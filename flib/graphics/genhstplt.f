* * * * * GENHSTPLT * * * * *
c	  
c	  GENHSTPLT is a general-purpose interface to the BSHST and BSPLT
c	  histogram and 2-dimensional data plotting routines.  See the
c	  documentation of those routines for instructions on operating them.
c	  
c	  The data file may have 1 or more columns of data values for each
c	  individual.  Before the first column of data, one may place a "type"
c	  value for each individual.  One can then form "groups" of values
c	  by combining individuals of one or more types.  If there are no type
c	  values, then there is only one group, consisting of all individuals
c	  in the file.  The actual type values are completely arbitrary and
c	  need not be 1, 2, 3, etc.  Once groups are formed, they are referred
c	  to in order as 1, 2, etc.
c	  
c	  The file may have lines at the beginning which can be skipped by the
c	  program.  The number of columns of data values (exclusive of the
c	  optional type value) may be put in the file, in the line just before
c	  the data begin, or it may be entered into the program interactively.
c	  
c	  Symbol types are selected by number, but the numbers have different
c	  meanings for symbols on the parallax and on the laser printer.
c	  Symbols 1 to 8 will appear on the parallax as the standard WIMP
c	  modeling symbols: filled and open circle, square, and triangle, X
c	  and +.  Symbols 1 to 19 are available for plots on the laser printer
c	  and yield the standard symbols generated by IMSYMB.  0 will give no
c	  symbol; a negative value will produce the characters corresponding
c	  to the point number for each data value instead of a symbol; except 
c	  that -2 will produce completely filled areas in histograms.
c
c	  Entries to the program are:
c
c	  0 for plots on the parallax, or 1 for plots only on the terminal.
c	  .  Enter 0 if the parallax is free, otherwise enter 1.  Note that if
c	  .  you need to use terminal plots, you will need to specify that
c	  .  option each time that you do a plot.
c	  
c	  0 if there are just data values, or 1 if there are also types
c	  
c	  Number of columns of data values (excluding the optional types).
c	  .  Enter 0 if the number of columns is to be read just before the
c	  .   data.
c	  
c	  Number of lines to skip at start of file.  Do not count the line
c	  .  telling the number of columns, if there is one and you just
c	  .  entered 0 to the last question.
c	  
c	  Data file name
c	  
c	  IF there are types, next enter:
c
c	  .  Number of groups.  Enter the negative of the number of there is
c	  .     only one type per group, as a shortcut.
c
c	  .  IF you entered a positive number, then enter for each group:
c
c	  .     Number of types in group, symbol number
c	  .     The type values for the types in the group
c	  
c	  .  BUT IF you entered a negative number, then enter for each group
c	  .     the type value and the symbol number
c	  
c	  IF there are no type values, just enter the symbol number to be used.
c	  
c	  Next enter the column number of the data to be examined next.
c	  
c	  Next specify how the data are scaled:
c	  .  To leave the data alone, enter 0,0
c	  .  To take the logarithm after adding some base amount to the data,
c	  .     enter 1 and the base amount
c	  .  If the data are already logarithms, enter -1,0
c	  
c	  The program now enters BSHST, which you can skip through if desired.
c	  
c	  You are now at an option point, which you may return to repeatedly
c	  while running the program.  Your choices are:
c	  
c	  .  1 to examine a new data column
c	  .  2 to enter BSPLT and plot the column just examined as a set of Y
c	  .     values versus the previous column, as a set of X values.
c	  .  3 to plot the column just examined versus the previous column,
c	  .     first grouping points within each group on the basis of their
c	  .     X values and forming means and standard deviations within
c	  .     groups (see below)
c	  .  4 to loop back and define new groups and/or symbols
c	  .  5 to loop back to the start of the program and open a new file
c	  .  6 to plot the current metacode file on workstation screen
c	  .  7 or 209 to plot the current metacode file on laser printer
c	  .  8 or -123 to exit the program
c	  .  9 to plot the column just examined versus the previous column as
c	  .     series of Tukey box plots, one Tukey box per group.
c	  .  10 to plot values with error bars based on S.D. values in another
c	  .     column of the data file.
c	  .  11 to group points based upon their X values in the previous
c	  .    column (as in option 3) and then divide the average of the
c	  .    current column by the average of some other column
c	  .  12 to select subsets of the data based on the values in some
c	  .    other column than the ones being plotted
c	  
c	  If you select option 3, you first choose whether to plot error bars
c	  as a multiple of standard deviation or standard error of the mean,
c	  or as confidence limits.  Enter a positive number to get bars equal
c	  to that number of S.D.'s, or a negative value to get bars equal to
c	  that number of S.E.M.'s, or a positive number greater than 30 to get
c	  confidence limits at that percentage level (e.g., 90 for 90%
c	  confidence limits).  Then, for each group of types, you will be told
c	  how many data points there are.  Enter the number of groupings that
c	  you want to combine these points into, then enter the number of
c	  points to include in each of the groupings, or just a / to divide
c	  the points equally among the groupings.  If you enter individual
c	  numbers for each grouping, they should add up to the total number of
c	  points in that group of types.
c
c	  If you select option 9, then when the data are plotted on the
c	  printer, they will appear as Tukey box plots for each group.
c	  Each such box shows the median and 25 and 50 percentile values of the
c	  set of Y values for the group; lines and ticks show the 10 and 90
c	  percentile points, and symbols are plotted for any data values
c	  outside the 10 and 90 percentile levels.  The box is plotted at the
c	  mean X coordinate of the points in the group.
c	  
c	  If you select option 10, you first choose whether to plot error bars
c	  as a multiple of standard deviation or standard error of the mean,
c	  or as confidence limits.  Enter a positive number to get bars equal
c	  to that number of S.D.'s, or a negative value to get bars equal to
c	  that number of S.E.M.'s, or a positive number greater than 30 to get
c	  confidence limits at that percentage level (e.g., 90 for 90%
c	  confidence limits).  If you select S.D.'s, next enter the column
c	  number in the data file that contains the S.D.'s.  Otherwise, enter
c	  two column numbers: the one with the S.D.'s and one with N's.  Both
c	  of these parameters are needed to plot S.E.M.'s or confidence limits.
c	  
c	  If you select option 11, you first enter a value for error bars as
c	  in option 3.  Then enter the column to divide the current column by.
c	  Then specify the groupings of points for each group of data.  The
c	  default groupings will have nearly equal SUMS for the denominators.
c	  The program will compute and print out for each set of points the
c	  following values: mean of previous column (X), mean of current
c	  column, SD of current column, mean of denominator column, mean of
c	  current divided by mean of denominator column (Y), SD of current
c	  divided by mean of denominator (SD associated with Y), and number
c	  of points in the set.  Error bars based on the resulting SD values
c	  may or may not be meaningful depending on the nature of the data.
c
c	  If you select option 12, first enter the number of the column that
c	  will be used to test whether to include data.  Then enter a lower
c	  and upper limit to a range of values, plus either 0 to include only
c	  values in that range, or 1 to exclude values in that range.  Use this
c	  option repeatedly to enter multiple selection criteria.  Data points
c	  will have to meet all of the criteria to be included in the plots.
c	  After entering one or more selection criteria, you must select data
c	  by specifying columns with option 1.  To cancel all of the criteria,
c	  specify option 12 and enter 0 for the column.
c
c	  $Author$
c
c	  $Date$
c
c	  $Revision$
c
c	  $Log$
c	  Revision 3.1  2002/01/28 16:06:05  mast
c	  Added ability to select data based on values in columns
c	

	parameter (len=100000,leng=5000)
	dimension dmat(len*10),xx(len),ngx(len),zz(len)
     1,yy(len),itype(len),itgrp(50,50),nsymb(50),ntypg(50)
	dimension ngxa(leng),avgx(leng),avgy(leng),nnav(leng),sdy(len)
	real*4 selmin(50),selmax(50)
	integer*4 icolsel(50),ifselexcl(50)
	character*80 name
c
	iffil=0
	iftypes=0
	ncol=2
	nskip=0
	iflogxin=0
	zadd=0
	nselect=0
5	continue
c	  HVEM version only
	write(*,'(1x,a,$)')
     &	    '0 for Plax screen plots, 1 for terminal only: '
	read(5,*)iffil
c
	call grfopn(iffil)
c
	write(*,'(1x,a,$)')'0 if there are just data values, or 1 if'//
     &	    ' there are types in first column: '
	read(5,*)iftypes
c	  
	write(*,'(1x,a,$)')'Number of columns of data values '//
     &	    '(or 0 to read as first line before data): '
	read(5,*)ncol
c	  
	write(*,'(1x,a,$)')
     &	    'Number of lines to skip at start of file: '
	read(5,*)nskip
c
10	call flnam(name,1,'0')
	close(1)
	open(1,file=name,status='old',err=10)
c
	do 11 i=1,nskip
	  read(1,'(a)')name
11	continue
	if(ncol.eq.0) read(1,*)ncol
c
	nd=0
12	i=nd+1
	jst=(i-1)*ncol+1
	jnd=i*ncol
	if(iftypes.eq.0)then
	  read(1,*,end=18)(dmat(j),j=jst,jnd)
	  itype(i)=1
	else
	  read(1,*,end=18)itype(i),(dmat(j),j=jst,jnd)
	endif
	nd=i
	go to 12
18	write(*,'(i5,a)')nd,' lines of data'
c	  
20	if(iftypes.ne.0)then
	  write(*,'('' # of groups (neg. if one Type/group): '',$)')
	  read(5,*)ngrps
	  ifotpg=0
	  if(ngrps.lt.0)then
	    ngrps=-ngrps
	    ifotpg=1
	    ntyps=1
	  endif
	  do 220 j=1,ngrps
	    write(*,*) 'for group #',j	
	    if(ifotpg.ne.0)then
	      write(*,'('' Type # and symbol #: '',$)')
	      read(5,*)itgrp(1,j),nsymb(j)
	    else
	      write(*,'('' # of Types and symbol #: '',$)')
	      read(5,*)ntyps,nsymb(j)
	      write(*,'('' Types: '',$)')
	      read(5,*)(itgrp(i,j),i=1,ntyps)
	    endif
	    ntypg(j)=ntyps
220	  continue
	else
	  ngrps=1
	  itgrp(1,1)=1
	  ntypg(1)=1
	  write(*,'(1x,a,$)')'Symbol #: '
	  read(5,*)nsymb(1)
	endif
c
30	if(ncol.gt.1)then
	  write(*,'('' Column number: '',$)')
	  read(5,*)icol
	else
	  icol=1
	endif
	if(icol.le.0.or.icol.gt.ncol)go to 20
c
	iflogy=iflogx
	do i=1,nx
	  yy(i)=xx(i)
	enddo
c
	write(*,'(1x,a,$)') '1 or 2 to take log or sqr root '//
     &	    '(-1 if it already is log), base to add: '
	read(5,*)iflogxin,zadd
c
	iflogx=iflogxin
	nx=0
	do igrp=1,ngrps
	  do k=1,nd
	    ingroup=0
	    do j=1,ntypg(igrp)
	      if(itype(k).eq.itgrp(j,igrp))ingroup=1
	    enddo
c	      
c	      check that it passes all selections too
c	      
	    do isel=1,nselect
	      selval=dmat((k-1)*ncol+icolsel(isel))
	      if(ifselexcl(isel).ne.0.xor.(selval.lt.selmin(isel).or.
     &		  selval.gt.selmax(isel)))ingroup=0
	    enddo
	    if(ingroup.gt.0)then
	      nx=nx+1
	      ngx(nx)=igrp
	      xx(nx)=dmat((k-1)*ncol+icol)
	      if(iflogx.gt.0)then
		if(iflogx.eq.2)xx(nx)=sqrt(xx(nx)+zadd)
		if(iflogx.ne.2)xx(nx)=alog10(xx(nx)+zadd)
	      endif
	    endif
	  enddo
	enddo
c
	if(iflogx.eq.2)iflogx=0
	iflogx=iabs(iflogx)
	call gnhst(xx,ngx,nx,nsymb,ngrps,iflogx)
c
50	write(*,104)
104	format(' Enter 1 for new column,',
     &	    '   2 for plot of this column versus previous column,',/,
     &	    '       3 for X/Y plot of averages of groups of points'
     &	    ' or 11 with column ratios',/,
     &	    '       4 to define new groups/symbols,',
     &	    '   5 to open a new file,',/,
     &	    '       6 or 7 to plot metacode file on screen or printer,',
     &	    '   8 to exit program,',/,
     &	    '       9 for Tukey box plots,'
     &	    '   10 for X/Y plot with error bars using S.D.''s,',/,
     &	    '       12 to set columns to select on')
	read(5,*)iopt
	if(iopt.eq.-123)go to 99
	if(iopt.eq.209)iopt=7
	if(iopt.le.0.or.iopt.gt.12)go to 50
	go to(30,60,70,20,5,90,90,99,110,70,70,130)iopt
c
60	call gnplt(yy,xx,ngx,nx,nsymb,ngrps,iflogy,iflogx)
	go to 50
c
70	write(*,'(1x,a,/,a,$)')'For the error bars, enter the # of '//
     &	    'S.D.''s, or - the # of S.E.M.''s,',
     &	    '   or a large # for confidence limits at that % level: '
	read(5,*)fsd
	if (iopt.eq.10)go to 120
	if(iopt.eq.11)then
	  write(*,'(1x,a,$)')'Column to divide current column by: '
	  read(5,*)icolden
	endif
	nplt=0
	igrpstr=1
c
	do 80 igrp=1,ngrps
	  if(ngrps.gt.1)write(*,*)
     &	      ' Define groupings of points for group #',igrp
c	    
	  ningrp=0
	  do 72 i=igrpstr,nx
	    if(ngx(i).ne.igrp)go to 74
	    ningrp=ningrp+1
72	  continue
74	  if(iopt.eq.11)then
	    ix=0
	    do k=1,nd
	      ingroup=0
	      do j=1,ntypg(igrp)
		if(itype(k).eq.itgrp(j,igrp))ingroup=1
	      enddo
	      if(ingroup.gt.0)then
		ix=ix+1
		zz(ix)=dmat((k-1)*ncol+icolden)
	      endif
	    enddo
	  endif
c
	  if(ningrp.gt.0)then
	    if(iopt.eq.11)then
	      call grupnt3(yy(igrpstr),xx(igrpstr),zz,ningrp,
     &		  avgx(nplt+1),avgy(nplt+1),sdy(nplt+1),nnav,ngav)
	    else
	      call grupnt(yy(igrpstr),xx(igrpstr),ningrp,avgx(nplt+1)
     &		  ,avgy(nplt+1),sdy(nplt+1),nnav,ngav)
	    endif
c
	    do 76 i=1,ngav
	      semval=sdy(nplt+i)/sqrt(float(nnav(i)))
	      if(fsd.gt.30..and.nnav(i).gt.1)then
		ifail=0
c		tcrit=g01caf(dble((1.+0.01*fsd)/2.),nnav(i)-1,ifail)
		tcrit=tvalue((1.+0.01*fsd)/2.,nnav(i)-1)
		sdy(nplt+i)=tcrit*semval
	      elseif(fsd.ge.0)then
		sdy(nplt+i)=fsd*sdy(nplt+i)
	      elseif(nnav(i).gt.1)then
		sdy(nplt+i)=-fsd*semval
	      endif
	      ngxa(nplt+i)=igrp
76	    continue
c
	    nplt=nplt+ngav
	    igrpstr=igrpstr+ningrp
	  endif
80	continue
	call errplt(avgx,avgy,ngxa,nplt,nsymb,ngrps,sdy,iflogy,iflogx)
	go to 50
c	    
110	sdy(1)=-9999.
	print *,'Enter an X value for each group, or / to use X',
     &	    ' values in previous column'
	read(5,*)(sdy(i),i=1,ngrps)
	if(sdy(1).ne.-9999.)then
	  do 142 i=1,nx
	    yy(i)=sdy(ngx(i))
142	  continue
	endif
	call boxplt(yy,xx,ngx,nx,nsymb,ngrps,sdy,iflogy,iflogx)
	go to 50
c	  
120	if(fsd.ge.0.and.fsd.le.30.)then
	  write(*,'(1x,a,$)')'Column number with S.D.''s: '
	  read(5,*)icolsd
	else
	  write(*,'(1x,a,$)')'Column numbers with S.D.''s and n''s: '
	  read(5,*)icolsd,icolnn
	endif
	ix=0
	do 140 igrp=1,ngrps
	  do 138 k=1,nd
	    ingroup=0
	    do 136 j=1,ntypg(igrp)
	      if(itype(k).eq.itgrp(j,igrp))ingroup=1
136	    continue
	    if(ingroup.gt.0)then
	      ix=ix+1
	      sdval=dmat((k-1)*ncol+icolsd)
	      sdy(ix)=fsd*sdval
	      if(fsd.lt.0..or.fsd.gt.30.)then
		nnval=dmat((k-1)*ncol+icolnn)
		semval=sdval/sqrt(float(nnval))
		if(nnval.le.1)then
		  sdy(ix)=0.
		elseif(fsd.lt.0.)then
		  sdy(ix)=-fsd*semval
		else
		  ifail=0
c		  tcrit=g01caf(dble((1.+0.01*fsd)/2.),nnval-1,ifail)
		  tcrit=tvalue((1.+0.01*fsd)/2.,nnval-1)
		  sdy(ix)=tcrit*semval
		endif
	      endif
	    endif
138	  continue
140	continue
	call errplt(yy,xx,ngx,nx,nsymb,ngrps,sdy,iflogy,iflogx)
	go to 50
c
90	continue
	call pltout(7-iopt)
	go to 50
c	  
130	write(*,'(1x,a,$)')
     &	    'New column to select on, or 0 to clear selections: '
	read(5,*)icolin
	if(icolin.le.0)then
	  nselect=0
	  go to 50
	endif
	nselect=nselect+1
	icolsel(nselect)=icolin
	write(*,'(1x,a,/,a,$)')'Minimum and maximum values for that '
     &	    //'column, and 0 to include or ',
     &	    '  1 to exclude values in that range: '
	read(5,*)selmin(nselect),selmax(nselect),ifselexcl(nselect)
	go to 50
c	  
99	call plxoff
	call imexit
	end

	subroutine grupnt3(xx,yy,zz,np,avgx,avgy,sdy,nn,ng)
	dimension xx(*),avgx(*),sdy(*),yy(*),nn(*),avgy(*),zz(*)
	integer*2 ind(10000)
c  given a list of np points (xx,yy), it asks how many contiguous
c  non-overlapping groups (ng) to divide into, and number of points in
c  each group (nn), orders the points by x value, finds the mean x value
c  (avgx), and the mean and sd y value (avgy and sdy)
	sz=0.
	do 5 i=1,np
	  ind(i)=i
	  sz=sz+zz(i)
5	continue
c  build an index to order the points by xx
	do 8 i=1,np-1
	  do 6 j=i+1,np
	    if(xx(ind(i)).gt.xx(ind(j)))then
	      itmp=ind(i)
	      ind(i)=ind(j)
	      ind(j)=itmp
	    endif
6	  continue
8	continue
	write(*,*) np,' points'
	write(*,'('' number of groups: '',$)')
	read(*,*)ng
	thrshint=sz/max(1,ng)
	thresh=thrshint
	ncum=0
	ig=1
	zcum=0.
	do 14 ii=1,np
	  i=ind(ii)
	  if(zcum+zz(i).ge.thresh)then
	    thresh=thresh+thrshint
	    nn(ig)=ii-ncum
	    ncum=ii
	    ig=ig+1
	  endif
	  zcum=zcum+zz(i)
14	continue
	if(ig.eq.ng)nn(ig)=np-ncum
	write(*,'(1x,a,$)')'# of points in each group (/ for equal '//
     &	    'denominators): '
	read(5,*)(nn(i),i=1,ng)
	ii=1
	do 20 ig=1,ng
	  sx=0.
	  sy=0.
	  sz=0.
	  sysq=0.
	  n=nn(ig)
	  do 10 in=1,n
	    i=ind(ii)
	    ii=ii+1
	    sx=sx+xx(i)
	    sy=sy+yy(i)
	    sz=sz+zz(i)
	    sysq=sysq+yy(i)**2
10	  continue
	  avgx(ig)=sx/n
	  avgyig=sy/n
	  avgz=sz/n
	  avgy(ig)=avgyig/avgz
	  sdyig=0.
	  if(n.gt.1)sdyig=sqrt((sysq-n*avgyig**2)/(n-1.))
	  sdy(ig)=sdyig/avgz
	  write(*,101)avgx(ig),avgyig,sdyig,avgz,avgy(ig),sdy(ig),nn(ig)
101	  format(6f10.4,i5)
20	continue
	return
	end
