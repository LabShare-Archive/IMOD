#!/usr/bin/env python
# imodkillgroup - kill a process group given member PID or tree below given PID
#
# Author: David Mastronarde
#
# $Id$
#

progname = 'imodkillgroup'
prefix = 'ERROR: ' + progname + ' - '

def processStatus(pid = None):
   statDict = {}
   if windows:
      procList = []
      try:
         if pid:
            procList.append(psutil.Process(pid))
         else:
            procList = psutil.process_iter();
      except Exception:
         exitError('Getting process list from psutil: ' +  str(sys.exc_info()[1]))
      for proc in procList:
         if proc.pid:
            try:
               statDict[proc.pid] = (proc.ppid, proc.exe, proc)
               #prnstr(fmtstr('{}  {}  {}', proc.pid, proc.ppid, proc.exe))
            except psutil.AccessDenied:
               pass
            except psutil.NoSuchProcess:
               pass
            except Exception:
               prnstr('Exception accessing status for pid ' + str(proc.pid) + ': ' +
                      str(sys.exc_info()[1]))
               pass
      return statDict
         
   # Now get a command with desired columns, or basic cygwin one
   command = 'ps -aeo pid,ppid,comm'
   if cygwin:
      command = 'ps -al'
   if pid:
      command += ' -p ' + str(pid)
   try:
      pslines = runcmd(command)
   except ImodpyError:
      exitFromImodError(progname)

   # Split up the lines and fetch the fields; skip leading S,I in cygwin
   for line in pslines[1:]:
      ind = 0
      if cygwin:
         ind = max(0, line.find(' '))
      lsplit = line[ind:].split()
      if len(lsplit) < 3:
         continue
      try:
         if cygwin:
            statDict[int(lsplit[0])] = (int(lsplit[1]), lsplit[len(lsplit) - 1], 
                                        int(lsplit[2]))
         else:
            statDict[int(lsplit[0])] = (int(lsplit[1]), lsplit[len(lsplit) - 1])
      except ValueError:
         continue
   
   return statDict


def killGroup(groupid):
   try:
      os.killpg(groupid, signal.SIGKILL)
   except OSError:
      return 'Error killing processes with group ID ' + str(groupid) + ': ' + \
                   str(sys.exc_info()[1])
   return None
      

#### MAIN PROGRAM  ####
#
# load System Libraries
import os, sys, signal, time

#
# Setup runtime environment
if sys.platform.find("win32") < 0:
   try:
      signal.signal(signal.SIGHUP, signal.SIG_IGN)
   except:
      pass
if os.getenv('IMOD_DIR') != None:
   os.environ['PATH'] = os.path.join(os.environ['IMOD_DIR'], 'bin') + \
                        os.pathsep + os.environ['PATH']
   sys.path.insert(0, os.path.join(os.environ['IMOD_DIR'], 'pylib'))
else:
   sys.stdout.write(prefix + " IMOD_DIR is not defined!\n")
   sys.exit(1)

#
# load IMOD Libraries
from imodpy import *
from pip import exitError, setExitPrefix
setExitPrefix(prefix)

cygwin = 'cygwin' in sys.platform
windows = 'win32' in sys.platform
killTree = False
pidList = {}
verbose = False
maxTrials = 5

# Get/check arguments
try:
   for arg in sys.argv[1:]:
      if arg == '-t':
         killTree = True
      elif arg == '-v':
         verbose = True
      else:
         pidList[int(arg)] = None

except ValueError:
   exitError('Unrecognized option or non-integer entry: ' + arg)

if not pidList:
   prnstr("""Usage: imodkillgroup [-t] PID [PID ...]'
       Kills whole process group given PID of any member, or just kills process
       tree below each PID if -t option is given.  Takes multiple PIDs from
       different groups""")
   sys.exit(0)

if windows:
   try:
      import psutil
   except ImportError:
      exitError('The psutil module must be installed to kill processes from Windows ' +\
                'Python')


exitVal = 0
if not killTree and not windows:
   for pidKill in pidList:
      
      # Get the group ID
      try:
         groupid = os.getpgid(pidKill)
         if verbose:
            prnstr('Group id: ' + str(groupid))
      except OSError:
         prnstr('Error getting group ID for PID ' + str(pidKill) + ': ' + \
                str(sys.exc_info()[1]))
         exitVal += 1
         continue

      # For Unix-type systems, the group kill should be fine
      if not cygwin:
         mess = killGroup(groupid)
         if mess:
            prnstr(mess)
            exitVal += 1

      # For cygwin, it might fail, so get a ps listing first, build list of the group
      # processes, then repeatedly kill the group and check if it is all gone
      else:
         psdict = processStatus()
         groupStats = {}
         for pid in psdict:
            if psdict[pid][2] == groupid:
               groupStats[pid] = psdict[pid]

         messList = []
         for trial in range(maxTrials):
            mess = killGroup(groupid)
            messList.append(mess)
            if mess and verbose:
               prnstr(mess)
               
            time.sleep(0.05)
            psdict = processStatus()
            numLeft = 0
            for pid in groupStats:
               if pid in psdict and psdict[pid][2] == groupid and \
                  psdict[pid][0] == groupStats[pid][0] and \
                  psdict[pid][1] == groupStats[pid][1]:
                  numLeft += 1
            if not numLeft:
               break
            prnstr(fmtstr('{} processes left in group after trial {}', numLeft, trial))
         else:    # ELSE ON FOR
            prnstr('Kill of group failed, messages on trials:')
            for ind in range(messList):
               if messList[ind]:
                  prnstr(str(ind) + ':  ' + messList[ind])
            exitVal += 1

   sys.exit(exitVal)

# For TREE KILL, Start an array of PID's for each level
pidTree = [pidList]
for level in range(100):

   # Need a ps to get going for cygwin maybe windows too
   if not level and (cygwin or windows):
      psdict = processStatus()

   # Stop processes for PID's at the current level
   # In windows/cygwin only stop python and tcsh processes, due to a cygwin bug
   # where stopped tilt could not be killed
   for pid in pidTree[level]:
      stopProc = True
      if cygwin or windows:
         stopProc = False

         # In cygwin, it seemed to help to stop only the controlling scripts, hence this
         # test.  But bad things still happen even with stopping them, so there is no
         # stop for cygwin here.  Selective stop occurs in Windows out of superstition.
         if pid in psdict:
            stopProc = 'python' in psdict[pid][1] or 'tcsh' in psdict[pid][1]

            # For windows, save the process object now if it is found in this process list
            if windows:
               if verbose:
                  prnstr('Saving process object for PID ' + str(pid))
               pidTree[level][pid] = psdict[pid][2]

      if stopProc:
         stopstr = 'Stopping PID ' + str(pid)
         if (level or cygwin or windows) and pid in psdict:
            stopstr += ': ' + psdict[pid][1]
         if verbose:
            prnstr(stopstr)
         try:
            if windows:
               psdict[pid][2].suspend()
            elif not cygwin:
               os.kill(pid, signal.SIGSTOP)
         except Exception:
            prnstr('Error occurred trying to stop ' + str(pid) + ': ' + \
                str(sys.exc_info()[1]))
      
   # Get a ps and first find out if each PID is still there
   psdict = processStatus()
   pidTree.append({})
   for pid in pidTree[level]:
      if not pid in psdict:
         prnstr('PID ' + str(pid) + ' is no longer in the process list')
         exitVal += 1
         pidTree[level][pid] = -1
         
   # find children of these processes
   for pid in psdict:
      parent = psdict[pid][0]
      if parent in pidTree[level] and (not windows or pidTree[level][parent]):
         pidTree[level + 1][pid] = None
         if verbose:
            prnstr(fmtstr('Adding child {} - {} of {} at level {}', pid, psdict[pid][1], 
                          parent, level))

   if not pidTree[level + 1]:
      break

# Kill all the processes from the bottom level up
for level in range(len(pidTree) - 1, -1, -1):
   for pid in pidTree[level]:
      if isinstance(pidTree[level][pid], int):
         continue
      if verbose and (not windows or pidTree[level][pid]):
         prnstr(fmtstr('Killing PID {} at level {}', pid, level))

      try:
         if windows:
            proc = pidTree[level][pid]
            if proc:
               proc.kill()
         else:
            os.kill(pid, signal.SIGKILL)
      except Exception:
         prnstr('Error occurred trying to kill ' + str(pid) + ': ' + \
                str(sys.exc_info()[1]))
         exitVal += 1

sys.exit(exitVal)

   
         
      
             
