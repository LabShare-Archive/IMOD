#!/usr/bin/python -u
# tomostitch - program to perform tasks in final stitching of a supermontage:
# running findwarp, warpvol, densmatch, newstack, and blendmont
#
# Author: David Mastronarde
#
# $Id$
# Log at end
#

# FUNCTIONS

# Run densmatch 
def runDensmatch(args):
    denscom = 'densmatch -report ' + args
    if verbose:
        print denscom
    try:
        densout = runcmd(denscom, None)
    except ImodpyError, errout:
        exitFromImodError(progname, errout)
                
    for l in densout:
        if l.find('SD =') >= 0:
            print l,
        indcolon = l.find(':')
        if indcolon >= 0 and l.startswith('Scale factor'):
            scaling = l[indcolon + 1:].split()
            if len(scaling) != 2:
                print prefix + \
                      " Could not find two numbers on Scale factor line"
                sys.exit(1)
            return scaling

    print prefix + " No Scale factor line found in output"
    sys.exit(1)

# Take product of scaling between volumes and scaling of reference volume
def scalingProduct(scale1, scale2):
    return (scale1[0] * scale2[0], scale1[0] * scale2[1] + scale1[1])

# Take inverse of a scaling
def scalingInverse(scale):
    return (1. / scale[0], -scale[1] / scale[0])


#### MAIN PROGRAM  ####
#
# load System Libraries
import os, sys, os.path, signal

progname = 'tomostitch'
prefix = 'ERROR: ' + progname + ' - '

#
# Setup runtime environment
if sys.platform.find("win32") < 0:
    try:
        signal.signal(signal.SIGHUP, signal.SIG_IGN)
    except:
        pass
if os.getenv('IMOD_DIR') != None:
    os.environ['PATH'] = os.path.join(os.environ['IMOD_DIR'], 'bin') + \
                         os.pathsep + os.environ['PATH']
    sys.path.append(os.path.join(os.environ['IMOD_DIR'], 'pylib'))
else:
    print prefix + " IMOD_DIR is not defined!"
    sys.exit(1)

#
# load IMOD Libraries
from imodpy import *
from pip import *
from supermont import *

setSMErrorPrefix(prefix)

# Initializations
targets = '0.1,0.2,0.3'
discount = 0.5
numMatchIter = 100
matchWidthFrac = 0.3
matchLengthFrac = 0.7
clipsize = 600

# Fallbacks from ../manpages/autodoc2man 3 1 tomostitch
options = ["info:InfoFile:FN:", "xrun:XRunStartEnd:IP:",
           "yrun:YRunStartEnd:IP:", "zrun:ZRun:I:",
           "thickness:ThicknessToOutput:I:", "find:FindWarping:B:",
           "warp:WarpVolumes:B:", "stack:StackVolumes:B:",
           "blend:BlendVolumes:B:", "verbose:VerboseOutput:I:",
           "target:TargetMeanResidual:FA:",
           "measured:MeasuredRatioMinAndMax:FP:",
           "discount:DiscountIfZeroVectors:F:",
           "tempdir:TemporaryDirectory:CH:",
           "density:DensityReferenceFrame:IPM:",
           "match:MatchingWidthXandY:IP:", "length:MatchingLengthXandY:IP:",
           "xminmax:StartingAndEndingX:IP:",
           "yminmax:StartingAndEndingY:IP:", "bin:BinByFactor:I:",
           "oldedge:OldEdgeFunctions:B:", "goodedge:GoodEdgeLowAndHighZ:IP:",
           "onegood:OneGoodEdgeLimits:IAM:",
           "exclude:ExcludeFillFromEdges:B:", "width:BlendingWidthXandY:IP:",
           "boxsize:BoxSizeShortAndLong:IP:"]

(numOpts, numNonOpts) = PipReadOrParseOptions(sys.argv, options, progname, 1, \
        1, 0)
infofile = PipGetInOutFile('InfoFile', 0)
if not infofile:
    print prefix + " Info file name must be entered"
    sys.exit(1)


predata = {}
pieces = []
edges = []
slices = []
readMontInfo(infofile, predata, slices, pieces, edges)
(xmin, xmax, ymin, ymax, zmin, zmax, zlist) = montMinMax(pieces)

# Get the extent in X and Y
xrunStart, yrunStart = -10000, -10000
xrunEnd, yrunEnd = 10000, 10000

xrunStart, xrunEnd = PipGetTwoIntegers('XRunStartEnd', xrunStart, xrunEnd)
yrunStart, yrunEnd = PipGetTwoIntegers('YRunStartEnd', yrunStart, yrunEnd)
xrunStart = max(xrunStart, xmin)
yrunStart = max(yrunStart, ymin)
xrunEnd = min(xrunEnd, xmax)
yrunEnd = min(yrunEnd, ymax)

# Get the section to do in Z
if len(zlist) > 1:
    zrun = PipGetInteger('ZRun', 0)
    if PipGetErrNo() == 1:
        print prefix + " Z value to run must be specified"
        sys.exit(1)

    for z in zlist:
        if z == zrun:
            break
    else:
        print prefix + " the Z value entered is not in the info file"
        sys.exit(1)
else:
    zrun = zlist[0]

# Find the section data for this z
for i in range(len(slices)):
    if int(slices[i][kZvalue]) == zrun:
        slice = slices[i]
        indSlice = i
        if not (slice.has_key(kSpacing) and slice.has_key(kOutsize) and \
                slice.has_key(kSample)):
            print prefix + " The info file is missing spacing, output size, " \
                  + " or interval factor data for this section"
            sys.exit(1)
        xoutSize = slice[kOutsize][0]
        youtSize = slice[kOutsize][1]
        zoutSize = slice[kOutsize][2]
        xSpacing = slice[kSpacing][0]
        ySpacing = slice[kSpacing][1]
        sampleFac = float(slice[kSample])
        slicename = slice['name']
        break
else:
    print prefix + " There is no section data for this Z in the info file"
    sys.exit(1)

# Get thickness and a bunch of other parameters
zoutSize = PipGetInteger('ThicknessToOutput', zoutSize)
if zoutSize < 1:
    print prefix + " Illegal thickness value"
    sys.exit(1)
refFrameX, refFrameY = PipGetTwoIntegers('DensityReferenceFrame', -1, -1)
minRatio = 4. / (sampleFac * sampleFac * sampleFac)
maxRatio = 12. / (sampleFac * sampleFac * sampleFac)
minRatio, maxRatio = PipGetTwoFloats('MeasuredRatioMinAndMax', minRatio, \
                                     maxRatio)
targets = PipGetString('TargetMeanResidual', targets)
discount = PipGetFloat('DiscountIfZeroVectors', discount)
tempdir = PipGetString('TemporaryDirectory', " ")
goodLowZ, goodHiZ = PipGetTwoIntegers('GoodEdgeLowAndHighZ', -1, -1)
blendWidthX, blendWidthY = PipGetTwoIntegers('BlendingWidthXandY', -1, -1)
boxShort, boxLong = PipGetTwoIntegers('BoxSizeShortAndLong', -1, -1)
binFactor = PipGetInteger('BinByFactor', 1)
oldedges = PipGetBoolean('OldEdgeFunctions', 0)
excludeFill = PipGetBoolean('ExcludeFillFromEdges', 0)
matchWidthX, matchWidthY = PipGetTwoIntegers('MatchingWidthXandY', -1, -1)
matchLengthX, matchLengthY = PipGetTwoIntegers('MatchingLengthXandY', -1, -1)
verbose = PipGetInteger('VerboseOutput', 0)

# X/Y start and end converted here to a string
xblst, xblnd = PipGetTwoIntegers('StartingAndEndingX', 0, 0)
if PipGetErrNo():
    xstnd = '/'
else:
    xstnd = "%d %d" % (xblst, xblnd)
yblst, yblnd = PipGetTwoIntegers('StartingAndEndingY', 0, 0)
if PipGetErrNo():
    ystnd = '/'
else:
    ystnd = "%d %d" % (yblst, yblnd)

numOneGood = PipNumberOfEntries('OneGoodEdgeLimits')
oneGoods = []
if numOneGood:
    for i in range(0, numOneGood):
        oneGood = PipGetIntegerArray('OneGoodEdgeLimits', 5)
        oneGoods.append(oneGood)


# Find out what operations to do
dofind = PipGetBoolean('FindWarping', 0)
dowarp = PipGetBoolean('WarpVolumes', 0)
doblend = PipGetBoolean('BlendVolumes', 0)
dostack = PipGetBoolean('StackVolumes', 0)
if not (dofind + dowarp + doblend + dostack):
    dofind, dowarp, doblend, dostack = 1, 1, 1, 1
if dofind and ((doblend and not (dowarp and dostack)) or \
               (dostack and not dowarp)):
    print prefix + 'If you run findwarp you must run each following step in ' \
          'sequence'
    sys.exit(1)
if dowarp and doblend and not dostack:
    print prefix + 'If you run Warpvol you need to stack the data before '\
          'blending'
    sys.exit(1)

PipDone()

# Build a piece map 
xdim = xmax + 1 - xmin
maxPieces = xdim * (ymax + 1 - ymin)
if xdim <= 0 or maxPieces <= 0:
    print prefix + " Illegal range of pieces to run specified"
    sys.exit(1)

pieceMap = []
for i in range(maxPieces):
    pieceMap.append(-1)
for i in range(len(pieces)):
    fxyz = pieces[i][kFrame]
    if fxyz[2] == zrun:
        pieceMap[fxyz[0] - xmin + xdim * (fxyz[1] - ymin)] = i

# Run findwarp
if dofind:
    failed = []
    print 'Running findwarp with min and max ratios of measured to unknowns' \
              ' of: %.1f  %1.f' % (minRatio, maxRatio)
    for y in range(yrunStart, yrunEnd + 1):
        for x in range(xrunStart, xrunEnd + 1):
            ind = pieceMap[x - xmin + xdim * (y - ymin)]
            if ind >= 0:
                if not (pieces[ind].has_key(kVectors) and \
                        pieces[ind].has_key(kMatxf)):
                    print '%s Frame %d %d is missing an initial transform or '\
                          'warping vectors' % (prefix, x, y)
                    sys.exit(1)
                patname = pieces[ind][kVectors]
                xfname = pieces[ind][kMatxf]
                warpname = changeExtension(xfname, '.warpxf')
                resname = changeExtension(xfname, '_res.patch')
                resmod = changeExtension(xfname, '_res.mod')
                input = ['VolumeOrSizeXYZ %d %d %d' % (xoutSize, youtSize,
                                                       zoutSize),
                         'TargetMeanResidual ' + targets,
                         'DiscountIfZeroVectors %f' % discount,
                         'MeasuredRatioMinAndMax %f %f' % (minRatio, maxRatio),
                         'PatchFile ' + patname,
                         'OutputFile ' + warpname,
                         'InitialTransformFile ' + xfname,
                         'ResidualPatchOutput ' + resname]
                try:
                    print '\nRunning findwarp on frame %d %d\n' % (x, y)
                    fwout = runcmd('findwarp -StandardInput', input, 'stdout')

                    print " "
                except ImodpyError, errout:
                    failed.append((x, y))

                if os.path.exists(resname):
                    patchcom = 'patch2imod -s 5 -f -c %d -n  ' % (clipsize) +\
                    '"Values are residuals; clip planes exist" ' + \
                               '-z %s %s' % (resname, resmod)
                    runcmd(patchcom, None)

    if len(failed):
        print '\n\nTo summarize, Findwarp failed on frames:'
        for frames in failed:
            print '      x %d  y %d' % frames
        print prefix + 'Findwarp did not succeed on all frames'
        sys.exit(1)

# Run warpvol
if dowarp:
    for y in range(yrunStart, yrunEnd + 1):
        for x in range(xrunStart, xrunEnd + 1):
            ind = pieceMap[x - xmin + xdim * (y - ymin)]
            if ind >= 0:
                if not pieces[ind].has_key(kMatxf):
                    print '%s No initial transform has been computed for ' \
                          'frame %d %d' % (prefix, x, y)
                    sys.exit(1)
                xfname = pieces[ind][kMatxf]
                warpname = changeExtension(xfname, '.warpxf')
                aliname = changeExtension(xfname, '.warped')
                if not os.path.exists(warpname):
                    print '%s No warping transform file is found for ' \
                          'frame %d %d' % (prefix, x, y)
                    sys.exit(1)
                    
                input = ['OutputSizeXYZ %d %d %d' % (xoutSize, youtSize,
                                                     zoutSize),
                         'InputFile ' + pieces[ind]['file'],
                         'OutputFile ' + aliname,
                         'TransformFile ' + warpname]
                if tempdir != ' ':
                    input.append('TemporaryDirectory ' + tempdir)
                if verbose:
                    print input
                try:
                    print '\nRunning warpvol on frame %d %d\n' % (x, y)
                    runcmd('warpvol -StandardInput', input)

                except ImodpyError, errout:
                    exitFromImodError(progname, errout)

# Densmatch and stack volumes and make piece list: first check size and number
if dostack:
    numStack = 0
    refNum = -1
    aliList = []
    plist = []
    listMap = { }
    for y in range(yrunStart, yrunEnd + 1):
        for x in range(xrunStart, xrunEnd + 1):
            ind = pieceMap[x - xmin + xdim * (y - ymin)]
            if ind >= 0:
                if not pieces[ind].has_key(kMatxf):
                    print '%s No initial transform has been computed for ' \
                          'frame %d %d' % (prefix, x, y)
                    sys.exit(1)
                xfname = pieces[ind][kMatxf]
                aliname = changeExtension(xfname, '.warped')
                if not os.path.exists(aliname):
                    print '%s No aligned volume is found for ' \
                          'frame %d %d' % (prefix, x, y)
                    sys.exit(1)
                
                try:
                    xstmp, ystmp, zstmp = getmrcsize(aliname)
                except ImodpyError, errout:
                    exitFromImodError(progname, errout)

                # First stack, record size and reference if not specified,
                # otherwise check for size match
                if not numStack:
                    xsize = xstmp
                    ysize = ystmp
                    zsize = zstmp
                    if refFrameX == -1 and refFrameY == -1:
                        refNum = 0
                elif xsize != xstmp or ysize != ystmp or zsize != zstmp:
                    print prefix + 'All aligned volumes are not the same size'
                    sys.exit(1)

                listMap[ind] = len(aliList)
                aliList.append(aliname)
                if refFrameX == x and refFrameY == y:
                    refNum = numStack
                numStack += 1

                # Add lines to piece list array.  Start coordinates at 0
                xcoord = (x - xrunStart) * xSpacing
                ycoord = (y - yrunStart) * ySpacing
                for i in range(zsize):
                    line = '%d  %d  %d\n' % (xcoord, ycoord, i)
                    plist.append(line)

    if refNum < 0:
        print prefix + 'The reference frame is not in the range being blended'
        sys.exit(1)

    if numStack < 2:
        print prefix + 'There is only one frame in the given range and no ' \
              'need to stack and blend'
        sys.exit(1)

    # Run densmatch; first do old global matching if either width is 0
    sclList = []
    if matchWidthX == 0 or matchWidthY == 0:
        for i in range(numStack):
            if i != refNum:
                print 'Running densmatch on ' + aliList[i]
                scaling = runDensmatch(aliList[refNum] + ' ' + aliList[i])
                sclList.append(scaling[0] + ',' + scaling[1])
            else:
                sclList.append('1,0')

    else:

        # Analyze all the overlaps in the range being run
        # First build arrays to get to lower and upper pieces
        lowerPcX = []
        lowerPcY = []
        upperPcX = []
        upperPcY = []
        lowerSclX = []
        lowerSclY = []
        pcScalings = []
        for y in range(yrunStart, yrunEnd + 1):
            for x in range(xrunStart, xrunEnd + 1):
                ind = pieceMap[x - xmin + xdim * (y - ymin)]
                if ind >= 0:
                    pcInd = listMap[ind]
                    pcScalings.append(None)

                    # Look up lower piece in X and run densmatch on overlap
                    loInd = -1
                    loScl = (1., 0.)
                    if x > xrunStart:
                        ind = pieceMap[x - 1 - xmin + xdim * (y - ymin)]
                        if ind >= 0:
                            loInd = listMap[ind]
                            overlap = xsize - xSpacing
                            width = matchWidthX
                            if width < 0:
                                width = int(matchWidthFrac * overlap)
                            ixmin = int(xSpacing + overlap / 2 - width / 2)
                            ixmax = int(ixmin + width - 1)
                            length = matchLengthY
                            if matchLengthY <= 0:
                                length = int(matchLengthFrac * ysize)
                            iymin = int(ysize / 2 - length / 2)
                            iymax = int(iymin + length - 1)
                            args = '-xminmax %d,%d -yminmax %d,%d -offset ' % \
                                   (ixmin, ixmax, iymin, iymax) + \
                                   '%d,0,0 %s %s' % \
                                   (-xSpacing, aliList[loInd], aliList[pcInd])
                            print 'Running densmatch in overlap between piece'\
                                  + ' %d %d and piece %d %d' % (x-1, y, x, y)
                            scaling = runDensmatch(args)
                            loScl = (float(scaling[0]), float(scaling[1]))
                            
                    lowerPcX.append(loInd)
                    lowerSclX.append(loScl)

                    # Look up upper piece in X
                    upInd = -1
                    if x < xrunEnd:
                        ind = pieceMap[x + 1 - xmin + xdim * (y - ymin)]
                        if ind >= 0:
                            upInd = listMap[ind]
                    upperPcX.append(upInd)

                    # Look up lower piece in Y and run densmatch
                    loInd = -1
                    loScl = (1., 0.)
                    if y > yrunStart:
                        ind = pieceMap[x - xmin + xdim * (y - 1 - ymin)]
                        if ind >= 0:
                            loInd = listMap[ind]
                            overlap = ysize - ySpacing
                            width = matchWidthY
                            if width < 0:
                                width = int(matchWidthFrac * overlap)
                            iymin = int(ySpacing + overlap / 2 - width / 2)
                            iymax = int(iymin + width - 1)
                            length = matchLengthX
                            if matchLengthX <= 0:
                                length = int(matchLengthFrac * xsize)
                            ixmin = int(xsize / 2 - length / 2)
                            ixmax = int(ixmin + length - 1)
                            args = '-xminmax %d,%d -yminmax %d,%d -offset ' % \
                                   (ixmin, ixmax, iymin, iymax) + \
                                   '0,%d,0 %s %s' % \
                                   (-ySpacing, aliList[loInd], aliList[pcInd])
                            print 'Running densmatch in overlap between piece'\
                                  + ' %d %d and piece %d %d' % (x, y-1, x, y)
                            scaling = runDensmatch(args)
                            loScl = (float(scaling[0]), float(scaling[1]))

                    lowerPcY.append(loInd)
                    lowerSclY.append(loScl)

                    # Look up upper piece in Y
                    upInd = -1
                    if y < yrunEnd:
                        ind = pieceMap[x - xmin + xdim * (y + 1 - ymin)]
                        if ind >= 0:
                            upInd = listMap[ind]
                    upperPcY.append(upInd)

        # Start with the reference piece defined and then analyze pieces
        # adjacent to ones with scaling defined on first iteration
        # Thereafter, just compute a scale from all neighbors to distribute the
        # error equally between the pieces
        pcScalings[refNum] = (1., 0.)
        for iter in range(numMatchIter):
            addedScale = True
            verbout = (verbose and (iter < 4 or iter >= numMatchIter - 2)) or \
                      verbose == 2
            if verbout:
                print '\nIteration %d:' % (iter + 1)
            while addedScale:
                addedScale = False
                newScalings = { }
                for i in range(numStack):
                    if (iter == 0 and pcScalings[i] != None) or i == refNum:
                        continue
                    numScales = 0
                    multsum = 0.
                    addsum = 0.
                    loInd = lowerPcX[i]
                    if loInd >= 0 and pcScalings[loInd] != None:
                        netscl = scalingProduct(pcScalings[loInd], \
                                                lowerSclX[i])
                        multsum += netscl[0]
                        addsum += netscl[1]
                        numScales += 1
                        if verbout:
                            if numScales == 1:
                                print ''
                            print 'Piece %d from lower X, net scale %.5f %.2f'\
                                  % (i, netscl[0], netscl[1])

                    loInd = lowerPcY[i]
                    if loInd >= 0 and pcScalings[loInd] != None:
                        netscl = scalingProduct(pcScalings[loInd], \
                                                lowerSclY[i])
                        multsum += netscl[0]
                        addsum += netscl[1]
                        numScales += 1
                        if verbout:
                            if numScales == 1:
                                print ''
                            print 'Piece %d from lower Y, net scale %.5f %.2f'\
                                  % (i, netscl[0], netscl[1])

                    upInd = upperPcX[i]
                    if upInd >= 0 and pcScalings[upInd] != None:
                        invscl = scalingInverse(lowerSclX[upInd])
                        netscl =  scalingProduct(pcScalings[upInd], invscl)
                        multsum += netscl[0]
                        addsum += netscl[1]
                        numScales += 1
                        if verbout:
                            if numScales == 1:
                                print ''
                            print 'Piece %d from upper X, net scale %.5f %.2f'\
                                  % (i, netscl[0], netscl[1])

                    upInd = upperPcY[i]
                    if upInd >= 0 and pcScalings[upInd] != None:
                        invscl = scalingInverse(lowerSclY[upInd])
                        netscl =  scalingProduct(pcScalings[upInd], invscl)
                        multsum += netscl[0]
                        addsum += netscl[1]
                        numScales += 1
                        if verbout:
                            if numScales == 1:
                                print ''
                            print 'Piece %d from upper Y, net scale %.5f %.2f'\
                                  % (i, netscl[0], netscl[1])

                    if numScales:
                        newScalings[i] = (multsum / numScales, \
                                          addsum / numScales) 
                        addedScale = True
                        if numScales > 1 and verbout:
                            print 'Piece %d mean scale %.5f  %.2f' % \
                                  (i, newScalings[i][0], newScalings[i][1])

                # Now if any were added, set them into the array of scales
                if addedScale:
                    for i in newScalings.keys():
                        pcScalings[i] = newScalings[i]
                if iter > 0:
                    addedScale = False


        # Now just convert the scalings into strings
        for i in range(numStack):
            sclList.append('%f,%f' % (pcScalings[i][0], pcScalings[i][1]))


    # Compose the newstack command, report scaling, and run newstack
    newstcom = 'newstack'
    print ''
    for y in range(yrunStart, yrunEnd + 1):
        for x in range(xrunStart, xrunEnd + 1):
            ind = pieceMap[x - xmin + xdim * (y - ymin)]
            if ind >= 0:
                i = listMap[ind]
                scaling = sclList[i].split(',')
                print 'Piece %d %d: multiply by %.5f, add %.2f' % \
                      (x, y, float(scaling[0]), float(scaling[1]))
                newstcom += ' -multadd ' + sclList[i] + ' ' + aliList[i] 

    newstcom += ' ' + slicename + '.st'
    print '\nStacking the volumes into ' + slicename + '.st'
    if verbose:
        print newstcom
    try:
        newstout = runcmd(newstcom, None)
    except ImodpyError, errout:
        exitFromImodError(progname, errout)
    l = newstout[len(newstout) - 1]
    if l.find('TRUNCATIONS') >= 0:
        print l
    
    # Make the piece list file
    try:
        plname = slicename + '.pl'
        makeBackupFile(plname)
        plfile = open(plname, 'w')
        plfile.writelines(plist)
        plfile.close()
    except:
        print prefix + 'Opening or writing to piece list file ' + plname
        sys.exit(1)

    slices[indSlice][kXstacked] = [xrunStart, xrunEnd]
    slices[indSlice][kYstacked] = [yrunStart, yrunEnd]

# Now is a good time to write the info file
if dofind or dowarp or dostack:
    writeMontInfo(infofile, predata, slices, pieces, edges)

# Blend!
if doblend:
    input = ['ImageInputFile\t' + slicename + '.st',
             'PieceListInput\t' + slicename + '.pl',
             'ImageOutputFile\t' + slicename + '.bl',
             'RootNameForEdges\t' + slicename,
             'OldEdgeFunctions\t%d' % oldedges,
             'StartingAndEndingX\t' + xstnd,
             'StartingAndEndingY\t' + ystnd,
             'ExcludeFillFromEdges\t%d' % excludeFill]
    if binFactor > 1:
        input.append('BinByFactor\t %d' % binFactor)
    if goodLowZ >= 0 and goodHiZ >=0:
        input.append('GoodEdgeLowAndHighZ\t%d %d' % \
                     (goodLowZ - 1, goodHiZ - 1))

    # Get range of slices to look over for edge limits
    xlo = xmin
    xhi = xmax
    ylo = ymin
    yhi = ymax
    if slices[indSlice].has_key(kXstacked):
        xlo = slices[indSlice][kXstacked][0]
        xhi = slices[indSlice][kXstacked][1]
    if slices[indSlice].has_key(kYstacked):
        ylo = slices[indSlice][kYstacked][0]
        yhi = slices[indSlice][kYstacked][1]

    # Loop on all edges
    for edge in edges:
        zlo = -1
        zhi = -1
        xpc = edge[kLower][0]
        ypc = edge[kLower][1]
        xory = 1
        if edge[kXorY] == 'Y':
            xory = 2
        if edge[kLower][2] == zrun and xpc >= xlo and xpc <= xhi and \
           ypc >= ylo and ypc <= yhi:

            
            # If and edge has lower piece in range and has a limit, take it
            if edge.has_key(kGoodlim):
                zlo = edge[kGoodlim][0]
                zhi = edge[kGoodlim][1]

            # Then search entries for overriding values for this edge
            for i in range(numOneGood):
                if oneGoods[i][0] == xpc and oneGoods[i][1] == ypc and \
                   oneGoods[i][2] == xory:
                    zlo = oneGoods[i][3]
                    zhi = oneGoods[i][4]

            # Add to input if any found
            if zlo >= 0 and zhi >= 0:
                input.append('OneGoodEdgeLimits\t%d %d %d %d %d' % \
                             (xpc + 1 - xlo, ypc + 1 - ylo, xory, \
                              zlo - 1, zhi - 1))

    # Output a command file before running it
    comlist = ['$blendmont -StandardInput\n']
    for l in input:
        comlist.append(l + '\n')
    comname = 'blend_' + slicename + '.com'
    makeBackupFile(comname)
    try:
        comfile = open(comname, 'w')
        comfile.writelines(comlist)
        comfile.close()
        print 'Command file to run blendmont output to ' + comname
    except:
        print 'WARNING: unable to open or write new command file' + comname

    print 'Running blendmont to build ' + slicename + '.bl'
    try:
        runcmd('blendmont -StandardInput', input, 'stdout')
    except ImodpyError, errout:
                exitFromImodError(progname, errout)

sys.exit(0)

#
# $Log$
# Revision 1.9  2009/08/20 22:19:54  mast
# Add some debug output
#
# Revision 1.8  2009/01/26 01:27:57  mast
# Zrun is an integer, not integer pair
#
# Revision 1.7  2008/05/29 23:36:08  mast
# Made ExcludeFill an option passed to Blendmont
#
# Revision 1.6  2008/04/27 21:26:58  mast
# Modified to match densities across overlap zones and resolve into single
# density scaling, added options to control that and for verbose output
#
# Revision 1.5  2008/04/26 19:43:11  mast
# Added new density matching scheme based on overlap zones
#
# Revision 1.4  2008/04/10 19:28:12  mast
# Needed space after tempdir entry in command
#
# Revision 1.3  2008/04/08 21:41:14  mast
# Made it produce a resmod whenever residual file exists
#
# Revision 1.2  2007/04/10 21:46:29  mast
# Fixed initial bugs and added exclude fill to blend command
#
# Revision 1.1  2007/04/08 16:32:20  mast
# Added to package
