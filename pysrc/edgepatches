#!/usr/bin/python -u
# edgepatches - program to set up a supermontage, find overall shifts between
# pieces, and compute patch correlation vectors in the edges (pverlap zones)
#
# Author: David Mastronarde
#
# $Id$
#
# $Log$

# FUNCTIONS

# The meat of the computations - a function to find shifts on edges
def findEdgeShifts(lower, upper, edge):
    print "Finding global shifts for edge " + edge['name']
    
    # Compute the starting and ending coordinates in long
    # dimension and overlap dimension
    xyminlo = [0, 0]
    xymaxlo = [0, 0]
    xyminup = [0, 0]
    xymaxup = [0, 0]
    intshift = [int(round(edge[kShift][0])), int(round(edge[kShift][1])),
                int(round(edge[kShift][2]))]
    losize = lower[kSize]
    upsize = upper[kSize]

    # Allow for existing shift and cut long dimension to fit
    longhalf = int(longFrac * min(losize[delx], upsize[delx])) / 2
    mid = (losize[delx] - intshift[delx]) / 2
    longhalf = min((longhalf, mid, losize[delx] - 1 - mid, \
                    mid + intshift[delx], \
                    upsize[delx] - 1 - mid - intshift[delx]))
    xyminlo[delx] = mid - longhalf
    xymaxlo[delx] = xyminlo[delx] + 2 * longhalf - 1
    xyminup[delx] = xyminlo[delx] + intshift[delx]
    xymaxup[delx] = xymaxlo[delx] + intshift[delx]

    # get coordinates in short dimension, trim some here
    ovsize = losize[dely] + intshift[dely]
    trim = int(trimFrac * ovsize)
    xyminlo[dely] = trim - intshift[dely]
    xymaxlo[dely] = losize[dely] - 1 - trim
    xyminup[dely] = trim
    xymaxup[dely] = ovsize - 1 - trim
    tmpproj1 = edge['name'] + '.proj1'
    tmpproj2 = edge['name'] + '.proj2'
    tmpprojst = edge['name'] + '.projst'
    tmpxf = edge['name'] + '.projxf'
    try:
        print "Projecting overlap zones"
        projcom = 'xyzproj -ax Y -an 0,0,0 -mo 2 -xm %d,%d -ym %d,%d %s %s' % \
                  (xyminlo[0], xymaxlo[0], xyminlo[1], xymaxlo[1], \
                   lower['file'], tmpproj1)
        runcmd(projcom, None)
        projcom = 'xyzproj -ax Y -an 0,0,0 -mo 2 -xm %d,%d -ym %d,%d %s %s' % \
                  (xyminup[0], xymaxup[0], xyminup[1], xymaxup[1], \
                   upper['file'], tmpproj2)
        runcmd(projcom, None)
        runcmd('newstack %s %s %s' % (tmpproj1, tmpproj2, tmpprojst), None)
        padx = int(padFrac * (xymaxup[0] + 1 - xyminup[0]))
        pady = int(padFrac * (xymaxup[1] + 1 - xyminup[1]))

        print "Correlating projections of overlap zones"
        txccom = 'tiltxcorr -ang 0,0 -pad %d,%d -sigma1 0.03 -rot 0. %s %s' % \
                 (padx, pady, tmpprojst, tmpxf)
        txcout = runcmd(txccom, None)
        txcout.reverse()
        failed = 0
        for line in txcout:
            if re.search('View.*shifts', line):
                line = re.sub('View.*shifts *(\S+) *(\S+).*', '\\1 \\2', \
                              line).strip()
                line = line.split(' ')
                if isinstance(line, str) or len(line) < 2:
                    failed = 1
                break
        else:
            failed = 1
        if failed:
            print '%s Cannot find shift in output of tiltxcorr on edge %s' %\
                  (prefix, edge['name'])
            sys.exit(1)

        # Subtract amount to shift upper to get new coordinate shift
        intshift[0] -= int(round(float(line[0])))
        intshift[1] -= int(round(float(line[1])))
        print 'Shift from correlation: %.1f, %.1f     Total shift %d, %d' % \
              (-float(line[0]), -float(line[1]), intshift[0], intshift[1])
        
        # Get coordinates for extracting subvolumes
        cenlo = [0, 0, 0]
        cenup = [0, 0, 0]
        size = [0, 0, 0]
        pad = [0, 0, 0]
        taper = [0, 0, 0]
        for i in [0, 1, 2]:
            mid = (losize[i] - intshift[i]) / 2
            half = min((blockSize / 2, mid, losize[i] - 1 - mid, \
                        mid + intshift[i], upsize[i] - 1 - mid - intshift[i]))
            cenlo[i] = mid
            cenup[i] = mid + intshift[i]
            size[i] = 2 * half
            pad[i] = size[i] / 5
            taper[i] = size[i] / 10

        # Extract the volumes
        print "Extracting subvolumes at center of overlap"
        tmpvol1 = edge['name'] + '.vol1'
        tmpvol2 = edge['name'] + '.vol2'
        tmpcor = edge['name'] + '.cor'
        input = [lower['file'],
                 tmpvol1,
                 '%d,%d,%d' % (size[0], size[1], size[2]),
                 '%d,%d,%d' % (cenlo[0], cenlo[1], cenlo[2]),
                 '%d,%d,%d' % (pad[0], pad[1], pad[2]),
                 '%d,%d,%d' % (taper[0], taper[1], taper[2])]
        runcmd('tapervoledge', input)
        input[0] = upper['file']
        input[1] = tmpvol2
        input[3] = '%d,%d,%d' % (cenup[0], cenup[1], cenup[2])
        runcmd('tapervoledge', input)

        # Run clip, this order of files should give shift of B coordinates
        print "Correlating subvolumes to find 3D shift"
        clipcom = 'clip corr -3d -n 0 %s %s %s' % (tmpvol1, tmpvol2, tmpcor)
        clipout = runcmd(clipcom, None)
        for line in clipout:
            if line.startswith('('):
                line = re.sub('^.*\((.*)\).*', '\\1', line).strip().split(',')
                break
        if isinstance(line, str) or len(line) < 3:
            print '%s Cannot find shift in output of clip on edge %s' %\
                  (prefix, edge['name'])
            sys.exit(1)
        for i in [0, 1, 2]:
            edge[kShift][i] = intshift[i] + float(line[i])
        edge[kShiftDone] = '1'
        print 'Shift from correlation: %f, %f, %f    Total shift %d, %d %d' % \
              (float(line[0]), float(line[1]), float(line[2]), intshift[0], \
               intshift[1], intshift[2])

        # Clean up
        os.remove(tmpproj1)
        os.remove(tmpproj2)
        os.remove(tmpprojst)
        os.remove(tmpxf)
        os.remove(tmpvol1)
        os.remove(tmpvol2)
        os.remove(tmpcor)
        return

    except ImodpyError, errout:
        exitFromImodError(progname, errout)

# And a function to find the patches
def findPatches(lower, upper, edge):
    global borderXY
    print 'Computing patch correlations in edge ' + edge['name']

    # Find limits in lower volume; Z limits are numbered from 1 but min and
    # max are numbered from zero
    sizes = patchSize
    patchname = edge['name'] + '.patch'
    mins = [0, 0, 0]
    maxes = [0, 0, 0]
    numpat = [0, 0, 0]
    
    mins[2] = max(0, borderZ)
    maxes[2] = lower[kSize][2] - 1 - mins[2]
    if lower.has_key(kZlimit):
        mins[2] = max(0, lower[kZlimit][0] - 1)
        maxes[2] = min(lower[kSize][2] - 1, lower[kZlimit][1] - 1)
    if maxes[2] - mins[2] < 0.5 * sizes[2]:
        print '%s Z limits (%d and %d) too narrow for patch Z size (%d) for' \
              ' edge %s' % (prefix, mins[2] + 1, maxes[2] + 1, sizes[2], \
                            edge['name'])
        sys.exit(1)

    if maxes[2] - mins[2] < sizes[2]:
        sizes[2] = maxes[2] - mins[2]

    borderXY = max(0, borderXY)
    for i in [0, 1]:
        mins[i] = max(borderXY, borderXY - edge[kShift][i])
        maxes[i] = min(lower[kSize][i] - 1 - borderXY, \
                       upper[kSize][i] - 1 - borderXY - edge[kShift][i])

    # Get number of patches
    delta = intervals
    if edge[kXorY] == 'Y':
        delta = [intervals[1], intervals[0], intervals[2]]
    for i in [0, 1, 2]:
        numpat[i] = max(1, int(round(float(maxes[i] - mins[i] - sizes[i]) / \
                                     delta[i])) + 1)
    if forceZ > 0:
        numpat[2] = forceZ

    print 'Number of patches in X, Y, and Z: %d %d %d' % \
          (numpat[0], numpat[1], numpat[2])
    input = ['ReferenceFile ' + lower['file'],
             'FileToAlign ' + upper['file'],
             'OutputFile ' + patchname,
             'VolumeShiftXYZ %f %f %f' % (edge[kShift][0], edge[kShift][1],
                                          edge[kShift][2]),
             'PatchSizeXYZ %d %d %d' % (sizes[0], sizes[1], sizes[2]),
             'XMinAndMax %d %d' % (mins[0], maxes[0]),
             'YMinAndMax %d %d' % (mins[1], maxes[1]),
             'ZMinAndMax %d %d' % (mins[2], maxes[2]),
             'NumberOfPatchesXYZ %d %d %d' % (numpat[0], numpat[1], numpat[2])]

    if lower.has_key(kModel):
        input.append('RegionModel ' + lower[kModel])
    if upper.has_key(kModel):
        input.append('BRegionModel ' + upper[kModel])
    if kernel > 0.:
        input.append('KernelSigma %f' % kernel)

    try:
        csout = runcmd('corrsearch3d -StandardInput', input)
        edge[kPatch] = patchname
        csout.reverse()
        for line in csout:
            if line.find('per position') >= 0:
                print line,
                break
            
        modname = edge['name'] + '_ccc.mod'
        patchcom = 'patch2imod -n "Values are correlation coefficients" ' + \
                   '-s 5 -f %s %s' % (patchname, modname)
        runcmd(patchcom, None)
        return
    
    except ImodpyError, errout:
        exitFromImodError(progname, errout)

# Function to compose a name given the rootname, string values for positions,
# and flags for whether to add z and whether to put _ between x, y, z
def composeName(root, x, y, z, noz, under):
    name = root + '_x' + x
    if under:
        name += '_'
    name += 'y' + y
    if noz:
        return name
    if under:
        name += '_'
    name += 'z' + z
    return name

#### MAIN PROGRAM  ####
#
# load System Libraries
import os, sys, os.path, signal

progname = 'edgepatches'
prefix = 'ERROR: ' + progname + ' -'

#
# Setup runtime environment
if sys.platform.find("win32") < 0:
    try:
        signal.signal(signal.SIGHUP, signal.SIG_IGN)
    except:
        pass
if os.getenv('IMOD_DIR') != None:
    os.environ['PATH'] = os.path.join(os.environ['IMOD_DIR'], 'bin') + os.pathsep + os.environ['PATH']
    sys.path.append(os.path.join(os.environ['IMOD_DIR'], 'pylib'))
else:
    print prefix + " IMOD_DIR is not defined!"
    sys.exit(1)

#
# load IMOD Libraries
from imodpy import *
from pip import *
from supermont import *

setSMErrorPrefix(prefix)

# Initializations
recExt = '.rec'
addx, addy, addZlo, addZhi = 0,0,0,0
xOverlap, yOverlap = -1, -1
longFrac = 0.5
padFrac = 0.2
trimFrac = 0.1
blockSize = 200
patchSize = (100, 100, 50)
intervals = (80, 120, 50)
borderXY = 50
borderZ = 10
forceZ = 0
kernel = 0.

# Fallbacks from ../manpages/autodoc2man 3 1 edgepatches
options = ["info:InfoFile:FN:", "noz:NoZValues:B:", "root:RootName:CH:",
           "overlap:OverlapInXandY:IP:", "underscore:UnderscoreXYZ:B:",
           "ext:ExtensionOnVolumes:CH:", "xyadd:AddMontageXandY:IP:",
           "zadd:AddMontageZRange:IP:", "all:RunAll:B:",
           "xrun:XRunStartEnd:IP:", "yrun:YRunStartEnd:IP:",
           "zrun:ZRunStartEnd:IP:", "skip:SkipDone:B:", "redo:RedoShifts:B:",
           "size:PatchSizeXYZ:IT:", "intervals:IntervalsShortLongZ:IT:",
           "force:ForceNumberInZ:I:", "borders:BordersInXYandZ:IP:",
           "model:DefaultRegionModel:FN:", "kernel:KernelSigma:F:",
           "long:LongFraction:F:"]

(numOpts, numNonOpts) = PipReadOrParseOptions(sys.argv, options, progname, 2, \
        1, 0)
infofile = PipGetInOutFile('InfoFile', 0)
if not infofile:
    print prefix + " Info file name must be entered"
    sys.exit(1)

# Get the options for adding montage and check for legality
infoExists = os.path.exists(infofile)
(addx, addy) = PipGetTwoIntegers('AddMontageXandY', addx, addy)
addingxy = 1 - PipGetErrNo()
(addZlo, addZhi) = PipGetTwoIntegers('AddMontageZRange', addZlo, addZhi)
addingz = 1 - PipGetErrNo()
if addingz and not addingxy:
    print prefix +" You must enter -xyadd if you enter -zadd"
    sys.exit(1)
if addingxy and (addx <= 0 or addy <= 0):
    print prefix + " Illegal montage size in X or Y"
    sys.exit(1)
if addingz and (addZlo > addZhi or addZlo < 0 or addZhi < 0):
    print prefix + " Z values out of order or negative"
    sys.exit(1)
if infoExists and addingxy and not addingz:
    print prefix + " Info file exists; you must end -zadd along with -zyadd"
    sys.exit(1)

# Get other options needed for composing names and doing edges
underscore = PipGetBoolean('UnderscoreXYZ', 0)
rootname = PipGetString('RootName', "")
(xOverlap, yOverlap) = PipGetTwoIntegers('OverlapInXandY', xOverlap, yOverlap)
recExt = PipGetString('ExtensionOnVolumes', recExt)
longFrac = PipGetFloat('LongFraction', longFrac)
nozopt = PipGetBoolean('NoZValues', 0)
if nozopt and (addingxy and infoExists or addingz):
    print prefix + " You cannot enter -noz with -zadd or if adding a " + \
          "montage with an existing Info file"
    sys.exit(1)

# Get running options
anyrun = 0
xrunStart, yrunStart, zrunStart = -10000, -10000, -10000
xrunEnd, yrunEnd, zrunEnd = 10000, 10000, 10000

anyrun = PipGetBoolean('RunAll', anyrun)
if not anyrun:
    xrunStart, xrunEnd = PipGetTwoIntegers('XRunStartEnd', xrunStart, xrunEnd)
    anyrun += 1 - PipGetErrNo()
    yrunStart, yrunEnd = PipGetTwoIntegers('YRunStartEnd', yrunStart, yrunEnd)
    anyrun += 1 - PipGetErrNo()
    zrunStart, zrunEnd = PipGetTwoIntegers('ZRunStartEnd', zrunStart, zrunEnd)
    anyrun += 1 - PipGetErrNo()
skipDone = PipGetBoolean('SkipDone', 0)
redoShifts = PipGetBoolean('RedoShifts', 0)

# Get options related to patch correlation
intervals = PipGetThreeIntegers('IntervalsShortLongZ', intervals[0],
                                intervals[1], intervals[2])
borderXY, borderZ = PipGetTwoIntegers('BordersInXYandZ', borderXY, borderZ)
patchSize = PipGetThreeIntegers('PatchSizeXYZ', patchSize[0],
                                patchSize[1], patchSize[2])
defaultModel = PipGetString('DefaultRegionModel', "")
forceZ = PipGetInteger('ForceNumberInZ', forceZ)
kernel = PipGetFloat('KernelSigma', kernel)

PipDone()

# Initialize dictionary arrays, then read existing info file 
predata = {}
pieces = []
edges = []
slices = []
neededges = addingxy
if nozopt:
    predata[kNoZvals] = "1"
if infoExists:
    readMontInfo(infofile, predata, slices, pieces, edges)
    if not len(pieces):
        print prefix + " No pieces are defined in the Info file " + infofile
        sys.exit(1)
    (xmin, xmax, ymin, ymax, zmin, zmax, zlist) = montMinMax(pieces)

    # Figure out if we need to do edges here: are there any edges for each z?
    if not len(edges):
        neededges = 1
    if not neededges:
        for z in zlist:
            for edge in edges:
                if edge[kLower][2] == z:
                    break
            else:
                neededges = 1

    # Check for non-conflict between added and existing Z values
    if addingxy:
        for z in range(addZlo, addZhi + 1):
            if z in zlist:
               print '%s Z value %d is iz list from existing file and in' +\
               'list to add' % (prefix, x)
               sys.exit(1)

# Check that options have been entered for making edges
if neededges and (not rootname or xOverlap <= 0 or yOverlap <= 0):
    print prefix + ' You must enter a rootname and overlap values with' + \
          ' new pieces'
    sys.exit(1)

# Add the new pieces
if addingxy:
    predata[kNoZvals] = str(nozopt)
    for z in range(addZlo, addZhi + 1):
        for x in range(1, addx + 1):
            for y in range(1, addy + 1):
                fileroot = composeName(rootname, str(x), str(y), str(z), \
                                       nozopt, underscore)
                filename = fileroot + recExt
                if os.path.exists(filename):
                    piece = {}
                    pieces.append(piece)
                    piece[kFrame] = [x, y, z]
                    piece['file'] = filename
                    print 'Adding piece ' + filename
                    filename = fileroot + '_region.mod'
                    if os.path.exists(filename):
                        piece[kModel] = filename
                    elif defaultModel:
                        piece[kModel] = defaultModel

# Rescan Z values
(xmin, xmax, ymin, ymax, zmin, zmax, zlist) = montMinMax(pieces)

# Build a piece map and fill in size entries for pieces
xsize = xmax + 1 - xmin
xysize = xsize * (ymax + 1 - ymin)
maxPieces = (zmax + 1 - zmin) * xysize

pieceMap = []
for i in range(maxPieces):
    pieceMap.append(-1)
for i in range(len(pieces)):
    fxyz = pieces[i][kFrame]
    pieceMap[fxyz[0] - xmin + xsize * (fxyz[1] - ymin) + \
             xysize * (fxyz[2] - zmin)] = i
    if not pieces[i].has_key(kSize):
        try:
            pieces[i][kSize] = getmrcsize(pieces[i]['file'])
        except ImodpyError, errout:
            exitFromImodError(progname, errout)
    
# Add edges for Z values that don't have any
for z in zlist:
    for edge in edges:
        if edge[kLower][2] == z:
            break
    else:
        delx = 1
        dely = 0
        zbase = xysize * (z - zmin)
        for xory in ('X', 'Y'):
            for x in range(xmin, xmax + dely):
                for y in range(ymin, ymax + delx):
                    lower = pieceMap[x - xmin + xsize * (y - ymin) + zbase]
                    upper =  pieceMap[x + delx - xmin + xsize * \
                                      (y + dely - ymin) + zbase]

                    # An edge exists if lower and upper pieces exist
                    if lower >= 0 and upper >= 0:
                        edge = {}
                        edges.append(edge)
                        xstr = str(x)
                        ystr = str(y)

                        # Set up shift as default for corrsearch3d: half the
                        # difference in sizes
                        shift = []
                        for i in [0, 1, 2]:
                            shift.append(pieces[upper][kSize][i] / 2. - \
                                         pieces[lower][kSize][i] / 2.)

                        # Set name and shift based on X or Y edge
                        if delx:
                            xstr += '-' + str(x + 1)
                            shift[0] = xOverlap - pieces[lower][kSize][0]
                        else:
                            ystr += '-' + str(y + 1)
                            shift[1] = yOverlap - pieces[lower][kSize][1]
                        edge['name'] = composeName(rootname, xstr, ystr, \
                                                   str(z), nozopt, underscore)
                        edge[kXorY] = xory
                        edge[kLower] = [x, y, z]
                        edge[kShift] = shift
            delx = 0
            dely = 1

    # Add a Section section with name and z value
    for slice in slices:
        if slice[kZvalue] == z:
            break
    else:
        slice = {}
        slices.append(slice)
        if predata[kNoZvals]:
            slice[name] = rootname + '_' + str(z)
            slice[kZvalue] = str(z)
        else:
            slice[name] = rootname
            slice[kZvalue] = '0'
            
        

# Run the desired edges if any
if anyrun:
    xrunStart = max(xmin, xrunStart)
    xrunEnd = min(xmax, xrunEnd)
    yrunStart = max(ymin, yrunStart)
    yrunEnd = min(ymax, yrunEnd)
    zrunStart = max(zmin, zrunStart)
    zrunEnd = min(zmax, zrunEnd)
    for z in range(zrunStart, zrunEnd + 1):
        delx = 1
        dely = 0
        zbase = xysize * (z - zmin)
        for xory in ('X', 'Y'):
            for x in range(xrunStart, xrunEnd + dely):
                for y in range(yrunStart, yrunEnd + delx):
                    lower = pieceMap[x - xmin + xsize * (y - ymin) + zbase]
                    upper =  pieceMap[x + delx - xmin + xsize * \
                                      (y + dely - ymin) + zbase]
                    if lower >= 0 and upper >= 0:
                        for edge in edges:
                            if edge[kXorY] == xory and edge[kLower][0] == x \
                                   and edge[kLower][1] == y and \
                                   edge[kLower][2] == z:
                                break
                        else:
                            print '%s Failed to find %s edge in edges array '\
                                  'for lower piece %d %d %d' % (prefix, xory, \
                                                                x, y, z)
                            sys.exit(1)

                        if redoShifts or not edge.has_key(kShiftDone):
                            findEdgeShifts(pieces[lower], pieces[upper], edge)
                        if not (skipDone and edge.has_key(kPatch)):
                            findPatches(pieces[lower], pieces[upper], edge)
                        
            delx = 0
            dely = 1

# Write the info file 
writeMontInfo(infofile, predata, slices, pieces, edges)
print 'New info file written'
sys.exit(0)
