#!/usr/bin/python -u
# edgepatches - program to set up a supermontage, find overall shifts between
# pieces, and compute patch correlation vectors in the edges (pverlap zones)
#
# Author: David Mastronarde
#
# $Id$
# Log at end
#

# FUNCTIONS

# The meat of the computations - a function to find shifts on edges
def findEdgeShifts(lower, upper, edge):
   prnstr("Finding global shifts for edge " + edge['name'])
   
   # Compute the starting and ending coordinates in long
   # dimension and overlap dimension
   xyminlo = [0, 0]
   xymaxlo = [0, 0]
   xyminup = [0, 0]
   xymaxup = [0, 0]
   intshift = [int(round(edge[kShift][0])), int(round(edge[kShift][1])),
              int(round(edge[kShift][2]))]
   losize = lower[kSize]
   upsize = upper[kSize]

   # Allow for existing shift and cut long dimension to fit
   longhalf = int(longFrac * min(losize[delx], upsize[delx])) // 2
   mid = (losize[delx] - intshift[delx]) // 2
   longhalf = min((longhalf, mid, losize[delx] - 1 - mid, \
                   mid + intshift[delx], \
                   upsize[delx] - 1 - mid - intshift[delx]))
   xyminlo[delx] = mid - longhalf
   xymaxlo[delx] = xyminlo[delx] + 2 * longhalf - 1
   xyminup[delx] = xyminlo[delx] + intshift[delx]
   xymaxup[delx] = xymaxlo[delx] + intshift[delx]

   # get coordinates in short dimension, trim some here
   ovsize = losize[dely] + intshift[dely]
   trim = int(trimFrac * ovsize)
   xyminlo[dely] = trim - intshift[dely]
   xymaxlo[dely] = losize[dely] - 1 - trim
   xyminup[dely] = trim
   xymaxup[dely] = ovsize - 1 - trim
   tmpproj1 = edge['name'] + '.proj1'
   tmpproj2 = edge['name'] + '.proj2'
   tmpprojst = edge['name'] + '.projst'
   tmpxf = edge['name'] + '.projxf'
   try:
      prnstr("Projecting overlap zones")
      projcom = fmtstr('xyzproj -ax Y -an 0,0,0 -mo 2 -xm {},{} -ym {},{} ' +\
                       '{} {}', xyminlo[0], xymaxlo[0], xyminlo[1], \
                       xymaxlo[1], lower['file'], tmpproj1)
      if verbose:
         prnstr(projcom)
      runcmd(projcom, None)
      projcom = fmtstr('xyzproj -ax Y -an 0,0,0 -mo 2 -xm {},{} -ym {},{} ' + \
                       '{} {}', xyminup[0], xymaxup[0], xyminup[1], \
                       xymaxup[1], upper['file'], tmpproj2)
      if verbose:
         prnstr(projcom)
      runcmd(projcom, None)
      runcmd(fmtstr('newstack {} {} {}', tmpproj1, tmpproj2, tmpprojst), None)
      padx = int(padFrac * (xymaxup[0] + 1 - xyminup[0]))
      pady = int(padFrac * (xymaxup[1] + 1 - xyminup[1]))

      prnstr("Correlating projections of overlap zones")
      txccom = fmtstr('tiltxcorr -ang 0,0 -pad {},{} -sigma1 0.03 -rot 0. ' +\
                      '{} {}', padx, pady, tmpprojst, tmpxf)
      if verbose:
         prnstr(txccom)
      txcout = runcmd(txccom, None)
      verboseOutput('TILTXCORR OUTPUT:', txcout)
         
      txcout.reverse()
      failed = 0
      for line in txcout:
         if re.search('View.*shifts', line):
            line = re.sub('View.*shifts *(\S+) *(\S+).*', '\\1 \\2', \
                          line).strip()
            line = line.split(' ')
            if isinstance(line, str) or len(line) < 2:
               failed = 1
            break
      else:
         failed = 1
      if failed:
         exitError(fmtstr('Cannot find shift in output of tiltxcorr on ' +\
                          'edge {}', edge['name']))

      # Subtract amount to shift upper to get new coordinate shift
      if verbose:
         prnstr(fmtstr('Initial shift: {}, {}', intshift[0], intshift[1]))
      intshift[0] -= int(round(float(line[0])))
      intshift[1] -= int(round(float(line[1])))
      prnstr(fmtstr('Shift from correlation: {:.1f}, {:.1f}     Total shift' +\
                    ' {}, {}', -float(line[0]), -float(line[1]), intshift[0], \
                    intshift[1]))
      
      # Get coordinates for extracting subvolumes
      cenlo = [0, 0, 0]
      cenup = [0, 0, 0]
      size = [0, 0, 0]
      pad = [0, 0, 0]
      taper = [0, 0, 0]
      for i in [0, 1, 2]:
         mid = (losize[i] - intshift[i]) // 2
         half = min((blockSize // 2, mid, losize[i] - 1 - mid, \
                     mid + intshift[i], upsize[i] - 1 - mid - intshift[i]))
         cenlo[i] = mid
         cenup[i] = mid + intshift[i]
         size[i] = 2 * half
         pad[i] = size[i] // 5
         taper[i] = size[i] // 10

      # Extract the volumes
      prnstr("Extracting subvolumes at center of overlap")
      tmpvol1 = edge['name'] + '.vol1'
      tmpvol2 = edge['name'] + '.vol2'
      tmpcor = edge['name'] + '.cor'
      input = [lower['file'],
               tmpvol1,
               fmtstr('{},{},{}', size[0], size[1], size[2]),
               fmtstr('{},{},{}', cenlo[0], cenlo[1], cenlo[2]),
               fmtstr('{},{},{}', pad[0], pad[1], pad[2]),
               fmtstr('{},{},{}', taper[0], taper[1], taper[2])]
      verboseOutput('tapervoledge input for run 1', input)
      runcmd('tapervoledge', input)

      input[0] = upper['file']
      input[1] = tmpvol2
      input[3] = fmtstr('{},{},{}', cenup[0], cenup[1], cenup[2])
      verboseOutput('tapervoledge input for run 2', input)
      runcmd('tapervoledge', input)

      # Run clip, this order of files should give shift of B coordinates
      prnstr("Correlating subvolumes to find 3D shift")
      clipcom = fmtstr('clip corr -3d -n 0 {} {} {}', tmpvol1, tmpvol2, tmpcor)
      if verbose:
         prnstr(clipcom)
      clipout = runcmd(clipcom, None)
      verboseOutput('CLIP OUTPUT:', clipout)
      for line in clipout:
         if line.startswith('('):
            line = re.sub('^.*\((.*)\).*', '\\1', line).strip().split(',')
            break
      if isinstance(line, str) or len(line) < 3:
         exitError(fmtstr('Cannot find shift in output of clip on edge {}',\
               edge['name']))
      for i in [0, 1, 2]:
         edge[kShift][i] = intshift[i] + float(line[i])
      edge[kShiftDone] = '1'
      prnstr(fmtstr('Shift from correlation: {}, {}, {}    Total shift {}, ' +\
                    '{} {}', float(line[0]), float(line[1]), float(line[2]), \
             edge[kShift][0], edge[kShift][1], edge[kShift][2]))

      # Clean up
      os.remove(tmpcor)
      if leavetmp:
         return
      os.remove(tmpprojst)
      os.remove(tmpproj1)
      os.remove(tmpproj2)
      os.remove(tmpxf)
      os.remove(tmpvol1)
      os.remove(tmpvol2)
      return

   except ImodpyError:
      exitFromImodError(progname)

# And a function to find the patches
def findPatches(lower, upper, edge):
   global borderXY
   prnstr('Computing patch correlations in edge ' + edge['name'])

   # Find limits in lower volume; Z limits are numbered from 1 but min and
   # max are numbered from zero
   sizes = list(patchSize)
   patchname = edge['name'] + '.patch'
   mins = [0, 0, 0]
   maxes = [0, 0, 0]
   numpat = [0, 0, 0]

   # Heirarchy for Z limits is the option entry, then the entry for the lower
   # piece, then an entry for the edge
   # Mins and maxes for corrsearch3d are numbered from 1
   mins[2] = max(1, borderZ + 1)
   maxes[2] = lower[kSize][2] + 1 - mins[2]
   if kZlimit in lower:
      mins[2] = max(1, lower[kZlimit][0])
      maxes[2] = min(lower[kSize][2], lower[kZlimit][1])
   if kZlimit in edge:
      mins[2] = max(1, edge[kZlimit][0])
      maxes[2] = min(lower[kSize][2], edge[kZlimit][1])
   if maxes[2] - mins[2] < 0.5 * sizes[2]:
      exitError(fmtstr('Z limits ({} and {}) too narrow for patch Z size ' +\
                       '({}) for edge {}', mins[2] + 1, maxes[2] + 1, \
                       sizes[2], edge['name']))

   if maxes[2] - mins[2] < sizes[2]:
      sizes[2] = maxes[2] - mins[2]

   borderXY = max(0, borderXY)
   for i in [0, 1]:
      mins[i] = max(borderXY, borderXY - int(edge[kShift][i])) + 1
      maxes[i] = min(lower[kSize][i] - borderXY, \
                     upper[kSize][i] - borderXY - int(edge[kShift][i]))
      if maxes[i] - mins[i] <= sizes[i]:
         prnstr(fmtstr('{} Border in X and Y and/or patch size in {} needs ' +\
                       'to be\nERROR:     reduced to fit in overlap for ' +\
                       'edge {}', prefix, ('X','Y')[i], edge['name']))
         overspace = min(lower[kSize][i], upper[kSize][i] -edge[kShift][i])\
                     - max(0, -edge[kShift][i])
         wanted = 2. * borderXY + sizes[i]
         frac = overspace / wanted
         prnstr(fmtstr('ERROR:     Overlap = {}; e.g., X/Y border {} and ' +\
                       'patch size {} would work', overspace,
                       int(frac * borderXY), int(frac * sizes[i])))
         sys.exit(1)

   # Get number of patches
   delta = intervals
   if edge[kXorY] == 'Y':
      delta = [intervals[1], intervals[0], intervals[2]]
   for i in [0, 1, 2]:
      numpat[i] = max(1, int(round(float(maxes[i] - mins[i] - sizes[i]) / \
                                   delta[i])) + 1)
   if forceZ > 0:
      numpat[2] = forceZ

   prnstr(fmtstr('Number of patches in X, Y, and Z: {} {} {}', \
         numpat[0], numpat[1], numpat[2]))
   input = ['ReferenceFile ' + lower['file'],
            'FileToAlign ' + upper['file'],
            'OutputFile ' + patchname,
            fmtstr('VolumeShiftXYZ {:f} {:f} {:f}', edge[kShift][0], \
                   edge[kShift][1], edge[kShift][2]),
            fmtstr('PatchSizeXYZ {} {} {}', sizes[0], sizes[1], sizes[2]),
            fmtstr('XMinAndMax {} {}', mins[0], maxes[0]),
            fmtstr('YMinAndMax {} {}', mins[1], maxes[1]),
            fmtstr('ZMinAndMax {} {}', mins[2], maxes[2]),
            fmtstr('BSourceBorderXLoHi {} {}', borderXY, borderXY),
            fmtstr('BSourceBorderYZLoHi {} {}', borderXY, borderXY),
            fmtstr('NumberOfPatchesXYZ {} {} {}', numpat[0], numpat[1],
                   numpat[2])]

   if kModel in lower:
       input.append('RegionModel ' + lower[kModel])
   if kModel in upper:
      input.append('BRegionModel ' + upper[kModel])
   if kernel > 0.:
      input.append(fmtstr('KernelSigma {:f}', kernel))

   try:
      verboseOutput('CORRSEARCH3D COMMAND:', input)
      csout = runcmd('corrsearch3d -StandardInput', input)
      verboseOutput('CORRSEARCH3D OUTPUT:', csout)

      # There are new patches: clear out all keys for derived patches
      edge[kPatch] = patchname
      if kReduce in edge:
         del edge[kReduce]
      if kResid in edge:
         del edge[kResid]
      if kResEdit in edge:
         del edge[kResEdit]
      if kResEdit in edge:
         del edge[kResEdit]
      csout.reverse()
      for line in csout:
         if line.find('per position') >= 0:
            prnstr(line, end='')
            break
         
      modname = edge['name'] + '_ccc.mod'
      patchcom = 'patch2imod -n "Values are correlation coefficients" ' + \
                 fmtstr('-s 5 -f {} {}', patchname, modname)
      runcmd(patchcom, None)
      return
   
   except ImodpyError:
      exitFromImodError(progname)

# Function to compose a name given the rootname, string values for positions,
# and flags for whether to add z and whether to put _ between x, y, z
def composeName(root, x, y, z, noz, under):
   name = root + '_x' + x
   if under:
      name += '_'
   name += 'y' + y
   if noz:
      return name
   if under:
      name += '_'
   name += 'z' + z
   return name

# Function for verbose multiline output
def verboseOutput(startLine, outputLines):
   if verbose:
      if len(startLine):
         prnstr(startLine)
      for line in outputLines:
         if line.endswith('\n'):
            prnstr(line, end='')
         else:
            prnstr(line)
   return

#### MAIN PROGRAM  ####
#
# load System Libraries
import os, sys, os.path, signal

progname = 'edgepatches'
prefix = 'ERROR: ' + progname + ' - '

#
# Setup runtime environment
if sys.platform.find("win32") < 0:
   try:
      signal.signal(signal.SIGHUP, signal.SIG_IGN)
   except:
      pass
if os.getenv('IMOD_DIR') != None:
   os.environ['PATH'] = os.path.join(os.environ['IMOD_DIR'], 'bin') + \
                        os.pathsep + os.environ['PATH']
   sys.path.append(os.path.join(os.environ['IMOD_DIR'], 'pylib'))
else:
   sys.stdout.write(prefix + " IMOD_DIR is not defined!\n")
   sys.exit(1)

#
# load IMOD Libraries
from imodpy import *
from pip import *
from supermont import *

setSMErrorPrefix(prefix)

# Initializations
recExt = '.rec'
addx, addy, addZlo, addZhi = 0,0,0,0
addXlo, addXhi, addYlo, addYhi = 0,0,0,0
xOverlap, yOverlap = -1, -1
longFrac = 0.5
padFrac = 0.2
trimFrac = 0.1
blockSize = 200
patchSize = (100, 100, 50)
intervals = (80, 120, 50)
borderXY = 50
borderZ = 10
forceZ = 0
kernel = 0.
testMode = 0
verbose = 0
leavetmp = 0

# Fallbacks from ../manpages/autodoc2man 3 1 edgepatches
options = ["info:InfoFile:FN:", "noz:NoZValues:B:", "root:RootName:CH:",
           "overlap:OverlapInXandY:IP:", "underscore:UnderscoreXYZ:B:",
           "ext:ExtensionOnVolumes:CH:", "xyadd:AddMontageXandY:IP:",
           "zadd:AddMontageZRange:IP:", "model:DefaultRegionModel:FN:",
           "all:RunAll:B:", "xrun:XRunStartEnd:IP:", "yrun:YRunStartEnd:IP:",
           "zrun:ZRunStartEnd:IP:", "skip:SkipDone:B:", "redo:RedoShifts:B:",
           "long:LongFraction:F:", "size:PatchSizeXYZ:IT:",
           "intervals:IntervalsShortLongZ:IT:", "force:ForceNumberInZ:I:",
           "borders:BordersInXYandZ:IP:", "kernel:KernelSigma:F:",
           "test:TestMode:I:"]

(numOpts, numNonOpts) = PipReadOrParseOptions(sys.argv, options, progname, 2, \
                                              1, 0)
infofile = PipGetInOutFile('InfoFile', 0)
if not infofile:
   exitError("Info file name must be entered")

# Get the options for adding montage and check for legality
infoExists = os.path.exists(infofile)
(addx, addy) = PipGetTwoIntegers('AddMontageXandY', addx, addy)
addingxy = 1 - PipGetErrNo()
(addXlo, addXhi) = PipGetTwoIntegers('AddMontageXRange', addXlo, addXhi)
addingx = 1 - PipGetErrNo()
(addYlo, addYhi) = PipGetTwoIntegers('AddMontageYRange', addYlo, addYhi)
addingy = 1 - PipGetErrNo()
(addZlo, addZhi) = PipGetTwoIntegers('AddMontageZRange', addZlo, addZhi)
addingz = 1 - PipGetErrNo()
if addingz and not (addingxy or (addingx and addingy)):
   exitError("You must enter -xyadd or -xadd and -yadd if you enter " + \
         "-zadd")
if addingxy and (addingx or addingy):
   exitError("You cannot enter -addxy with -addx or -addy")
if (addingx and not addingy) or (addingy and not addingx):
   exitError("You must enter both -xadd and -yadd if you enter one")
if addingxy and (addx <= 0 or addy <= 0):
   exitError("Illegal montage size in X or Y")
if addingx and (addXlo > addXhi or addXlo < 0 or addXhi < 0):
   exitError("X values out of order or negative")
if addingy and (addYlo > addYhi or addYlo < 0 or addYhi < 0):
   exitError("Y values out of order or negative")
if addingz and (addZlo > addZhi or addZlo < 0 or addZhi < 0):
   exitError("Z values out of order or negative")
if infoExists and (addingxy or addingx or addingy) and not addingz:
   exitError("Info file exists; you must enter -zadd along with " + \
         "-xyadd or -xadd and -yadd")
if addingxy:
   addXlo = 1
   addXhi = addx
   addYlo = 1
   addYhi = addy
   addingx = 1

# Get other options needed for composing names and doing edges
underscore = PipGetBoolean('UnderscoreXYZ', 0)
rootname = PipGetString('RootName', "")
(xOverlap, yOverlap) = PipGetTwoIntegers('OverlapInXandY', xOverlap, yOverlap)
recExt = PipGetString('ExtensionOnVolumes', recExt)
longFrac = PipGetFloat('LongFraction', longFrac)
nozopt = PipGetBoolean('NoZValues', 0)
if nozopt and (addingx and infoExists or addingz):
   exitError(" You cannot enter -noz with -zadd or if adding a " + \
         "montage with an existing Info file")
if not nozopt and addingx and not addingz:
   exitError(" You must enter either -zadd to add volumes that have Z" + \
         "values")

# Get running options
anyrun = 0
xrunStart, yrunStart, zrunStart = -10000, -10000, -10000
xrunEnd, yrunEnd, zrunEnd = 10000, 10000, 10000

anyrun = PipGetBoolean('RunAll', anyrun)
if not anyrun:
   xrunStart, xrunEnd = PipGetTwoIntegers('XRunStartEnd', xrunStart, xrunEnd)
   anyrun += 1 - PipGetErrNo()
   yrunStart, yrunEnd = PipGetTwoIntegers('YRunStartEnd', yrunStart, yrunEnd)
   anyrun += 1 - PipGetErrNo()
   zrunStart, zrunEnd = PipGetTwoIntegers('ZRunStartEnd', zrunStart, zrunEnd)
   anyrun += 1 - PipGetErrNo()
skipDone = PipGetBoolean('SkipDone', 0)
redoShifts = PipGetBoolean('RedoShifts', 0)

# Get options related to patch correlation
intervals = PipGetThreeIntegers('IntervalsShortLongZ', intervals[0],
                                intervals[1], intervals[2])
borderXY, borderZ = PipGetTwoIntegers('BordersInXYandZ', borderXY, borderZ)
patchSize = PipGetThreeIntegers('PatchSizeXYZ', patchSize[0],
                                patchSize[1], patchSize[2])
defaultModel = PipGetString('DefaultRegionModel', "")
forceZ = PipGetInteger('ForceNumberInZ', forceZ)
kernel = PipGetFloat('KernelSigma', kernel)
testMode = PipGetInteger('TestMode', testMode)
if testMode > 1:
   leavetmp = 1
if testMode % 2:
   verbose = 1

patchParams = fmtstr("-size {},{},{} -interval {},{},{} -border {},{}", \
              patchSize[0], patchSize[1], patchSize[2], intervals[0],
               intervals[1], intervals[2], borderXY, borderZ)
if forceZ:
   patchParams += fmtstr(" -force {}", forceZ)
if kernel:
   patchParams += fmtstr(" -kernel {:.2f}", kernel)

PipDone()

# Initialize dictionary arrays, then read existing info file 
predata = {}
pieces = []
edges = []
slices = []
neededges = addingx

if nozopt:
   predata[kNoZvals] = "1"
if infoExists:
   readMontInfo(infofile, predata, slices, pieces, edges)
   if not len(pieces):
      exitError(" No pieces are defined in the Info file " + infofile)
   (xmin, xmax, ymin, ymax, zmin, zmax, zlist) = montMinMax(pieces)

   # Figure out if we need to do edges here: are there any edges for each z?
   if not len(edges):
      neededges = 1
   if not neededges:
      for z in zlist:
         for edge in edges:
            if edge[kLower][2] == z:
               break
         else:
            neededges = 1

   # Check for non-conflict between added and existing Z values
   if addingx:
      for z in range(addZlo, addZhi + 1):
         if z in zlist:
            exitError(fmtstr('Z value {} is in Z list from', z) + \
                      ' existing file and in list to add')

# Check that options have been entered for making edges
if neededges and (not rootname or (xOverlap <= 0 and yOverlap <= 0)):
   exitError(' You must enter a rootname and overlap values with' + \
         ' new pieces')
if addingx and addXhi > addXlo and xOverlap <= 0:
   exitError('You must enter a positive value for overlap in X ' + \
         'when adding multiple pieces in X')
if addingx and addYhi > addYlo and yOverlap <= 0:
   exitError('You must enter a positive value for overlap in Y ' + \
         'when adding multiple pieces in Y')

# Add the new pieces
addedData = 0
if addingx:
   predata[kNoZvals] = str(nozopt)
   for z in range(addZlo, addZhi + 1):
      for x in range(addXlo, addXhi + 1):
         for y in range(addYlo, addYhi + 1):
            fileroot = composeName(rootname, str(x), str(y), str(z), \
                                   nozopt, underscore)
            filename = fileroot + recExt
            if os.path.exists(filename):
               addedData = 1
               piece = {}
               pieces.append(piece)
               piece[kFrame] = [x, y, z]
               piece['file'] = filename
               prnstr('Adding piece ' + filename)
               filename = fileroot + '_region.mod'
               if os.path.exists(filename):
                  piece[kModel] = filename
               elif defaultModel:
                  piece[kModel] = defaultModel

# Rescan Z values
(xmin, xmax, ymin, ymax, zmin, zmax, zlist) = montMinMax(pieces)

# Build a piece map and fill in size entries for pieces
xsize = xmax + 1 - xmin
xysize = xsize * (ymax + 1 - ymin)
maxPieces = (zmax + 1 - zmin) * xysize

pieceMap = []
for i in range(maxPieces):
   pieceMap.append(-1)
for i in range(len(pieces)):
   fxyz = pieces[i][kFrame]
   pieceMap[fxyz[0] - xmin + xsize * (fxyz[1] - ymin) + \
          xysize * (fxyz[2] - zmin)] = i
   if not kSize in pieces[i]:
      addedData = 1
      try:
         pieces[i][kSize] = getmrcsize(pieces[i]['file'])
      except ImodpyError:
         exitFromImodError(progname)
   
# Add edges for Z values that don't have any
for z in zlist:
   for edge in edges:
      if edge[kLower][2] == z:
         break
   else:
      delx = 1
      dely = 0
      zbase = xysize * (z - zmin)
      for xory in ('X', 'Y'):
         for x in range(xmin, xmax + dely):
            for y in range(ymin, ymax + delx):
               lower = pieceMap[x - xmin + xsize * (y - ymin) + zbase]
               upper =  pieceMap[x + delx - xmin + xsize * \
                                 (y + dely - ymin) + zbase]

               # An edge exists if lower and upper pieces exist
               if lower >= 0 and upper >= 0:
                  addedData = 1
                  edge = {}
                  edges.append(edge)
                  xstr = str(x)
                  ystr = str(y)

                  # Set up shift as default for corrsearch3d: half the
                  # difference in sizes
                  shift = []
                  for i in [0, 1, 2]:
                     shift.append(pieces[upper][kSize][i] / 2. - \
                                  pieces[lower][kSize][i] / 2.)

                  # Set name and shift based on X or Y edge
                  if delx:
                     xstr += '-' + str(x + 1)
                     shift[0] = xOverlap - pieces[lower][kSize][0]
                  else:
                     ystr += '-' + str(y + 1)
                     shift[1] = yOverlap - pieces[lower][kSize][1]
                  edge['name'] = composeName(rootname, xstr, ystr, \
                                             str(z), nozopt, underscore)
                  edge[kXorY] = xory
                  edge[kLower] = [x, y, z]
                  edge[kShift] = shift
         delx = 0
         dely = 1

   # Add a Section section with name and z value
   for slice in slices:
      if int(slice[kZvalue]) == z:
         break
   else:
      addedData = 1
      slice = {}
      slices.append(slice)
      if kNoZvals in predata and predata[kNoZvals] != '0':
         slice['name'] = rootname
         slice[kZvalue] = '0'
      else:
         slice['name'] = rootname + '_' + str(z)
         slice[kZvalue] = str(z)
         
# Write the info file now in case of failure, and after each edge
if addedData:
    writeMontInfo(infofile, predata, slices, pieces, edges)


# Run the desired edges if any
if anyrun:
   xrunStart = max(xmin, xrunStart)
   xrunEnd = min(xmax, xrunEnd)
   yrunStart = max(ymin, yrunStart)
   yrunEnd = min(ymax, yrunEnd)
   zrunStart = max(zmin, zrunStart)
   zrunEnd = min(zmax, zrunEnd)
   for z in range(zrunStart, zrunEnd + 1):
      delx = 1
      dely = 0
      zbase = xysize * (z - zmin)
      for xory in ('X', 'Y'):
         for x in range(xrunStart, xrunEnd + dely):
            for y in range(yrunStart, yrunEnd + delx):
               lower = pieceMap[x - xmin + xsize * (y - ymin) + zbase]
               upper =  pieceMap[x + delx - xmin + xsize * \
                                 (y + dely - ymin) + zbase]
               if lower >= 0 and upper >= 0:
                  for edge in edges:
                     if edge[kXorY] == xory and edge[kLower][0] == x and \
                            edge[kLower][1] == y and edge[kLower][2] == z:
                        break
                  else:
                     exitError(fmtstr('Failed to find {} edge in edges array'+\
                           ' for lower piece {} {} {}', xory, x, y, z))

                  if redoShifts or not kShiftDone in edge:
                     addedData = 1
                     findEdgeShifts(pieces[lower], pieces[upper], edge)
                     writeMontInfo(infofile, predata, slices, pieces, edges)
                  if not (skipDone and kPatch in edge):
                     addedData = 1
                     findPatches(pieces[lower], pieces[upper], edge)
                     edge[kPatchParam] = patchParams
                     writeMontInfo(infofile, predata, slices, pieces, edges)
                  
         delx = 0
         dely = 1

# Write the info file 
if addedData:
   prnstr('New info file written')
else:
   prnstr('Nothing was done')
sys.exit(0)

#
# $Log$
# Revision 1.13  2010/04/08 02:06:14  mast
# Adjusted mins and maxes for corrsearch3d to start from 1
#
# Revision 1.12  2009/11/03 03:45:55  mast
# Needed to copy patchsize to sizes as a list to modify it
#
# Revision 1.11  2009/10/22 05:46:17  mast
# Add error message if no -zadd
#
# Revision 1.10  2009/09/11 05:49:46  mast
# Fix spaces in patch params
#
# Revision 1.9  2009/09/08 23:27:36  mast
# Clear out keys for dependent data when making new patches; save command
# parameters for each patch; write info file after each operation
#
# Revision 1.8  2008/12/23 03:28:29  mast
# Fix output of total shift after 3D correlation
#
# Revision 1.7  2008/04/08 21:37:43  mast
# Added options for setting range to add in X or Y separately, fixed problem
# with Section entry, and allowed 0 overlap value in one direction
#
# Revision 1.6  2007/10/01 23:00:39  mast
# Added option for verbose output
#
# Revision 1.5  2007/07/19 02:46:20  mast
# Made it detect problems with patches not fitting in a range in X/y and
# suggest changes in border and size; fixed a problem with nozvals and made
# it write info file only if data was added to it
#
# Revision 1.4  2007/05/11 05:35:10  mast
# Fixed weird duplicate text
#
# Revision 1.3  2007/04/11 15:45:42  mast
# Added Z limits for edges
#
# Revision 1.2  2007/04/10 22:39:49  mast
# Fixed bugs dealing with section (slice) names and Z values
#
# Revision 1.1  2007/04/08 16:30:13  mast
# Added to package
