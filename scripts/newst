#! /bin/csh -f

#  $Author$
#
#  $Date$
#
#  $Revision$
#
#  $Log$
#  Revision 3.8  2003/11/13 19:43:02  mast
#  Needed to run csh with -f flag
#
#  Revision 3.7  2003/10/24 02:14:00  mast
#  source settmpdir to get tmpdir, better for Windows
#
#  Revision 3.6  2003/07/10 23:41:49  mast
#  Added ability to specify multiple input files
#
#  Revision 3.5  2003/06/20 20:02:46  mast
#  Let tmpdir be defined and fall back to /tmp if /usr/tmp does not exist
#
#  Revision 3.4  2003/03/14 02:00:28  mast
#  Added linear interpolation option
#
#  Revision 3.3  2002/12/10 18:11:08  mast
#  Implemented combinations of transforming, rotating, and scaling
#
#  Revision 3.2  2002/11/14 20:18:41  mast
#  Made it exit with an error if newstack does
#

if ($#argv == 0) then
cat <<EOF
Usage: newst [options] input.file(s) output.file
  options:  -se[cs] section_list         (default is entire file)
            -si[ze] X,Y
            -m[ode] new_mode
            -o[ffset] dX,dY              (single offset used for whole file)
            -x[form] transform_file
            -l[inear]                    (transform with linear interpolation)
            -e[xpand] expansion_factor   (>1 to expand, <1 to squeeze)
            -r[otate] rotation_angle     (degrees, counterclockwise positive)
            -c[ontrast] black,white      (scale to black/white levels)
            -f[loat] option  (0=none, 1=range, 2=mean/SD, 3 = shift to mean
                              -1 = single scaling by specifying min/max
                              -2 = scaling by entering black/white levels)
EOF
exit 0
endif


set tmpdir = /usr/tmp
if ($?IMOD_DIR) then
    set path = ($IMOD_DIR/bin $path)
    if (-e $IMOD_DIR/bin/settmpdir) source $IMOD_DIR/bin/settmpdir
endif

set sec = "u"
set size = ",,"
set mode = "/"
set ifoffset = "0"
set ifxf = "0"
set ifexpand = "0"
set ifrotate = "0"
set float = "0"
set minmax = "/"
set ifcontrast = "0"
set linear = "0"
set done = "0"
@ numxf = 0
while (($#argv > 2) && ($done == "0"))
  switch ($argv[1])
    case -se*:
      set sec = $argv[2]
      shift; shift
      breaksw
    case -si*:
      set size = $argv[2]
      shift; shift
      breaksw
    case -m*:
      set mode = $argv[2]
      @ modenum = $mode
      if ($modenum < 0 || ($modenum > 4 && $modenum < 9) || $modenum > 15)then
        echo "ERROR: newst - Bad mode value $mode"
        exit 1
      endif
      shift; shift
      breaksw
    case -o*:
      set ifoffset = "-1"
      set offset = $argv[2]
      shift; shift
      breaksw
    case -x*:
      set ifxf = "1"
      set xfile = $argv[2]
	if (! -e $xfile) then
          echo "ERROR: newst - transform file $argv[2] does not exist"
          exit 1
        endif
      shift; shift
      breaksw
    case -l*:
      set linear = "1"
      shift
      breaksw
    case -e*:
      set ifexpand = "1"
      set expand = $argv[2]
      @ numxf++
      shift; shift
      breaksw
    case -r*:
      set ifrotate = "1"
      set rotate = $argv[2]
      @ numxf++
      shift; shift
      breaksw
    case -f*:
      set float = $argv[2]
      shift; shift
      breaksw
    case -c*:
      set ifcontrast = "1"
      set minmax = $argv[2]
      shift; shift
      breaksw
    default:
      set done = "1"
      breaksw
  endsw
end

if ($#argv < 2) then
    echo "ERROR: newst - only one argument left after parsing options"
    exit 1
endif

# check existence of remaining input files
@ i = 1
while ($i < $#argv)
    if (! -e $argv[$i])then
        echo "ERROR: newst - $argv[$i] is a bad argument or a nonexistent input file"
        exit 1
    endif
    @ i++
end

# if multiple input files, forbid section entry; otherwise get sections
if ($#argv > 2) then
    if ($sec != "u") then
        echo "ERROR: newst - you cannot make a section entry with multiple input files"
        exit 1
    endif
else
    if ($sec == "u") then
        @ numsec =  `header $argv[1] | sed -n '/rows, sections/p'| awk '{print $9}'`
        @ numsec--
        set sec = "0-"$numsec
    endif
endif

@ floatnum = $float
if ($floatnum < -2 || $floatnum > 4) then
  echo "ERROR: newst - bad float option $float"
  exit 1
endif

if ($ifcontrast == "1")then
    if ($float != "0") echo "Float option is superceded by contrast option; your -float entry is ignored"
    set float = "-2"

else
    if ($float == "-1") header $argv[1] | sed -n '/mum dens/p'
    if ($float == "-1" || $float == "4") then
	echo -n "Values to scale min and max to, or / for full range: "
	set minmax = $<
    endif
    if ($float == "-2") then
	echo -n "Black and white contrast settings: "
	set minmax = $<
    endif
endif

# Get transform line list, but multiple transforms not allowed for multiple 
# input files
if ($ifxf == "1") then
  @ numxfl = `cat $xfile |wc -l`
  if ($numxfl > 1) then
    if ($#argv > 2) then
        echo "ERROR: newst - you cannot us a transform file containing more"
        echo "  than one transform with multiple input files"
        exit 1
    endif
     set xfsec = $sec
  else
     set xfsec = "0"
  endif
endif

set tmpfil = $tmpdir/newst.$$
set tmpexpxf = $tmpdir/newstexpxf.$$
set tmprotxf = $tmpdir/newstrotxf.$$
set tmpexprot = $tmpdir/newstexprot.$$
set tmpprod = $tmpdir/newstprodxf.$$

# Set up xf for expansion; set size if default taken
if ($ifexpand == "1") then
    echo "$expand 0. 0. $expand 0. 0." >! $tmpexpxf
    if ($size == ',,') then
	set xysize = `header $argv[1] | sed -n '/rows, sections/p'| awk '{print $7, $8}'`
	set xsize = `echo $xysize[1] $expand | awk '{print int($1 * $2 + 0.5)}'`
	set ysize = `echo $xysize[2] $expand | awk '{print int($1 * $2 + 0.5)}'`
	set size = "$xsize,$ysize"
    endif
endif

# set up xf for rotation; set size if it is still default
if ($ifrotate == "1") then
    switch ($rotate)
	case 90:
	case 90.:
	case 90.0:
	    echo "0 -1 1 0 -1 0" >! $tmprotxf
	    if ($size == ',,') then
		set xysize = `header $argv[1] | sed -n '/rows, sections/p'| awk '{print $7, $8}'`
		set size = "$xysize[2],$xysize[1]"
	    endif
	    breaksw

	case -90:
	case -90.:
	case -90.0:
	    echo "0 1 -1 0 0 -1" >! $tmprotxf
	    if ($size == ',,') then
		set xysize = `header $argv[1] | sed -n '/rows, sections/p'| awk '{print $7, $8}'`
		set size = "$xysize[2],$xysize[1]"
	    endif
	    breaksw

	case 180:
	case 180.:
	case 180.0:
	case -180:
	case -180.:
	case -180.0:
	    echo "-1 0 0 -1 -1 -1" >! $tmprotxf
	    breaksw

	default:
	    set cos = `echo $rotate | awk '{print cos(0.0174533 * $1)}'`
	    set sin = `echo $rotate | awk '{print sin(0.0174533 * $1)}'`
	    set msin = `echo $rotate | awk '{print -sin(0.0174533 * $1)}'`
	    echo "$cos $msin $sin $cos 0. 0." >! $tmprotxf
	    breaksw
    endsw
endif

if ($numxf) then

    # if both expansion and rotation, get the product, rotation first
    if ($numxf == 2) then
	xfproduct <<EOF
$tmprotxf
$tmpexpxf
$tmpexprot
EOF
	if ($status) goto clean
    else if ($ifexpand == "1") then
	set tmpexprot = $tmpexpxf
    else
	set tmpexprot = $tmprotxf	
    endif

    # If doing transforms also, multiply transforms by post rotation/expansion
    if ($ifxf == "1") then
	xfproduct <<EOF
$xfile
$tmpexprot
$tmpprod
EOF
	if ($status) goto clean
	set xfile = $tmpprod
    else
	# otherwise just setup to do the rot/trans
	set xfsec = "0"
	set ifxf = "1"
	set xfile = $tmpexprot
    endif
endif

if ($ifxf != "0" && $linear != "0") set ifxf = 2

onintr clean

@ numinfiles = $#argv
@ numinfiles--

cat >! $tmpfil <<EOCAT
$numinfiles
EOCAT
while ($#argv > 1)
    echo $argv[1] >> $tmpfil
    if ($sec == "u") then
        @ numsec =  `header $argv[1] | sed -n '/rows, sections/p'| awk '{print $9}'`
        @ numsec--
        echo "0-"$numsec >> $tmpfil
    else
        echo $sec >> $tmpfil
    endif
    shift
end
cat >> $tmpfil <<EOCAT
1
$argv[1]
$size
$mode
$ifoffset
EOCAT
if ($ifoffset == "-1") then
  echo $offset >> $tmpfil
endif
echo $ifxf >> $tmpfil
if ($ifxf != "0") then
cat >> $tmpfil <<EOCAT
$xfile
$xfsec
EOCAT
endif
echo $float >> $tmpfil
if ($float == "-1" || $float == "-2" || $float == "4") echo $minmax >> $tmpfil
newstack < $tmpfil
if ($status) goto clean
\rm -f $tmpfil $tmpexpxf $tmprotxf $tmpexprot $tmpprod
exit 0
clean:
\rm -f $tmpfil $tmpexpxf $tmprotxf $tmpexprot $tmpprod
exit 1
