#! /bin/csh -f

#  $Author$
#
#  $Date$
#
#  $Revision$
#
#  $Log$
#  Revision 3.2  2002/11/14 20:18:41  mast
#  Made it exit with an error if newstack does
#

if ($#argv == 0) then
cat <<EOF
Usage: newst [options] input.file output.file
  options:  -se[cs] section_list         (default is entire file)
            -si[ze] X,Y
            -m[ode] new_mode
            -o[ffset] dX,dY              (single offset used for whole file)
            -x[form] transform_file
            -e[xpand] expansion_factor   (>1 to expand, <1 to squeeze)
            -r[otate] rotation_angle     (degrees, counterclockwise positive)
            -c[ontrast] black,white      (scale to black/white levels)
            -f[loat] option  (0=none, 1=range, 2=mean/SD, 3 = shift to mean
                              -1 = single scaling by specifying min/max
                              -2 = scaling by entering black/white levels)
EOF
exit 0
endif
if ($#argv % 2 != 0)then
echo "newst: Wrong number of arguments"
exit 1
endif

if ($?IMOD_DIR) set path = ($IMOD_DIR/bin $path)

set sec = "u"
set size = ",,"
set mode = "/"
set ifoffset = "0"
set ifxf = "0"
set ifexpand = "0"
set ifrotate = "0"
set float = "0"
set minmax = "/"
set ifcontrast = "0"
@ numxf = 0
while ($#argv > 2)
  switch ($argv[1])
    case -se*:
      set sec = $argv[2]
      shift; shift
      breaksw
    case -si*:
      set size = $argv[2]
      shift; shift
      breaksw
    case -m*:
      set mode = $argv[2]
      @ modenum = $mode
      if ($modenum < 0 || ($modenum > 4 && $modenum < 9) || $modenum > 15)then
        echo "newst: Bad mode value $mode"
        exit 1
      endif
      shift; shift
      breaksw
    case -o*:
      set ifoffset = "-1"
      set offset = $argv[2]
      shift; shift
      breaksw
    case -x*:
      set ifxf = "1"
      set xfile = $argv[2]
	if (! -e $xfile) then
          echo "newst: transform file $argv[2] does not exist"
          exit 1
        endif
      shift; shift
      breaksw
    case -e*:
      set ifexpand = "1"
      set expand = $argv[2]
      @ numxf++
      shift; shift
      breaksw
    case -r*:
      set ifrotate = "1"
      set rotate = $argv[2]
      @ numxf++
      shift; shift
      breaksw
    case -f*:
      set float = $argv[2]
      shift; shift
      breaksw
    case -c*:
      set ifcontrast = "1"
      set minmax = $argv[2]
      shift; shift
      breaksw
    default:
      echo "newst: bad argument $argv[1]"
      exit 1
  endsw
end
if (! -e $argv[1])then
  echo "newst: input file $argv[1] does not exist"
  exit 1
endif
if ($sec == "u") then
  @ numsec =  `header $argv[1] | sed -n '/rows, sections/p'| awk '{print $9}'`
  @ numsec--
  set sec = "0-"$numsec
endif
@ floatnum = $float
if ($floatnum < -2 || $floatnum > 4) then
  echo "newst: bad float option $float"
  exit 1
endif

if ($ifcontrast == "1")then
    if ($float != "0") echo "Float option is superceded by contrast option; your -float entry is ignored"
    set float = "-2"

else
    if ($float == "-1") header $argv[1] | sed -n '/mum dens/p'
    if ($float == "-1" || $float == "4") then
	echo -n "Values to scale min and max to, or / for full range: "
	set minmax = $<
    endif
    if ($float == "-2") then
	echo -n "Black and white contrast settings: "
	set minmax = $<
    endif
endif

if ($ifxf == "1") then
  @ numxfl = `cat $xfile |wc -l`
  if ($numxfl > 1) then
     set xfsec = $sec
  else
     set xfsec = "0"
  endif
endif

set tmpfil = /usr/tmp/newst.$$
set tmpexpxf = /usr/tmp/newstexpxf.$$
set tmprotxf = /usr/tmp/newstrotxf.$$
set tmpexprot = /usr/tmp/newstexprot.$$
set tmpprod = /usr/tmp/newstprodxf.$$

# Set up xf for expansion; set size if default taken
if ($ifexpand == "1") then
    echo "$expand 0. 0. $expand 0. 0." >! $tmpexpxf
    if ($size == ',,') then
	set xysize = `header $argv[1] | sed -n '/rows, sections/p'| awk '{print $7, $8}'`
	set xsize = `echo $xysize[1] $expand | awk '{print int($1 * $2 + 0.5)}'`
	set ysize = `echo $xysize[2] $expand | awk '{print int($1 * $2 + 0.5)}'`
	set size = "$xsize,$ysize"
    endif
endif

# set up xf for rotation; set size if it is still default
if ($ifrotate == "1") then
    switch ($rotate)
	case 90:
	case 90.:
	case 90.0:
	    echo "0 -1 1 0 -1 0" >! $tmprotxf
	    if ($size == ',,') then
		set xysize = `header $argv[1] | sed -n '/rows, sections/p'| awk '{print $7, $8}'`
		set size = "$xysize[2],$xysize[1]"
	    endif
	    breaksw

	case -90:
	case -90.:
	case -90.0:
	    echo "0 1 -1 0 0 -1" >! $tmprotxf
	    if ($size == ',,') then
		set xysize = `header $argv[1] | sed -n '/rows, sections/p'| awk '{print $7, $8}'`
		set size = "$xysize[2],$xysize[1]"
	    endif
	    breaksw

	case 180:
	case 180.:
	case 180.0:
	case -180:
	case -180.:
	case -180.0:
	    echo "-1 0 0 -1 -1 -1" >! $tmprotxf
	    breaksw

	default:
	    set cos = `echo $rotate | awk '{print cos(0.0174533 * $1)}'`
	    set sin = `echo $rotate | awk '{print sin(0.0174533 * $1)}'`
	    set msin = `echo $rotate | awk '{print -sin(0.0174533 * $1)}'`
	    echo "$cos $msin $sin $cos 0. 0." >! $tmprotxf
	    breaksw
    endsw
endif

if ($numxf) then

    # if both expansion and rotation, get the product, rotation first
    if ($numxf == 2) then
	xfproduct <<EOF
$tmprotxf
$tmpexpxf
$tmpexprot
EOF
	if ($status) goto clean
    else if ($ifexpand == "1") then
	set tmpexprot = $tmpexpxf
    else
	set tmpexprot = $tmprotxf	
    endif

    # If doing transforms also, multiply transforms by post rotation/expansion
    if ($ifxf == "1") then
	xfproduct <<EOF
$xfile
$tmpexprot
$tmpprod
EOF
	if ($status) goto clean
	set xfile = $tmpprod
    else
	# otherwise just setup to do the rot/trans
	set xfsec = "0"
	set ifxf = "1"
	set xfile = $tmpexprot
    endif
endif

onintr clean
cat >! $tmpfil <<EOCAT
newstack <<EOF
1
$argv[1]
$sec
1
$argv[2]
$size
$mode
$ifoffset
EOCAT
if ($ifoffset == "-1") then
  echo $offset >> $tmpfil
endif
echo $ifxf >> $tmpfil
if ($ifxf == "1") then
cat >> $tmpfil <<EOCAT
$xfile
$xfsec
EOCAT
endif
echo $float >> $tmpfil
if ($float == "-1" || $float == "-2" || $float == "4") echo $minmax >> $tmpfil
echo EOF >>$tmpfil
csh $tmpfil
if ($status) goto clean
\rm -f $tmpfil $tmpexpxf $tmprotxf $tmpexprot $tmpprod
exit 0
clean:
\rm -f $tmpfil $tmpexpxf $tmprotxf $tmpexprot $tmpprod
exit 1
