#! /bin/csh -f
# SHELL SCRIPT TO FINISH JOINING SERIAL SECTION TOMOGRAMS
#
#  $Id$
#  Log at end of file
#

nohup
set pn = "finishjoin"
set anglerange = 50

if ($#argv < 3) then
echo "Usage: $pn [options]  root_name  slice_range1  slice_range2  ..."
cat <<EOF
        root_name     Is the root name for the joined tomogram
        slice_range   Gives the starting and ending slices to include from each
                      individual tomogram.  A range is two numbers separated by
                      comma or dash; slices are numbered from 1.
  Options:
        -r[ef] tomo_# Use the given tomogram number as the reference for 
                      alignment, in which case this tomogram will not be
                      transformed and other tomograms will be transformed into
                      alignment with it.
        -s[ize] X,Y   Set the dimensions of the joined tomogram to X by Y.
        -o[ffset] X,Y Offsets in X and Y from the center of the image to the
                      the point which should end up in the center of the new
                      images.  A positive X offset will shift images to the
                      left.
        -a[ngle] #    Compute the average rotation angle using only the
                      tomograms whose angles fall in the given range
                      (default $anglerange)
        -t[rial] #    Build trial joined file, using slices at the given 
                      interval (output will be "root_name"_trial.join)
        -b[in] #      Bin images by the given number in a trial joined file.
                      Size and offset entries should still be in unbinned 
                      pixels.
        -m[axsize]    Just compute the maximum size and offsets needed to
                      contain all of the transformed data, then exit
        -l[ocal]      Use local fits to 7 sections when running xftoxg
        -x[form] file Refine alignment with g transforms in the given file
        -g[aps]       Fill gaps with blank slices if a slice range goes beyond
                      the bounds of the input
        -P            Output process ID
EOF
exit 0
endif

set tmpdir = /usr/tmp
if ($?IMOD_DIR) then
    setenv PATH "$IMOD_DIR/bin:$PATH"
    if (-e "$IMOD_DIR/bin/settmpdir") source "$IMOD_DIR/bin/settmpdir"
endif

set retval = 0
set rangelist = ""
set joinroot = ""
set newsize = ""
set refarg = ""
set maxsize = 0
@ linesave = 0
set offset = "0,0"
@ binning = 1
@ interval = 1
set trial = ""
set newmode = ""
set xffile = ""
set gaps = 0
set fitopt = "-nfit 0"

while ($#argv > 2 && $joinroot == "")
  switch ($argv[1])
    case -r*:
      set refarg = "-ref $argv[2]"
      @ nref = $argv[2]
      shift; shift
      breaksw
    case -s*:
      set newsize = $argv[2]
      shift; shift
      breaksw
    case -o*:
      set offset = $argv[2]
      shift; shift
      breaksw
    case -a*:
      set anglerange = $argv[2]
      shift; shift
      breaksw
    case -t*:
      @ interval = $argv[2]
      set trial = "_trial"
      shift; shift
      breaksw
    case -b*:
      @ binning = $argv[2]
      shift; shift
      breaksw
    case -m*:
      set maxsize = 1
      shift
      breaksw
    case -l*:
      set fitopt = ""
      shift
      breaksw
    case -g*:
      set gaps = 1
      shift
      breaksw
    case -x*:
      set xffile = "$argv[2]"
      shift; shift
      breaksw
    case -P:
      echo2 Shell PID: $$
      shift
      breaksw
    default:
      set joinroot = "$argv[1]"
      shift
      breaksw
  endsw
end

if ($joinroot == "" || (! -e $joinroot.info)) then
    echo "ERROR: $pn - Illegal entry, or $joinroot.info does not exist"
    exit 1
endif

set info1 = `head -n 1 $joinroot.info | sed '/[[:cntrl:]]/s///g'`
@ ntomo = $info1[1]
set ifsquoze = $info1[2]

# 2nd version info file has default size in it
# The fifth entry was added as a version number at version 3
# Access of info1 variable must be on separate line from test, thus then/endif
set version = 1
if ($#info1 > 2) set version = 2
if ($#info1 > 4) then
    set version = $info1[5]
endif
if ($version > 3) then
    set newmode = $info1[6]
endif

# use default size unless user entered size
# Note, wasn't able to test on "/" because csh tried to do a division
if ($newsize == "" && $version > 1) set newsize = "$info1[3],$info1[4]"

# Early versions just had list of filenames then list of inversion flags
if ($version < 3) then
    set matlist = `head -n 2 $joinroot.info | tail -n 1 | sed '/[[:cntrl:]]/s///g'`
    set invertlist = `head -n 3 $joinroot.info | tail -n 1 | sed '/[[:cntrl:]]/s///g'`
    set scalelist = ""
else

# Later versions have lines of information for all tomos, then tomo file names
# one per line to handle spaces
    set invertlist = `head -n 2 $joinroot.info | tail -n 1 | sed '/[[:cntrl:]]/s///g'`
    set scalelist = `head -n 3 $joinroot.info | tail -n 1 | sed '/[[:cntrl:]]/s///g'`
    if ($#scalelist < $ntomo) then
        echo "ERROR: $pn - $joinroot.info does not have enough scaling entries"
        exit 1
    endif

    # Read in the lines one by one.  
    # Have to build a wordlist big enough before starting
    @ linestart = 4
    @ linesave = $linestart - 1
    @ ind = 0
    set matlist = ()
    while ($ind < $ntomo)
        @ ind++
        set matlist = ($matlist "dummy")
    end
    @ ind = 0
    while ($ind < $ntomo)
        @ ind++
        set matlist[$ind] = `head -n $linestart $joinroot.info | tail -n 1 | sed '/[[:cntrl:]]/s///g'`
        @ linestart++
    end
endif

echo $matlist

if ($#argv != $ntomo) then
    echo "ERROR: $pn - You entered $#argv Z-ranges but $ntomo are required"
    exit 1
endif

if ("$refarg" != "") then
    if ($nref < 1 || $nref > $ntomo) then
	echo "ERROR: $pn - Illegal entry for reference tomogram number"
	exit 1
    endif
endif

# If trial mode with binning, adjust newsize (and not offset - 1/31/07)
#
if ($trial == "") @ binning = 1
if ($binning > 1 && $newsize != "") then
    set arrtmp = `echo $newsize | sed '/,/s// /g'`
    if ($#arrtmp < 2) goto twoerr
    set numtmp = `echo $arrtmp[1] | sed '/\..*/s///'`
    if ($numtmp == "") goto converr
    @ xtmp = $numtmp
    @ xtmp /= $binning

    set numtmp = `echo $arrtmp[2] | sed '/\..*/s///'`
    if ($numtmp == "") goto converr
    @ ytmp = $numtmp
    @ ytmp /= $binning
    set newsize = $xtmp,$ytmp
endif

#  Get Z ranges
#
@ itomo = 1
while ($itomo <= $ntomo)
    if (! -e "$matlist[$itomo]") then
	set size = `echo "1024 1024 100"`
	echo "WARNING: $matlist[$itomo] NO LONGER EXISTS.  SETTING SIZE TO $size FOR TESTING"
#	exit 1
    else
        set size = `header -si "$matlist[$itomo]" | sed '/[[:cntrl:]]/s///g'`
    endif
    @ nz = $size[3]

    set zentry = `echo $argv[1] | sed '/,/s// /g'`
    shift
    if ($#zentry < 2) then
        echo "ERROR: $pn - The Z range for tomogram # $itomo does not have two numbers"
	exit 1
    endif
    @ zst = $zentry[1]
    @ znd = $zentry[2]
    @ zst--
    @ znd--
    if ($gaps == 0 && ($zst < 0 || $zst >= $nz || $znd < 0 || $znd >= $nz)) then
	echo "ERROR: $pn - The Z range for tomogram # $itomo has coordinates out of range"
	exit 1
    endif
    set ifinvert = $invertlist[$itomo]
    if (($zst < $znd && $ifinvert == "0") || ($zst >= $znd && $ifinvert == "1")) then
	set zstout = $zst
	set zndout = $znd
    else
	set zstout = $znd
	set zndout = $zst
    endif

    # Set up z range as simple range or as list of slices at interval
    #
    if ($trial == "") then
        set zrange = $zstout"-"$zndout
    else
        @ intuse = $interval
        @ zsto = $zstout
        @ zndo = $zndout
        @ idir = 1
        set zrange = "$zstout"
        if ($zsto > $zndo) @ idir = -1
        set zlast = $zsto
        @ iz = $zsto + $idir * $interval
        while ($idir * ($iz - $zndo) <= 0)
            set zrange = $zrange,$iz
            set zlast = $iz
            @ iz += $idir * $interval
        end
        if ($zlast != $zndo) set zrange = $zrange,$zndo
    endif

    set rangelist = ($rangelist $zrange)

    @ itomo++
end

if (-e $joinroot.tomoxf) \mv $joinroot.tomoxf $joinroot.tomoxf~

set wcout = `wc -l $joinroot.xf`
@ nlines = $wcout[1]

# For new-style file, lines match, just copy it
#
if ($nlines == $ntomo) then
    \cp $joinroot.xf $joinroot.tomoxf
    chmod u+rw $joinroot.tomoxf
else

    # Now work on getting the transforms if it is an old file
    # Note the bug, if there was a unit transform intentionally

    \echo "1.0000000   0.0000000   0.0000000   1.0000000       0.000       0.000" > $joinroot.tomoxf
    sed '/1.0000000   0.0000000   0.0000000   1.0000000       0.000       0.000/d' $joinroot.xf >> $joinroot.tomoxf
    set wcout = `wc -l $joinroot.tomoxf`
    @ nlines = $wcout[1]

    if ($nlines != $ntomo) then
        @ nlines--
        echo "ERROR: $pn - There are $nlines lines in $joinroot.xf with non-unit transforms"
        echo "This is not the right number of lines for joining $ntomo tomograms"
        exit 1
    endif
endif

# 10/11/05: stop checking for big transformation if no reference, since
# we now have range option to ignore them
#
xftoxg -range $anglerange $refarg $fitopt $joinroot.tomoxf $joinroot.tomoxg
if ($status) goto error

if ($ifsquoze == "1") then
    \mv $joinroot.tomoxg $joinroot.tmpxg
    xfproduct $joinroot.sqzxf $joinroot.tmpxg $joinroot.tmpsqz
    if ($status) goto error
    xfproduct $joinroot.tmpsqz $joinroot.xpndxf $joinroot.tomoxg
    if ($status) goto error
endif

# If a refinement file was entered, form product with that
#
if ("$xffile" != "") then
    \mv $joinroot.tomoxg $joinroot.tmpxg
    xfproduct $joinroot.tmpxg "$xffile" $joinroot.tomoxg
    if ($status) goto error
endif

# Now if max size is wanted, call the program
#
if ($maxsize) then
    if ($linesave == 0) then
        echo 'ERROR: $pn - INFO FILE IS TOO OLD TO GET THE MAXIMUM SIZE FROM'
        exit 1
    endif
    maxjoinsize $ntomo $linesave $joinroot
    exit $status
endif

set newstin = "$tmpdir/joinnewst.$$"

echo -n >! "$newstin"
@ itomo = 1
while ($itomo <= $ntomo)
    echo "InputFile $matlist[$itomo]" >> "$newstin"
    echo "SectionsToRead $rangelist[$itomo]" >> "$newstin"
    if ("$scalelist" != "") then
        echo "MultiplyAndAdd $scalelist[$itomo]" >> "$newstin"
    endif
    @ itomo++
end
if ($newsize != "") echo "SizeToOutputInXandY $newsize" >> "$newstin"
if ($newmode != "") echo "ModeToOutput $newmode" >> "$newstin"
if ($gaps == 1) echo "BlankOutput" >> "$newstin"
cat >> "$newstin" <<EOF
OneTransformPerFile
BinByFactor $binning
OutputFile $joinroot$trial.join
OffsetsInXandY $offset
TransformFile $joinroot.tomoxg
EOF

newstack -StandardInput < "$newstin"
if ($status) goto error
echo "Truncations are a normal result of the scaling for density matching."
goto clean
error:
set retval = 1

clean:
\rm -f "$newstin"
\find . -name "$joinroot.*tmp*"  -exec rm "{}" \;
exit $retval

twoerr:
echo "ERROR: $pn - there must be two numbers entered for size or offsets"
exit 1

converr:
echo "ERROR: $pn - Size and offset values should be integers"
exit 1

#
#  $Log$
#  Revision 3.22  2008/05/20 22:45:49  mast
#  Added option to do local fits with xftoxg
#
#  Revision 3.21  2008/01/04 07:03:38  mast
#  Fixed for space in IMOD_DIR, possibly for space in tmpdir
#
#  Revision 3.20  2007/02/01 02:30:22  mast
#  Do not adjust offset for binning, newstack does it already
#
#  Revision 3.19  2007/01/24 23:53:42  mast
#  No longer allow dashes in slice ranges, so negative numbers can be used
#
#  Revision 3.18  2006/12/20 05:58:05  mast
#  Added gap option to get blank output from newstack
#
#  Revision 3.17  2006/10/24 19:38:54  mast
#  Added refinement transforms
#
#  Revision 3.16  2006/07/04 19:03:28  mast
#  Stripped returns from head and tail output for Windows
#
#  Revision 3.15  2006/02/16 06:47:09  mast
#  Stripped control chars from output of sed/header etc for Windows
#
#  Revision 3.14  2005/11/19 04:31:26  mast
#  Quote path setting to preserve spaces
#
#  Revision 3.13  2005/10/11 21:03:14  mast
#  Implemented rotation range for xftoxg and took advantage of new one
#  transform per file option in Newstack
#
#  Revision 3.12  2005/05/27 15:46:08  mast
#  Changed to output transform line numbers on multiple lines to avoid
#  line length limits in shell
#
#  Revision 3.11  2004/11/29 05:29:59  mast
#  Set the output mode if one is provided in the info file
#
#  Revision 3.10  2004/11/24 02:45:03  mast
#  *** empty log message ***
#
#  Revision 3.9  2004/11/09 21:24:56  mast
#  Change terminology to slices  in usage statement
#
#  Revision 3.8  2004/11/08 18:12:50  mast
#  Name the trial output file differently
#
#  Revision 3.7  2004/10/28 21:13:31  mast
#  Added maxsize, bin and trial options
#
#  Revision 3.6  2004/09/17 19:02:44  mast
#  Had it detect large rotations and warn if there is no reference sections
#
#  Revision 3.5  2004/08/27 05:44:59  mast
#  Changed to handle new version of info file with scaling and file names
#  on separate lines, switched to head -n and tail -n
#
#  Revision 3.4  2004/07/09 21:06:01  mast
#  Switched from /usr/tmp to tmpdir set in standard way
#
#  Revision 3.3  2004/07/08 22:54:18  mast
#  Switched some echos to \echo to dodge Cygwin tcsh bug
#
#  Revision 3.2  2004/06/29 03:47:22  mast
#  Added nohup, fixed path setting
#
