#! /bin/csh -f
# SCRIPT TO COPY AND MODIFY COMBINE.COM AND ASSOCIATED COM FILES
#  $Id$
# Log at end of file

set XYBORDERS = (24 36 54 68 80)    # border sizes per increment of minimum
set BORDERINC = 1000                # dimension
set PATCHXY = (64 80 100)
set PATCHZ = (32 40 50)
set DELPATCHXY = 100
set NZPATCH3 = 75      # Thickness at which to do 3 patches in Z
set NZPATCH4 = 150     # Thickness at which to do 4 patches in Z
set MAXPIXELS = 20000  # KPixels for maximum FFT - check FFT3D if increase
set TAPERPADXZ = 8       # Size of taper/pad for 3D ffts in X and Z
set TAPERPADY = 4       # Size of taper/pad for 3D ffts in Y
set MAXPIECEY = 1       # Maximum pieces in Y
set MINOVERLAP = 10     # Minimum overlap between pieces
set MATCHSHIFTXZ = 100   # size of 3-D box in X and Z for matchshifts
set MATCHSHIFTY  = (40 60 76 90)      # Y sizes per increment of Y dimension
set MATCHSHIFTINC = 100

# Set this to "clip fft" if MAXPIXELS is increased near to value in ftbuf.inc
set FFT3D = "fftrans -q"   # Command to get get fft - assumes -3d argument

set pn = setupcombine

set to_srcname = "g5a"
set from_srcname = "g5b"
set tmp_srcname = "g5tmpdir"
set backupname = "./savework"
set backupsed = ".\/savework"

set matchshift = solvematch.com
set matchvol1 = matchvol1.com
set patchcorr = patchcorr.com
set matchorwarp = matchorwarp.com
set warpvol = warpvol.com
set matchvol2 = matchvol2.com
set volcombine = volcombine.com

setenv LC_NUMERIC C

if ($?IMOD_DIR) then

    # Set the com directory.  If on cygwin, convert to cygwin path otherwise
    # sed's create extra ^M (although the | cat's prevent this)
    #
    set srcdir = "$IMOD_DIR/com"
    set test = `which cygpath`
    if (! $status) set srcdir = `cygpath "$IMOD_DIR"`/com
    setenv PATH "$IMOD_DIR/bin:$PATH"
else
    echo "Environment variable IMOD_DIR must be set to the top IMOD directory"
    exit 1
endif


if (! -d "$srcdir") then
    echo "Source directory for command file, $srcdir, not found."
    echo "Edit $0 if necessary to set the source directory correctly"
    exit 1
endif

set noglob

set uselist = "\/"
set matchatob = 0
set sedtranskey = "gibberish"
set fromlet = "b"
set tolet = "a"
set transfile = ""
set delregion = "RegionModel"

if ($#argv > 0) then

    set interactive = 0
    set corrlist1 = "\/"
    set corrlist2 = "\/"
    set patchin = "M"
    set tmproot = ""
    set handclean = 0
    set regionmod = ""

    # process arguments
    while ($#argv > 0)
      switch ($argv[1])
        case -h*:
          goto usage
          breaksw
        case -na*:
          set rootname = $argv[2]
          shift; shift
          breaksw
        case -at*:
          set fromlet = "a"
          set tolet = "b"
          set matchatob = 1
          shift
          breaksw
        case -to*:
          set corrlist1 = `echo $argv[2] | sed -e '/ /s///g' -e '/\//s//\\\//g'`
          shift; shift
          breaksw
        case -fr*:
          set corrlist2 = `echo $argv[2] | sed -e '/ /s///g' -e '/\//s//\\\//g'`
          shift; shift
          breaksw
        case -tr*:
          set transfile = $argv[2]
          set sedtranskey = "#TransferCoordinateFile"
          shift; shift
          breaksw
        case -us*:
          set uselist = $argv[2]
          shift; shift
          breaksw
        case -su*:
          set modsurf = $argv[2]
          if ("$modsurf" != "0" && "$modsurf" != "1" && "$modsurf" != "-1" && \
              "$modsurf" != "2" && "$modsurf" != "-2") then
              echo "ERROR: $pn - Illegal surface option $modsurf"  
              exit 1
          endif
          shift; shift
          breaksw
        case -pa*:
          set patchin = $argv[2]
          shift; shift
          breaksw
        case -xl*:
          set xlim = $argv[2]
          shift; shift
          breaksw
        case -yl*:
          set ylim = $argv[2]
          shift; shift
          breaksw
        case -zl*:
          set zlim = $argv[2]
          shift; shift
          breaksw
        case -re*:
          set regionmod = $argv[2]
          set delregion = "gibberish"
          shift; shift
          breaksw
        case -te*:
          set tmproot = $argv[2]
          shift; shift
          breaksw
        case -no*:
          set handclean = 1
          shift
          breaksw
        default:
          echo "ERROR: $pn - unrecognized option $argv[1]"
          exit 1
      endsw
    end

    # Check validity of inputs
    #
    if (! $?rootname) then
        echo "ERROR: $pn - You must enter a root name"
        exit 1
    endif
    if (! $?modsurf) then
        echo "ERROR: $pn - You must enter a surface/model option"
        exit 1
    endif
    if (! $?zlim) then
        echo "ERROR: $pn - You must enter Z limits for the patches"
        exit 1
    endif

else

    # INTERACTIVE - not much to get started
    set interactive = 1
    echo " "
    echo "This program sets up the file combine.com for combining two tomograms."
    echo "It can be run with command line arguments; enter -h for help."
    echo "Just answer each of the questions in turn."
    echo "To interrupt, type Ctrl-C then Return"
    echo " "

    echo -n "Enter root name of data sets (omitting a or b and extension): "
    set rootname = $<
    set tolet = "z"
    while ($tolet != "a" && $tolet != "b")
        echo -n "Enter letter of tomogram being matched TO (a or b): "
        set tolet = $<
        if ($tolet == "b") then
            set fromlet = "a"
            set matchatob = 1
        endif
    end
endif

set toname = $rootname$tolet
set fromname = $rootname$fromlet
set tilta = "tilt$tolet.com"
set tiltb = "tilt$fromlet.com"

if ((-e tilta.com) && (-e tiltb.com)) then
    # This ugliness is for Cygwin Windows, with nobinmode not set
    set xaxisa = `grep -i xaxistilt $tilta | sed '/[[:cntrl:]]/s///g'`
    set xaxisb = `grep -i xaxistilt $tiltb | sed '/[[:cntrl:]]/s///g'`
    if ($#xaxisa < 2) set xaxisa = (xaxistilt 0.)
    if ($#xaxisb < 2) set xaxisb = (xaxistilt 0.)
    set angoffa = `grep -i '^offset' $tilta | sed '/[[:cntrl:]]/s///g'`
    set angoffb = `grep -i '^offset' $tiltb | sed '/[[:cntrl:]]/s///g'`
    if ($#angoffa < 2) set angoffa = (offset 0.)
    if ($#angoffb < 2) set angoffb = (offset 0.)
    set zshifta = `grep -i '^shift' $tilta | sed '/[[:cntrl:]]/s///g'`
    set zshiftb = `grep -i '^shift' $tiltb | sed '/[[:cntrl:]]/s///g'`
    if ($#zshifta < 3) set zshifta = (shift 0. 0.)
    if ($#zshiftb < 3) set zshiftb = (shift 0. 0.)
    set binning = `grep -i imagebinned $tilta | sed '/[[:cntrl:]]/s///g'`
    if ($#binning > 1) then
        set temp = `echo $binning[2] $zshifta[3] | awk '{print $2 / $1}'`
        set zshifta[3] = $temp
    endif
    set binning = `grep -i imagebinned $tiltb | sed '/[[:cntrl:]]/s///g'`
    if ($#binning > 1) then
        set temp = `echo $binning[2] $zshiftb[3] | awk '{print $2 / $1}'`
        set zshiftb[3] = $temp
    endif
else
    echo " "
    echo2 "WARNING: CANNOT FIND tilta.com or tiltb.com; CANNOT SET X-AXIS TILTS CORRECTLY"
    set xaxisa = (xaxistilt 0.)
    set xaxisb = (xaxistilt 0.)
    set angoffa = (offset 0.)
    set angoffb = (offset 0.)
    set zshifta = (shift 0. 0.)
    set zshiftb = (shift 0. 0.)
endif

set recfile = $toname.rec
set matfile = $fromname.mat
set origfile = $fromname.rec
set invfile = "inverse.xf"
set atlt = $toname.tlt
set btlt = $fromname.tlt
set mode = 1

if (-e $recfile) then
    set size = `header -si $recfile | sed '/[[:cntrl:]]/s///g'`
    set modeline = `header -mo $recfile | sed '/[[:cntrl:]]/s///g'`
    if ("$modeline" == 2) set mode = 2
else
    set size = `echo "1024 60 1024"`
    echo " "
    echo2 "WARNING: $recfile NOT FOUND; SETTING SIZE TO $size FOR TEST PURPOSES"
endif

@ nx = $size[1]
@ ny = $size[3]
@ nz = $size[2]

if ($interactive) then
    echo ""
    echo "Specify the correspondence between fiducial points in the two tilt alignments."
    echo "Enter a list of the points in tilt series $tolet for which you"
    echo "are sure of the corresponding point in tilt series $fromlet"
    echo " (ranges may be entered)."
    echo "Or just Return if the points are in one-to-one correspondence"
    echo "   or if there are no fiducial points"
    #
    # Need to strip spaces out of these lists and convert a / to \/
    #
    set corrlistin = "$<"
    set corrlistin = ($corrlistin)
    set corrlist1 = `echo $corrlistin | sed -e '/ /s///g' -e '/\//s//\\\//g'`

    set corrlist2 = "\/"
    if ("$corrlist1" != "") then
        echo "Enter a list of the corresponding points in tilt series $fromlet"
        set corrlistin = "$<"
        set corrlist2 = `echo $corrlistin | sed -e '/ /s///g' -e '/\//s//\\\//g'`
    else
        set corrlist1 = "\/"
    endif

    set modsurf = "z"
    while ($modsurf != "0" && $modsurf != "1" && $modsurf != "-1" && $modsurf != "2" && $modsurf != "-2")
        echo ""
        echo "Enter -2 to use just models of corresponding points ($toname.matmod and"
        echo " $fromname.matmod) to specify initial registration between tomograms;"
        echo " or 0 to use models of corresponding points along with relative fiducial"
        echo "    coordinates (for old fiducial coordinates); otherwise enter:"
        echo "   1 if fiducials are on only one surface and tomograms are NOT inverted,"
        echo "  -1 if fiducials are on only one surface and tomograms are inverted"
        echo "           relative to each other, or"
        echo -n "   2 if there are fiducials on both surfaces: "
        set modsurf = $<
    end

    set ifok = "0"
    while ($ifok == "0")
        echo ""
        echo "Enter s for small patches ($PATCHXY[1] x $PATCHZ[1] x $PATCHXY[1]), m for medium patches ($PATCHXY[2] x $PATCHZ[2] x $PATCHXY[2]),"
        echo -n " or l for large patches ($PATCHXY[3] x $PATCHZ[3] x $PATCHXY[3]) (Return for m): "
        set patchin = $<
        set ifok = "1"
        if ($patchin == "") set patchin = "M"
        if ($patchin == "s" || $patchin == "S") then
            set indpatch = 1
        else if ($patchin == "m" || $patchin == "M") then
            set indpatch = 2
        else if ($patchin == "l" || $patchin == "L") then
            set indpatch = 3
        else
            set ifok = "0"
        endif
    end

else

    # Process patch input as letter or three numbers

    if ($patchin == "s" || $patchin == "S") then
        set indpatch = 1
    else if ($patchin == "m" || $patchin == "M") then
        set indpatch = 2
    else if ($patchin == "l" || $patchin == "L") then
        set indpatch = 3
    else
        set indpatch = 0
        set patchxyz = `echo $patchin | sed -e '/,/s// /g' -e '/[^0-9 ]/s///g'`
        if ($#patchxyz != 3) then
            echo "ERROR: $pn - patch size entry ($patchin) must be S, M, L, or 3 numbers"
            exit 1
        endif
        @ patchnx = $patchxyz[1]
        @ patchny = $patchxyz[2]
        @ patchnz = $patchxyz[3]
    endif
endif

if ($indpatch) then
    @ patchnx = $PATCHXY[$indpatch]
    @ patchny = $PATCHXY[$indpatch]
    @ patchnz = $PATCHZ[$indpatch]
endif

@ minsize = $nx
if ($ny < $nx) @ minsize = $ny
@ borderindex = 1 + $minsize / $BORDERINC
if ($borderindex > $#XYBORDERS) @ borderindex = $#XYBORDERS
@ xyborder = $XYBORDERS[$borderindex]
if ($xyborder > $minsize / 4) @ xyborder = $minsize / 4

if ($interactive) then
    echo ""
    echo "Now specify the limits of the volume from which patches will be"
    echo "      extracted by patchcrawl3d."
    echo "The default upper limits for X and Y are based on a border of $xyborder pixels."
    set ifok = "0"
    while ($ifok == "0")
        @ patchxl = $xyborder
        @ patchxu = $nx - $xyborder
        echo -n "Lower X (left) limit of area (Return for $patchxl): "
        set patchin = $<
        if ($patchin != "") @ patchxl = $patchin
        echo -n "Upper X (right) limit of area (Return for $patchxu): "
        set patchin = $<
        if ($patchin != "") @ patchxu = $patchin
        if ($patchxl < 0 ) then
            echo "Lower limit out of bounds, try again"
        else if ($patchxu > $nx) then
            echo "Upper limit out of bounds, try again"
        else if ($patchxl >= $patchxu) then
            echo "Lower limit greater than upper limit, try again"
        else
            set ifok = "1"
        endif
    end
    set ifok = "0"
    while ($ifok == "0")
        @ patchyl = $xyborder
        @ patchyu = $ny - $xyborder
        echo -n "Lower Y (bottom) limit of area in flipped tomogram (Return for $patchyl): "
        set patchin = $<
        if ($patchin != "") @ patchyl = $patchin
        echo -n "Upper Y (top) limit of area in flipped tomogram (Return for $patchyu): "
        set patchin = $<
        if ($patchin != "") @ patchyu = $patchin
        if ($patchyl < 0 ) then
            echo "Lower limit out of bounds, try again"
        else if ($patchyu > $ny) then
            echo "Upper limit out of bounds, try again"
        else if ($patchyl >= $patchyu) then
            echo "Lower limit greater than upper limit, try again"
        else
            set ifok = "1"
        endif
    end
    set ifok = "0"
    while ($ifok == "0")
        set patchin = ""
        while ($patchin == "")
            echo -n "Lower Z limit of volume (bottom slice) in flipped tomogram: "
            set patchin = $<
            if ($patchin != "") then
                @ patchzl = $patchin
            endif
        end

        set patchin = ""
        while ($patchin == "")
            echo -n "Upper Z limit of volume (top slice) in flipped tomogram: "
            set patchin = $<
            if ($patchin != "") then
                @ patchzu = $patchin
            endif
        end
        if ($patchzl < 0 ) then
            echo "Lower limit out of bounds, try again"
        else if ($patchzu > $nz) then
            echo "Upper limit out of bounds, try again"
        else if ($patchzl >= $patchzu) then
            echo "Lower limit greater than upper limit, try again"
        else
            set ifok = "1"
        endif
    end

else

    # Process patch limits from command line
    #
    @ patchxl = $xyborder
    @ patchxu = $nx - $xyborder
    @ patchyl = $xyborder
    @ patchyu = $ny - $xyborder
    if ($?xlim) then
        set xlimlu = `echo $xlim | sed -e '/,/s// /g' -e '/[^0-9 ]/s///g'`
        if ($#xlimlu != 2) then
            echo "ERROR: $pn - X limits ($xlim) must consist of 2 numbers"
            exit 1
        endif
        @ patchxl = $xlimlu[1]
        @ patchxu = $xlimlu[2]
        if ($patchxl < 0 || $patchxu > $nx || $patchxl >= $patchxu) then
            echo "ERROR: $pn - X limits ($xlim) out of range or out of order"
            exit 1
        endif
    endif

    if ($?ylim) then
        set ylimlu = `echo $ylim | sed -e '/,/s// /g' -e '/[^0-9 ]/s///g'`
        if ($#ylimlu != 2) then
            echo "ERROR: $pn - Y limits ($ylim) must consist of 2 numbers"
            exit 1
        endif
        @ patchyl = $ylimlu[1]
        @ patchyu = $ylimlu[2]
        if ($patchyl < 0 || $patchyu > $ny || $patchyl >= $patchyu) then
            echo "ERROR: $pn - Y limits ($ylim) out of range or out of order"
            exit 1
        endif
    endif

    set zlimlu = `echo $zlim | sed -e '/,/s// /g' -e '/[^0-9 ]/s///g'`
    if ($#zlimlu != 2) then
        echo "ERROR: $pn - Z limits ($zlim) must consist of 2 numbers"
        exit 1
    endif
    @ patchzl = $zlimlu[1]
    @ patchzu = $zlimlu[2]
    if ($patchzl < 0 || $patchzu > $nz || $patchzl >= $patchzu) then
        echo "ERROR: $pn - Z limits ($zlim) out of range or out of order"
        exit 1
    endif
endif

# figure out a size in Y for matchshift block
@ msyindex = $nz / $MATCHSHIFTINC
if ($msyindex == 0) then
    @ msy = $MATCHSHIFTY[1]
    if ($msy > $nz) @ msy = $nz
else if ($msyindex >= $#MATCHSHIFTY) then
    @ msy = $MATCHSHIFTY[$#MATCHSHIFTY]
else
    @ deltay = $nz - $msyindex * $MATCHSHIFTINC
    @ msy1 = $MATCHSHIFTY[$msyindex]
    @ msyindex++
    @ msy2 = $MATCHSHIFTY[$msyindex]
    @ deltamsy = $msy2 - $msy1
    @ msy = $msy1 + ($deltay * $deltamsy ) / $MATCHSHIFTINC
endif

# Set the size in X and Z, not bigger than 1/4 of X dimension
@ msxz = $MATCHSHIFTXZ
if ($msxz > $nx / 4) @ msxz = $nx / 4

# Get patch model file

set modeltext = "gibberish"
if ($interactive) then
    echo "Enter name of model file with contours enclosing patches to use for fits,"
    echo -n "   or Return to use all patches: "
    set regionmod = $<
endif

if ($regionmod != "") then
    set modeltext = "matchorwarp -size"
    set delregion = "gibberish"
    if (! -e $regionmod) then
	echo " "
	echo2 "WARNING: file $regionmod does not yet exist."
    endif
endif

@ npatchx = ($patchxu + $DELPATCHXY / 2 - $patchxl) / $DELPATCHXY
@ npatchy = ($patchyu + $DELPATCHXY / 2 - $patchyl) / $DELPATCHXY

# set number of patches in Z based on criteria, but if patch thickness
# is greater than two-thirds of extent, do only one row of patches
@ npatchz = 2
if (($patchzu - $patchzl) >= $NZPATCH3) @ npatchz = 3
if (($patchzu - $patchzl) >= $NZPATCH4) @ npatchz = 4
if ($patchnz > (2 * ($patchzu - $patchzl)) / 3) then
    @ npatchz = 1
    echo " "
    echo2 "WARNING: Only one layer of patches will be computed in Z"
endif

# If patch thickness is greater than extent cut it down
#
if ($patchnz > $patchzu + 1 - $patchzl) then
    @ patchnz = $patchzu + 1 - $patchzl
    echo " "
    echo2 "WARNING: Patch thickness set to $patchnz to fit within Z limits"
endif

# compute disk space needed before asking about temp directory
@ kpixel = ((($nx * $nz) / 100) * $ny) / 10
@ mbytes = ((6 * $kpixel) + ($kpixel / 2)) / 1000
@ lim1 = ((4 * $kpixel) + ($kpixel / 2) + (8 * $MAXPIXELS)) / 1000
if ($lim1 > $mbytes) @ mbytes = $lim1
@ lim1 = ((2 * $kpixel) + (10 * $MAXPIXELS)) / 1000
if ($lim1 > $mbytes) @ mbytes = $lim1

echo " "
echo "$mbytes MBytes of disk space will be needed for combining"

if ($interactive) then
    echo "If you want to use a local temporary directory, enter the path name of a"
    echo " directory in which the temporary directory can be created (e.g., /usr/tmp)"
    echo -n " or Return for no temporary directory: "
    set tmproot = $<
    set handclean = "-1"
endif

if ("$tmproot" == "") then
    set tmpdir = ""
    set tmppath = ""
    set ifmkdir = '#$if'
    set tempdirarg = " -tempdir "
    set tmpmatfile = $matfile
    set sedtmpdir = ""
    set sedmatfile = $matfile
    set sedtempkey = "gibberish"
else
    # WORKAROUND 10/20/05: need to just exit since etomo doesn't check
    if (! -d $tmproot) then
        echo ""
        echo "ERROR: $pn - $tmproot does not exist or is not a directory"
        exit 1
    else if (! -w $tmproot) then
        echo ""
        echo "ERROR: $pn - You do not have permission to write in $tmproot"
        exit 1
    else
        set tmpdir = $tmproot/combine.$$
        set tmppath = $tmpdir/
        set ifmkdir = '$if'
        set tempdirarg = "gibberish"
        set tmpmatfile = $tmppath$matfile
        set sedtmpdir = `echo $tmpdir | sed 's/\//\\\//g'`
        set sedmatfile = $sedtmpdir\\/$matfile
        set sedtempkey = "TemporaryDir"
    endif
endif

set sumname = sum.rec

# If there is an existing link to sum.rec, remove it
\find . -type l -name sum.rec -exec rm -f "{}" \;

if ($tmpdir != "") then
    if ($interactive) then
        echo " "
        echo "The default is auto-cleanup of your temp directory.  You may choose"
        echo " to clean up by hand if you want fastest possible access to sum.rec,"
        echo " or if you want access to $matfile."
        while ($handclean == "-1")
            echo -n "Do you want to clean up by hand (enter y or n)? "
            set ifhand = $<
            if ($ifhand == "y" || $ifhand == "Y") set handclean = "1"
            if ($ifhand == "n" || $ifhand == "N") set handclean = "0"
        end
        echo " "
    endif
    if ($handclean == "1") then
	set sumname = $tmpdir/sum.rec
	if (! -e sum.rec) ln -s $sumname .
	echo "There should now be a link to sum.rec in the current directory."
	echo " $matfile and the real sum.rec will be left in $tmpdir"
	echo "You are responsible for deleting $tmpdir and its contents"
	echo " when you are done with these files."
    else
	echo "Your temporary directory is $tmpdir"
	echo "It and its contents will be deleted when combine.com finishes successfully".
    endif
endif

echo " "
echo "The number of patches for PATCHCRAWL3D is $npatchx in X, $npatchz in Y, and $npatchy in Z"
echo "   (Y and Z are not flipped on the PATCHCRAWL3D command line)"

if (-e combine.com) \mv -f combine.com combine.com~
if (-e $matchshift) \mv -f $matchshift $matchshift~
if (-e $matchvol1) \mv -f $matchvol1 $matchvol1~
if (-e $matchvol2) \mv -f $matchvol2 $matchvol2~
if (-e $warpvol) \mv -f $warpvol $warpvol~
if (-e $patchcorr) \mv -f $patchcorr $patchcorr~
if (-e $matchorwarp) \mv -f $matchorwarp $matchorwarp~
if (-e $volcombine) \mv -f $volcombine $volcombine~


sed -e s/$from_srcname/$fromname/g\
    -e s/$to_srcname/$toname/g\
    -e "/^ACorrespondenceList/s/[ 	].*/	$corrlist1/"\
    -e "/^BCorrespondenceList/s/[ 	].*/	$corrlist2/"\
    -e "/^XAxisTilts/s/[ 	].*/	$xaxisa[2],$xaxisb[2]/"\
    -e "/^AngleOffsets/s/[ 	].*/	$angoffa[2],$angoffb[2]/"\
    -e "/^ZShifts/s/[ 	].*/	$zshifta[3],$zshiftb[3]/"\
    -e "/^SurfacesOrUseModel/s/[ 	].*/	$modsurf/"\
    -e "/$sedtranskey/s/.*/TransferCoordinateFile	$transfile/"\
    -e "/^UsePoints/s/[ 	].*/	$uselist/"\
    -e "/^MatchingAtoB/s/[ 	].*/	$matchatob/"\
    -e "/matchshifts.*64 32 64/s/64 32 64/$msxz $msy $msxz/"\
	< "$srcdir/$matchshift" | cat >$matchshift

sed -e s/$from_srcname/$fromname/g\
    -e s/$to_srcname/$toname/g\
    -e "s/$tmp_srcname/$sedtmpdir/g"\
    -e "/mkdir/s/.*if/$ifmkdir/"\
    -e s/$matfile/$sedmatfile/g\
    -e "/$sedtempkey/s/\#//"\
    -e "/OutputSizeXYZ/s/\//$size/g"\
    -e "/savework-file/s//$backupsed/g"\
	< "$srcdir/$matchvol1" | cat >$matchvol1

sed -e s/$from_srcname/$fromname/g\
    -e s/$to_srcname/$toname/g\
    -e "s/$tmp_srcname/$sedtmpdir/g"\
    -e "/mkdir/s/.*if/$ifmkdir/"\
    -e s/$matfile/$sedmatfile/g\
    -e "/$sedtempkey/s/\#//"\
    -e "/OutputSizeXYZ/s/\//$size/g"\
	< "$srcdir/$matchvol2" | cat >$matchvol2

sed -e s/$from_srcname/$fromname/g\
    -e s/$to_srcname/$toname/g\
    -e "s/$tmp_srcname/$sedtmpdir/g"\
    -e "/mkdir/s/.*if/$ifmkdir/"\
    -e s/$matfile/$sedmatfile/g\
    -e "/$sedtempkey/s/\#//"\
    -e "/OutputSizeXYZ/s/\//$size/g"\
	< "$srcdir/$warpvol" | cat >$warpvol

sed -e s/$from_srcname/$fromname/g\
    -e s/$to_srcname/$toname/g\
    -e s/$matfile/$sedmatfile/g\
    -e "/^PatchSizeXYZ/s/[ 	].*/	$patchnx,$patchnz,$patchny/"\
    -e "/^NumberOfPatchesXYZ/s/[ 	].*/	$npatchx,$npatchz,$npatchy/"\
    -e "/^XMinAndMax/s/[ 	].*/	$patchxl,$patchxu/"\
    -e "/^YMinAndMax/s/[ 	].*/	$patchzl,$patchzu/"\
    -e "/^ZMinAndMax/s/[ 	].*/	$patchyl,$patchyu/"\
    -e "/^BSourceBorder/s/[ 	].*/	$xyborder,$xyborder/"\
    -e "/^RegionModel/s/[ 	].*/	$regionmod/"\
    -e "/^$delregion/d"\
	< "$srcdir/$patchcorr" | cat >$patchcorr

sed -e s/$from_srcname/$fromname/g\
    -e s/$to_srcname/$toname/g\
    -e "s/$tmp_srcname/$sedtmpdir/g"\
    -e "/mkdir/s/.*if/$ifmkdir/"\
    -e s/$matfile/$sedmatfile/g\
    -e "/$modeltext/s/$modeltext/matchorwarp -modelfile $regionmod -size/"\
    -e "/$tempdirarg/s///"\
	< "$srcdir/$matchorwarp" | cat >$matchorwarp

sed -e s/$from_srcname/$fromname/g\
    -e s/$to_srcname/$toname/g\
    -e "s/$tmp_srcname/$sedtmpdir/g"\
    -e s/$matfile/$sedmatfile/g\
    -e "/savework-file/s//$backupsed/g"\
    	< "$srcdir/$volcombine" | cat >$volcombine

\cp "$srcdir/combine.com" .

@ megamax = $MAXPIXELS
@ megamax /= 1000
set ranlist = `tomopieces -tomo $recfile -mega $megamax -xpad $TAPERPADXZ -ypad $TAPERPADY -zpad $TAPERPADXZ -min $MINOVERLAP -ymax $MAXPIECEY | sed '/[[:cntrl:]]/s///g'`

if ($status) then
    echo $ranlist
    echo "ERROR running tomopieces - does $recfile exist?"
    exit 1
endif


cat <<EOF | cat >> $volcombine
\$set nonomatch
\$\\rm -f ${tmppath}*.mat~ ${tmppath}mat.fft* ${tmppath}rec.fft* ${tmppath}sum.fft* $sumname* ${tmppath}sum[1-9]*.rec*
#
\$echo STATUS: RUNNING FILLTOMO TO FILL IN GRAY AREAS IN THE .MAT FILE
\$echo 
#
\$filltomo
$tmpmatfile
$recfile
$origfile
$invfile
/
EOF

@ npiecex = $ranlist[1]
shift ranlist
@ npiecey = $ranlist[1]
shift ranlist
@ npiecez = $ranlist[1]
shift ranlist

@ npiecetot = $npiecex * $npiecey * $npiecez
@ sumnum = 0
@ znum = 0
while ($znum < $npiecez)
    @ znum++
    @ ynum = 0
    while ($ynum < $npiecey)
        @ ynum++
        @ xnum = 0
        while ($xnum < $npiecex)
            @ xnum++
            @ sumnum++
            cat <<EOCAT | cat >> $volcombine
#
\$dopiece${sumnum}:
\$echo STATUS: EXTRACTING AND COMBINING PIECE  $sumnum  of $npiecetot
\$echo
#
\$taperoutvol
$recfile
${tmppath}rec.st
$ranlist[1]
$TAPERPADXZ,$TAPERPADY,$TAPERPADXZ
\$$FFT3D -3d ${tmppath}rec.st ${tmppath}rec.fft
\$\\rm ${tmppath}rec.st
\$taperoutvol
$tmpmatfile
${tmppath}mat.st
$ranlist[1]
$TAPERPADXZ,$TAPERPADY,$TAPERPADXZ
\$$FFT3D -3d ${tmppath}mat.st ${tmppath}mat.fft
\$\\rm ${tmppath}mat.st
\$combinefft -StandardInput
AInputFFT	${tmppath}rec.fft
BInputFFT	${tmppath}mat.fft
InverseTransformFile	$invfile
ATiltFile	$atlt
BTiltFile	$btlt
ReductionFraction	\$combinefft_reduce
LowFromBothRadius	\$combinefft_lowboth
\$\\rm ${tmppath}rec.fft
\$$FFT3D -3d -m $mode ${tmppath}mat.fft ${tmppath}sum$sumnum.rec
\$\\rm ${tmppath}mat.fft
EOCAT
            shift ranlist
        end
    end
end

cat <<EOCAT | cat >> $volcombine
#
\$echo STATUS: REASSEMBLING PIECES
\$echo
#
\$assemblevol
$sumname
$npiecex,$npiecey,$npiecez
EOCAT

@ xnum = 0
while ($xnum < $npiecex)
    echo $ranlist[1] | cat >> $volcombine
    shift ranlist
    @ xnum++
end

@ ynum = 0
while ($ynum < $npiecey)
    echo $ranlist[1] | cat >> $volcombine
    shift ranlist
    @ ynum++
end

@ znum = 0
while ($znum < $npiecez)
    echo $ranlist[1] | cat >> $volcombine
    shift ranlist
    @ znum++
end
    
@ sumnum = 0
while ($sumnum < $npiecetot)
  @ sumnum++
  echo ${tmppath}sum$sumnum.rec | cat >> $volcombine
end
cat <<EOCAT | cat >> $volcombine
#
\$echo 
\$echo STATUS: RUNNING FILLTOMO ON FINAL VOLUME
\$echo 
#
\$\\rm ${tmppath}sum[1-9]*.rec
\$filltomo
$sumname
$recfile
$origfile
$invfile
/
EOCAT


if ($tmpdir != "" && $handclean == "0") then
cat <<EOCAT | cat >> $volcombine
\$\\rm -r $tmpdir
EOCAT
endif

echo '$'"if (-e $backupname) $backupname" | cat >> $volcombine
exit 0

usage:
cat <<EOF
Usage: setupcombine -options
Options may be abbreviated to unique strings of at least 2 characters;
characters in [] are optional.
Options:
  -na[me]  name       Root name of dataset
  -at[ob]             Match A to B instead of B to A
  -to[list]  list     List of points in tomogram being match to that have 
                        corresponding points 
  -fr[omlist]  list   List of the corresponding points in the tomogram being
                        transformed to match
  -tr[ansfer]  name   File from transferfid with corresponding coordinates
  -us[elist]  list    List of points from A to use with transfer coordinates
  -su[rfaces]  #      0 to use matching models and fiducials if any, 2 for
                        fiducials on both surfaces, 1 or -1 for fiducials on
                        one surface (-1 if tomograms inverted), or -2 to use
                        matching models only
  -pa[tchsize] size   Patch size, either S, M, L or 3 numbers for size in X,Y,Z
  -xl[imits]  #,#     Lower and upper limits of patches in X
  -yl[imits]  #,#     Lower and upper limits of patches in Y
  -zl[imits]  #,#     Lower and upper limits of patches in Z
  -re[gionmod]  name  Model with contours enclosing regions to do patches in
  -te[mpdir]  name    Location to create a temporary local directory
  -no[clean]          Do not clean up the temporary directory  
EOF

#
#  $Log$
#  Revision 3.39  2009/10/28 00:22:54  mast
#  Changed the cleanup statements to use find instead of rm due to change in tcsh
#
#  Revision 3.38  2008/01/04 07:03:38  mast
#  Fixed for space in IMOD_DIR, possibly for space in tmpdir
#
#  Revision 3.37  2006/09/13 22:32:35  mast
#  Added LowFromBoth entry for combinefft
#
#  Revision 3.36  2006/08/23 04:35:35  mast
#  Process new patchcorr.com and extract more tilt parameters for solvematch
#
#  Revision 3.35  2006/06/23 03:22:23  mast
#  Convert com directory path from windows to cygwin format
#
#  Revision 3.34  2006/05/11 23:39:08  mast
#  Changed list arguments and usage output to remove a-b confusion
#
#  Revision 3.33  2006/05/05 17:35:29  mast
#  Converted to command-line arguments and change solvematch processing
#
#  Revision 3.32  2006/02/16 06:47:09  mast
#  Stripped control chars from output of sed/header etc for Windows
#
#  Revision 3.31  2005/11/19 04:31:26  mast
#  Quote path setting to preserve spaces
#
#  Revision 3.30  2005/10/20 19:36:36  mast
#  Exit with error if temp directory is not usable to avoid etomo hangup
#
#  Revision 3.29  2005/08/30 01:55:48  mast
#  Allowed / input to the correspondence list
#
#  Revision 3.28  2004/11/30 04:43:22  mast
#  Switched from combinefft_options command-line to combinefft_reduce entered
#  through standard input
#
#  Revision 3.27  2004/10/27 22:25:01  mast
#  Switched to using fftrans
#
#  Revision 3.26  2004/08/12 17:42:02  mast
#  Put back right version for 3.4
#
#  Revision 3.24  2004/07/22 18:17:12  mast
#  Change to better sed command for stripping Ctrl M
#
#  Revision 3.23  2004/07/13 18:15:40  mast
#  Changed to PIP format for combinefft with an option variable, added a
#  label for each piece for a goto at the start to jump to
#
#  Revision 3.22  2004/06/20 15:32:30  mast
#  Restore new solvematch and cut patch thickness to fit in limits
#
#  Revision 3.20  2004/06/14 19:29:10  mast
#  Changed to handle general 3D output of tomopieces but constrained to
#  one layer in Y
#
#  Revision 3.19  2004/06/10 22:46:08  mast
#  Changes for new solvematch command file
#
#  Revision 3.18  2004/04/27 14:55:11  mast
#  Removed warning for no xaxistilt line, it is fine if it is not there
#
#  Revision 3.17  2004/04/24 03:37:36  mast
#  Added check for xaxistilt lines and warning if they are not there
#
#  Revision 3.16  2004/01/13 20:02:06  mast
#  ($<) does not work in true csh on SGI, so make wordlist in two steps
#
#  Revision 3.15  2003/10/24 02:14:00  mast
#  source settmpdir to get tmpdir, better for Windows
#
#  Revision 3.14  2003/10/16 20:43:06  mast
#  Make matchshift patches bigger in X and Y to reduce check volume failures
#
#  Revision 3.13  2003/10/11 00:05:52  mast
#  Changes for new input methods for matchvol/warpvol
#
#  Revision 3.12  2003/05/23 00:38:25  mast
#  Move creation of temporary directory into sub-command files
#
#  Revision 3.11  2003/05/20 21:39:47  mast
#  Strip spaces from corresponding fiducial list
#
#  Revision 3.10  2003/05/19 22:50:25  mast
#  *** empty log message ***
#
#  Revision 3.9  2003/05/13 22:00:48  mast
#  Fix getting x axis tilt for Windows/Cygwin
#
#  Revision 3.8  2003/05/12 23:21:11  mast
#  remove test for piping
#
#  Revision 3.7  2003/05/12 18:53:24  mast
#  Pipe command files through cat for dos line endings in cygwin
#
#  Revision 3.6  2002/11/04 20:38:02  mast
#  Made WARNINGS go to standard error with echo2
#
#  Revision 3.5  2002/10/23 15:36:50  mast
#  Made it set up for one patch in Z if patch thickness is two-thirds of the
#  spacing between the limits in Z.  Also made warnings start on a new line
#  and all start with WARNING:
#
#  Revision 3.4  2002/08/03 00:36:02  mast
#  Added a blank line before last STATUS in volcombine.com
#
#  Revision 3.3  2002/07/27 23:57:02  mast
#  Change volcombine STATUS line to say piece n of m
#
#  Revision 3.2  2002/07/21 19:33:30  mast
#  Made default borders for patchcorr be based upon image size, and also
#  made thickness passed to Matchshifts bigger and based on image size
#
#  Revision 3.1  2002/06/19 16:06:29  mast
#  Conversion to multiple command files
#
#  Revision 3.0  2001/11/29 18:11:11  rickg
#  *** empty log message ***
#
#  Revision 1.2  2001/11/28 23:23:55  mast
#  Minor changes to accomodate changing from $! to # in command files.
#

