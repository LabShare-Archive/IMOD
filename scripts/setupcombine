#! /bin/csh -f
# SCRIPT TO COPY AND MODIFY COMBINE.COM

set XYBORDER = 36
set PATCHXY = (64 80 100)
set PATCHZ = (32 40 50)
set DELPATCHXY = 100
set NZPATCH3 = 75      # Thickness at which to do 3 patches in Z
set NZPATCH4 = 150     # Thickness at which to do 4 patches in Z
set MAXPIXELS = 20000  # KPixels for maximum FFT
set MAXMEMORY = 8.e7   # Memory size for ffts = 4000 * MAXPIXELS
set TAPERPADXZ = 8       # Size of taper/pad for 3D ffts in X and Z
set TAPERPADY = 4       # Size of taper/pad for 3D ffts in Y
set MINOVERLAP = 10     # Minimum overlap between pieces

set to_srcname = "g5a"
set from_srcname = "g5b"
set tmp_srcname = "g5tmpdir"
set backupname = "./savework"
set backupsed = ".\/savework"

if ($?IMOD_DIR) then
    set srcdir = "$IMOD_DIR/com"
    set path = ($IMOD_DIR/bin $path)
else
    echo "Environment variable IMOD_DIR must be set to the top IMOD directory"
    exit 1
endif


if (! -d $srcdir) then
    echo "Source directory for command file, $srcdir, not found."
    echo "Edit $0 if necessary to set the source directory correctly"
    exit 1
endif

set noglob

echo " "
echo "This program sets up the file combine.com for combining two tomograms."
echo "There are no command line arguments."
echo "Just answer each of the questions in turn."
echo "To interrupt, type Ctrl-C then Return"
echo " "

echo -n "Enter root name of data sets (omitting a or b and extension): "
set rootname = $<
set tolet = "z"
while ($tolet != "a" && $tolet != "b")
    echo -n "Enter letter of tomogram being matched TO (a or b): "
    set tolet = $<
    if ($tolet == "a") then
        set fromlet = "b"
    else if ($tolet == "b") then
        set fromlet = "a"
    endif
end
set toname = $rootname$tolet
set fromname = $rootname$fromlet
set tilta = "tilt$tolet.com"
set tiltb = "tilt$fromlet.com"

if ((-e tilta.com) && (-e tiltb.com)) then
    set xaxisa = `grep -i xaxistilt $tilta`
    set xaxisb = `grep -i xaxistilt $tiltb`
else
    echo "WARNING: CANNOT FIND tilta.com or tiltb.com; CANNOT SET X-AXIS TILTS CORRECTLY"
    set xaxisa = "xaxistilt 0."
    set xaxisb = "xaxistilt 0."
endif

set xaxisa = ($xaxisa)
set xaxisb = ($xaxisb)

set recfile = $toname.rec
set matfile = $fromname.mat
set origfile = $fromname.rec
set invfile = "inverse.xf"
set atlt = $toname.tlt
set btlt = $fromname.tlt
set mode = 1

if (-e $recfile) then
    set size = `header $recfile | sed -n '/rows, sections/p'| awk '{print $7, $8, $9}'`
    set modeline = `header $recfile | sed -n '/Map mode/p'`
    if ($modeline[4] == 2) set mode = 2
else
    set size = `echo "1024 60 1024"`
    echo "WARNING: $recfile NOT FOUND; SETTING SIZE TO $size FOR TEST PURPOSES"
endif

echo ""
echo "Specify the correspondence between fiducial points in the two tilt alignments."
echo "Enter a list of the points in tilt series $tolet for which you"
echo "are sure of the corresponding point in tilt series $fromlet"
echo " (ranges may be entered)."
echo "Or just Return if the points are in one-to-one correspondence."
set corrlist1 = $<
set corrtext1 = "gibberish"
set corrtext2 = "gibberish"
set corrlist2 = " "
if ($corrlist1 != "") then
    set corrtext1 = "list of points in 1st"
    echo "Enter a list of the corresponding points in tilt series $fromlet"
    set corrlist2 = $<
    set corrtext2 = "list of corresponding points"
endif

set modsurf = "z"
while ($modsurf != "0" && $modsurf != "1" && $modsurf != "-1" && $modsurf != "2")
echo ""
echo "Enter 0 to use models of corresponding points ($toname.matmod and"
echo " $fromname.matmod) to specify initial registration between tomograms;"
echo " otherwise enter:"
echo "   1 if fiducials are on only one surface and tomograms are NOT inverted,"
echo "  -1 if fiducials are on only one surface and tomograms are inverted"
echo "           relative to each other, or"
echo -n "   2 if there are fiducials on both surfaces: "
set modsurf = $<
end

set gotomodel = '$\!goto'
if ($modsurf == "0") set gotomodel = '$goto'

@ nx = $size[1]
@ ny = $size[3]
@ nz = $size[2]

set ifok = "0"
while ($ifok == "0")
    echo ""
    echo "Enter s for small patches ($PATCHXY[1] x $PATCHZ[1] x $PATCHXY[1]), m for medium patches ($PATCHXY[2] x $PATCHZ[2] x $PATCHXY[2]),"
    echo -n " or l for large patches ($PATCHXY[3] x $PATCHZ[3] x $PATCHXY[3]) (Return for m): "
    set patchin = $<
    set ifok = "1"
    if ($patchin == "") set patchin = "M"
    if ($patchin == "s" || $patchin == "S") then
	set indpatch = 1
    else if ($patchin == "m" || $patchin == "M") then
	set indpatch = 2
    else if ($patchin == "l" || $patchin == "L") then
	set indpatch = 3
    else
	set ifok = "0"
    endif
end

echo ""
echo "Now specify the limits of the volume from which patches will be"
echo "      extracted by patchcrawl3d."
echo "The default upper limits for X and Y are based on a border of $XYBORDER pixels."
set ifok = "0"
while ($ifok == "0")
    @ patchxl = $XYBORDER
    @ patchxu = $nx - $XYBORDER
    echo -n "Lower X (left) limit of area (Return for $patchxl): "
    set patchin = $<
    if ($patchin != "") @ patchxl = $patchin
    echo -n "Upper X (right) limit of area (Return for $patchxu): "
    set patchin = $<
    if ($patchin != "") @ patchxu = $patchin
    if ($patchxl < 0 ) then
	echo "Lower limit out of bounds, try again"
    else if ($patchxu > $nx) then
	echo "Upper limit out of bounds, try again"
    else if ($patchxl >= $patchxu) then
	echo "Lower limit greater than upper limit, try again"
    else
	set ifok = "1"
    endif
end
set ifok = "0"
while ($ifok == "0")
    @ patchyl = $XYBORDER
    @ patchyu = $ny - $XYBORDER
    echo -n "Lower Y (bottom) limit of area in flipped tomogram (Return for $patchyl): "
    set patchin = $<
    if ($patchin != "") @ patchyl = $patchin
    echo -n "Upper Y (top) limit of area in flipped tomogram (Return for $patchyu): "
    set patchin = $<
    if ($patchin != "") @ patchyu = $patchin
    if ($patchyl < 0 ) then
	echo "Lower limit out of bounds, try again"
    else if ($patchyu > $ny) then
	echo "Upper limit out of bounds, try again"
    else if ($patchyl >= $patchyu) then
	echo "Lower limit greater than upper limit, try again"
    else
	set ifok = "1"
    endif
end
set ifok = "0"
while ($ifok == "0")
    set patchin = ""
    while ($patchin == "")
	echo -n "Lower Z limit of volume (bottom slice) in flipped tomogram: "
	set patchin = $<
	if ($patchin != "") then
	    @ patchzl = $patchin
	endif
    end

    set patchin = ""
    while ($patchin == "")
	echo -n "Upper Z limit of volume (top slice) in flipped tomogram: "
	set patchin = $<
	if ($patchin != "") then
	    @ patchzu = $patchin
	endif
    end
    if ($patchzl < 0 ) then
	echo "Lower limit out of bounds, try again"
    else if ($patchzu > $nz) then
	echo "Upper limit out of bounds, try again"
    else if ($patchzl >= $patchzu) then
	echo "Lower limit greater than upper limit, try again"
    else
	set ifok = "1"
    endif
end

set modeltext = "gibberish"
echo "Enter name of model file with contours enclosing patches to use for fits,"
echo -n "   or Return to use all patches: "
set modelin = $<
if ($modelin != "") then
    set modeltext = "matchorwarp -size"
    if (! -e $modelin) echo "Warning: file $modelin does not yet exist."
endif

@ npatchx = ($patchxu + $DELPATCHXY / 2 - $patchxl) / $DELPATCHXY
@ npatchy = ($patchyu + $DELPATCHXY / 2 - $patchyl) / $DELPATCHXY
@ npatchz = 2
if (($patchzu - $patchzl) >= $NZPATCH3) @ npatchz = 3
if (($patchzu - $patchzl) >= $NZPATCH4) @ npatchz = 4

# compute disk space needed before asking about temp directory
@ kpixel = ((($nx * $nz) / 100) * $ny) / 10
@ mbytes = ((6 * $kpixel) + ($kpixel / 2)) / 1000
@ lim1 = ((4 * $kpixel) + ($kpixel / 2) + (8 * $MAXPIXELS)) / 1000
if ($lim1 > $mbytes) @ mbytes = $lim1
@ lim1 = ((2 * $kpixel) + (10 * $MAXPIXELS)) / 1000
if ($lim1 > $mbytes) @ mbytes = $lim1

echo " "
echo "$mbytes MBytes of disk space will be needed for combining"

set ifok = "0"
while ($ifok == "0")
    echo "If you want to use a local temporary directory, enter the path name of a"
    echo " directory in which the temporary directory can be created (e.g., /usr/tmp)"
    echo -n " or Return for no temporary directory: "
    set tmproot = $<
    if ($tmproot == "") then
	set tmpdir = ""
	set tmppath = ""
	set ifmkdir = '$\!if'
        set tempdirarg = " -tempdir "
	set tmpmatfile = $matfile
	set sedtmpdir = ""
	set sedmatfile = $matfile
	set ifok = "1"
    else
	if (! -d $tmproot) then
	    echo "$tmproot does not exist or is not a directory; try again"
	else if (! -w $tmproot) then
	    echo "You do not have permission to write in $tmproot; try again"
	else
	    set tmpdir = $tmproot/combine.$$
	    set tmppath = $tmpdir/
	    set ifmkdir = '$if'
	    set tempdirarg = "gibberish"
	    set tmpmatfile = $tmppath$matfile
	    set sedtmpdir = `echo $tmpdir | sed 's/\//\\\//g'`
	    set sedmatfile = $sedtmpdir\\/$matfile
	    set ifok = "1"
	endif
    endif
end

set sumname = sum.rec

# If there is an existing link to sum.rec, remove it
if (-e sum.rec) then
    set testlink = `ls -l sum.rec | awk '{print $1}' | grep l`
    if ($testlink != "") \rm sum.rec
endif

set handclean = "-1"
if ($tmpdir != "") then
    echo " "
    echo "The default is auto-cleanup of your temp directory.  You may choose"
    echo " to clean up by hand if you want fastest possible access to sum.rec,"
    echo " or if you want access to $matfile."
    while ($handclean == "-1")
	echo -n "Do you want to clean up by hand (enter y or n)? "
	set ifhand = $<
	if ($ifhand == "y" || $ifhand == "Y") set handclean = "1"
	if ($ifhand == "n" || $ifhand == "N") set handclean = "0"
    end
    echo " "
    if ($handclean == "1") then
	set sumname = $tmpdir/sum.rec
	if (! -e sum.rec) ln -s $sumname .
	echo "There should now be a link to sum.rec in the current directory."
	echo " $matfile and the real sum.rec will be left in $tmpdir"
	echo "You are responsible for deleting $tmpdir and its contents"
	echo " when you are done with these files."
    else
	echo "Your temporary directory is $tmpdir"
	echo "It and its contents will be deleted when combine.com finishes successfully".
    endif
endif

echo " "
echo "The number of patches for PATCHCRAWL3D is $npatchx in X, $npatchz in Y, and $npatchy in Z"
echo "   (Y and Z are not flipped on the PATCHCRAWL3D command line)"

if (-e combine.com) \mv -f combine.com combine.com~
sed -e "/patchcrawl3d *[0-9]/s/3d[ 0-9]*/3d  $PATCHXY[$indpatch] $PATCHZ[$indpatch] $PATCHXY[$indpatch]   $npatchx $npatchz $npatchy   $patchxl $patchxu   $patchzl $patchzu   $patchyl $patchyu /g"\
    -e s/$from_srcname/$fromname/g\
    -e s/$to_srcname/$toname/g\
    -e "s/$tmp_srcname/$sedtmpdir/g"\
    -e s/$matfile/$sedmatfile/g\
    -e "/goto usemodels/s/.*goto /$gotomodel /"\
    -e "/mkdir/s/.*if/$ifmkdir/"\
    -e "/$corrtext1/s/.*	/$corrlist1	/g"\
    -e "/$corrtext2/s/.*	/$corrlist2	/g"\
    -e "/X-axis tilt/s/.*	/$xaxisa[2],$xaxisb[2]	/g"\
    -e "/0 to use models/s/.*	/$modsurf	/g"\
    -e "/NX,NY,NZ of output/s/.*	/$size	/g"\
    -e "/$modeltext/s/$modeltext/matchorwarp -modelfile $modelin -size/"\
    -e "/boundary_model/s//$modelin/"\
    -e "/savework-file/s//$backupsed/g"\
    -e "/$tempdirarg/s///"\
	<$srcdir/combine.com >combine.com

set ranlist = `tomopieces $recfile $MAXMEMORY $TAPERPADXZ $TAPERPADY $MINOVERLAP`

if ($status) then
    echo "Error running tomopieces - does $recfile exist?"
    exit 1
endif

cat >> combine.com <<EOF
\$touch prevent-error
\$\\rm prevent-err* ${tmppath}*.mat~ ${tmppath}mat.fft* ${tmppath}rec.fft* ${tmppath}sum.fft* $sumname* ${tmppath}sum[1-9]*.rec*
\$!
\$filltomo
$tmpmatfile
$recfile
$origfile
$invfile
/
EOF

@ npiecex = $ranlist[1]
shift ranlist
@ npiecez = $ranlist[1]
shift ranlist

@ sumnum = 0
@ znum = 0
while ($znum < $npiecez)
    @ znum++
    @ xnum = 0
    while ($xnum < $npiecex)
	@ xnum++
	@ sumnum++
	cat >> combine.com <<EOCAT
#
# Extracting and combining piece $sumnum
#
\$taperoutvol
$recfile
${tmppath}rec.st
$ranlist[1]
$TAPERPADXZ,$TAPERPADY,$TAPERPADXZ
\$clip fft -3d ${tmppath}rec.st ${tmppath}rec.fft
\$\\rm ${tmppath}rec.st
\$taperoutvol
$tmpmatfile
${tmppath}mat.st
$ranlist[1]
$TAPERPADXZ,$TAPERPADY,$TAPERPADXZ
\$clip fft -3d ${tmppath}mat.st ${tmppath}mat.fft
\$\\rm ${tmppath}mat.st
\$combinefft
${tmppath}rec.fft
${tmppath}mat.fft

$invfile
$atlt
$btlt
\$\\rm ${tmppath}rec.fft
\$clip fft -3d -m $mode ${tmppath}mat.fft ${tmppath}sum$sumnum.rec
\$\\rm ${tmppath}mat.fft
EOCAT
	shift ranlist
    end
end

cat >> combine.com <<EOCAT
#
# Reassembing pieces
#
\$assemblevol
$sumname
$npiecex,1,$npiecez
EOCAT
@ xnum = 0
while ($xnum < $npiecex)
    echo $ranlist[1] >> combine.com
    shift ranlist
    @ xnum++
end
echo $ranlist[1] >> combine.com
shift ranlist
@ znum = 0
while ($znum < $npiecez)
    echo $ranlist[1] >> combine.com
    shift ranlist
    @ znum++
end
    
@ sumnum = 0
while ($sumnum < $npiecex * $npiecez)
  @ sumnum++
  echo ${tmppath}sum$sumnum.rec >> combine.com
end
cat >> combine.com <<EOCAT
#
# Clear out pieces and fill bad pixels again
#
\$\\rm ${tmppath}sum[1-9]*.rec
\$filltomo
$sumname
$recfile
$origfile
$invfile
/
EOCAT


if ($handclean == "0") then
cat >> combine.com <<EOCAT
\$\\rm -r $tmpdir
EOCAT
endif

echo '$'"if (-e $backupname) $backupname" >> combine.com
