#! /bin/csh -f
# SCRIPT TO COPY AND MODIFY COMBINE.COM AND ASSOCIATED COM FILES

set XYBORDERS = (24 36 54 68 80)    # border sizes per increment of minimum
set BORDERINC = 1000                # dimension
set PATCHXY = (64 80 100)
set PATCHZ = (32 40 50)
set DELPATCHXY = 100
set NZPATCH3 = 75      # Thickness at which to do 3 patches in Z
set NZPATCH4 = 150     # Thickness at which to do 4 patches in Z
set MAXPIXELS = 20000  # KPixels for maximum FFT
set MAXMEMORY = 8.e7   # Memory size for ffts = 4000 * MAXPIXELS
set TAPERPADXZ = 8       # Size of taper/pad for 3D ffts in X and Z
set TAPERPADY = 4       # Size of taper/pad for 3D ffts in Y
set MINOVERLAP = 10     # Minimum overlap between pieces
set MATCHSHIFTXZ = 56   # size of 3-D box in X and Z for matchshifts
set MATCHSHIFTY  = (40 60 76 90)      # Y sizes per increment of Y dimension
set MATCHSHIFTINC = 100

set to_srcname = "g5a"
set from_srcname = "g5b"
set tmp_srcname = "g5tmpdir"
set backupname = "./savework"
set backupsed = ".\/savework"

set matchshift = solvematchshift.com
set matchmod = solvematchmod.com
set matchvol1 = matchvol1.com
set patchcorr = patchcorr.com
set matchorwarp = matchorwarp.com
set warpvol = warpvol.com
set matchvol2 = matchvol2.com
set volcombine = volcombine.com

set pipecom = ""
if ($?CYGWIN) then
    if (`echo $CYGWIN | grep nobinmode` != "") set pipecom = "| cat"
endif

echo $pipecom

#  $Author$
#
#  $Date$
#
#  $Revision$
#
#  $Log$
#  Revision 3.6  2002/11/04 20:38:02  mast
#  Made WARNINGS go to standard error with echo2
#
#  Revision 3.5  2002/10/23 15:36:50  mast
#  Made it set up for one patch in Z if patch thickness is two-thirds of the
#  spacing between the limits in Z.  Also made warnings start on a new line
#  and all start with WARNING:
#
#  Revision 3.4  2002/08/03 00:36:02  mast
#  Added a blank line before last STATUS in volcombine.com
#
#  Revision 3.3  2002/07/27 23:57:02  mast
#  Change volcombine STATUS line to say piece n of m
#
#  Revision 3.2  2002/07/21 19:33:30  mast
#  Made default borders for patchcorr be based upon image size, and also
#  made thickness passed to Matchshifts bigger and based on image size
#
#  Revision 3.1  2002/06/19 16:06:29  mast
#  Conversion to multiple command files
#
#  Revision 3.0  2001/11/29 18:11:11  rickg
#  *** empty log message ***
#
#  Revision 1.2  2001/11/28 23:23:55  mast
#  Minor changes to accomodate changing from $! to # in command files.
#
#
if ($?IMOD_DIR) then
    set srcdir = "$IMOD_DIR/com"
    set path = ($IMOD_DIR/bin $path)
else
    echo "Environment variable IMOD_DIR must be set to the top IMOD directory"
    exit 1
endif


if (! -d $srcdir) then
    echo "Source directory for command file, $srcdir, not found."
    echo "Edit $0 if necessary to set the source directory correctly"
    exit 1
endif

set noglob

echo " "
echo "This program sets up the file combine.com for combining two tomograms."
echo "There are no command line arguments."
echo "Just answer each of the questions in turn."
echo "To interrupt, type Ctrl-C then Return"
echo " "

echo -n "Enter root name of data sets (omitting a or b and extension): "
set rootname = $<
set tolet = "z"
while ($tolet != "a" && $tolet != "b")
    echo -n "Enter letter of tomogram being matched TO (a or b): "
    set tolet = $<
    if ($tolet == "a") then
        set fromlet = "b"
    else if ($tolet == "b") then
        set fromlet = "a"
    endif
end
set toname = $rootname$tolet
set fromname = $rootname$fromlet
set tilta = "tilt$tolet.com"
set tiltb = "tilt$fromlet.com"

if ((-e tilta.com) && (-e tiltb.com)) then
    set xaxisa = `grep -i xaxistilt $tilta`
    set xaxisb = `grep -i xaxistilt $tiltb`
else
    echo " "
    echo2 "WARNING: CANNOT FIND tilta.com or tiltb.com; CANNOT SET X-AXIS TILTS CORRECTLY"
    set xaxisa = "xaxistilt 0."
    set xaxisb = "xaxistilt 0."
endif

set xaxisa = ($xaxisa)
set xaxisb = ($xaxisb)

set recfile = $toname.rec
set matfile = $fromname.mat
set origfile = $fromname.rec
set invfile = "inverse.xf"
set atlt = $toname.tlt
set btlt = $fromname.tlt
set mode = 1

if (-e $recfile) then
    set size = `header $recfile | sed -n '/rows, sections/p'| awk '{print $7, $8, $9}'`
    set modeline = `header $recfile | sed -n '/Map mode/p'`
    if ($modeline[4] == 2) set mode = 2
else
    set size = `echo "1024 60 1024"`
    echo " "
    echo2 "WARNING: $recfile NOT FOUND; SETTING SIZE TO $size FOR TEST PURPOSES"
endif

echo ""
echo "Specify the correspondence between fiducial points in the two tilt alignments."
echo "Enter a list of the points in tilt series $tolet for which you"
echo "are sure of the corresponding point in tilt series $fromlet"
echo " (ranges may be entered)."
echo "Or just Return if the points are in one-to-one correspondence."
set corrlist1 = $<
set corrtext1 = "gibberish"
set corrtext2 = "gibberish"
set corrlist2 = " "
if ($corrlist1 != "") then
    set corrtext1 = "list of points in 1st"
    echo "Enter a list of the corresponding points in tilt series $fromlet"
    set corrlist2 = $<
    set corrtext2 = "list of corresponding points"
endif

set modsurf = "z"
while ($modsurf != "0" && $modsurf != "1" && $modsurf != "-1" && $modsurf != "2")
echo ""
echo "Enter 0 to use models of corresponding points ($toname.matmod and"
echo " $fromname.matmod) to specify initial registration between tomograms;"
echo " otherwise enter:"
echo "   1 if fiducials are on only one surface and tomograms are NOT inverted,"
echo "  -1 if fiducials are on only one surface and tomograms are inverted"
echo "           relative to each other, or"
echo -n "   2 if there are fiducials on both surfaces: "
set modsurf = $<
end

set uncomment = $matchshift
set comment = $matchmod
set surftext = "0 to use models"
if ($modsurf == "0") then
    set comment = $matchshift
    set uncomment = $matchmod
    set surftext = "gibberish"
endif

@ nx = $size[1]
@ ny = $size[3]
@ nz = $size[2]

set ifok = "0"
while ($ifok == "0")
    echo ""
    echo "Enter s for small patches ($PATCHXY[1] x $PATCHZ[1] x $PATCHXY[1]), m for medium patches ($PATCHXY[2] x $PATCHZ[2] x $PATCHXY[2]),"
    echo -n " or l for large patches ($PATCHXY[3] x $PATCHZ[3] x $PATCHXY[3]) (Return for m): "
    set patchin = $<
    set ifok = "1"
    if ($patchin == "") set patchin = "M"
    if ($patchin == "s" || $patchin == "S") then
	set indpatch = 1
    else if ($patchin == "m" || $patchin == "M") then
	set indpatch = 2
    else if ($patchin == "l" || $patchin == "L") then
	set indpatch = 3
    else
	set ifok = "0"
    endif
end

@ minsize = $nx
if ($ny < $nx) @ minsize = $ny
@ borderindex = 1 + $minsize / $BORDERINC
if ($borderindex > $#XYBORDERS) @ borderindex = $#XYBORDERS
set xyborder = $XYBORDERS[$borderindex]

echo ""
echo "Now specify the limits of the volume from which patches will be"
echo "      extracted by patchcrawl3d."
echo "The default upper limits for X and Y are based on a border of $xyborder pixels."
set ifok = "0"
while ($ifok == "0")
    @ patchxl = $xyborder
    @ patchxu = $nx - $xyborder
    echo -n "Lower X (left) limit of area (Return for $patchxl): "
    set patchin = $<
    if ($patchin != "") @ patchxl = $patchin
    echo -n "Upper X (right) limit of area (Return for $patchxu): "
    set patchin = $<
    if ($patchin != "") @ patchxu = $patchin
    if ($patchxl < 0 ) then
	echo "Lower limit out of bounds, try again"
    else if ($patchxu > $nx) then
	echo "Upper limit out of bounds, try again"
    else if ($patchxl >= $patchxu) then
	echo "Lower limit greater than upper limit, try again"
    else
	set ifok = "1"
    endif
end
set ifok = "0"
while ($ifok == "0")
    @ patchyl = $xyborder
    @ patchyu = $ny - $xyborder
    echo -n "Lower Y (bottom) limit of area in flipped tomogram (Return for $patchyl): "
    set patchin = $<
    if ($patchin != "") @ patchyl = $patchin
    echo -n "Upper Y (top) limit of area in flipped tomogram (Return for $patchyu): "
    set patchin = $<
    if ($patchin != "") @ patchyu = $patchin
    if ($patchyl < 0 ) then
	echo "Lower limit out of bounds, try again"
    else if ($patchyu > $ny) then
	echo "Upper limit out of bounds, try again"
    else if ($patchyl >= $patchyu) then
	echo "Lower limit greater than upper limit, try again"
    else
	set ifok = "1"
    endif
end
set ifok = "0"
while ($ifok == "0")
    set patchin = ""
    while ($patchin == "")
	echo -n "Lower Z limit of volume (bottom slice) in flipped tomogram: "
	set patchin = $<
	if ($patchin != "") then
	    @ patchzl = $patchin
	endif
    end

    set patchin = ""
    while ($patchin == "")
	echo -n "Upper Z limit of volume (top slice) in flipped tomogram: "
	set patchin = $<
	if ($patchin != "") then
	    @ patchzu = $patchin
	endif
    end
    if ($patchzl < 0 ) then
	echo "Lower limit out of bounds, try again"
    else if ($patchzu > $nz) then
	echo "Upper limit out of bounds, try again"
    else if ($patchzl >= $patchzu) then
	echo "Lower limit greater than upper limit, try again"
    else
	set ifok = "1"
    endif
end

# figure out a size in Y for matchshift block
@ msyindex = $nz / $MATCHSHIFTINC
if ($msyindex == 0) then
    @ msy = $MATCHSHIFTY[1]
    if ($msy > $nz) @ msy = $nz
else if ($msyindex >= $#MATCHSHIFTY) then
    @ msy = $MATCHSHIFTY[$#MATCHSHIFTY]
else
    @ deltay = $nz - $msyindex * $MATCHSHIFTINC
    @ msy1 = $MATCHSHIFTY[$msyindex]
    @ msyindex++
    @ msy2 = $MATCHSHIFTY[$msyindex]
    @ deltamsy = $msy2 - $msy1
    @ msy = $msy1 + ($deltay * $deltamsy ) / $MATCHSHIFTINC
endif

# Get patch model file

set modeltext = "gibberish"
echo "Enter name of model file with contours enclosing patches to use for fits,"
echo -n "   or Return to use all patches: "
set modelin = $<
if ($modelin != "") then
    set modeltext = "matchorwarp -size"
    if (! -e $modelin) then
	echo " "
	echo2 "WARNING: file $modelin does not yet exist."
    endif
endif

@ npatchx = ($patchxu + $DELPATCHXY / 2 - $patchxl) / $DELPATCHXY
@ npatchy = ($patchyu + $DELPATCHXY / 2 - $patchyl) / $DELPATCHXY

# set number of patches in Z based on criteria, but if patch thickness
# is greater than two-thirds of extent, do only one row of patches
@ npatchz = 2
if (($patchzu - $patchzl) >= $NZPATCH3) @ npatchz = 3
if (($patchzu - $patchzl) >= $NZPATCH4) @ npatchz = 4
if ($PATCHZ[$indpatch] > (2 * ($patchzu - $patchzl)) / 3) then
    @ npatchz = 1
    echo " "
    echo2 "WARNING: Only one layer of patches will be computed in Z"
endif

# compute disk space needed before asking about temp directory
@ kpixel = ((($nx * $nz) / 100) * $ny) / 10
@ mbytes = ((6 * $kpixel) + ($kpixel / 2)) / 1000
@ lim1 = ((4 * $kpixel) + ($kpixel / 2) + (8 * $MAXPIXELS)) / 1000
if ($lim1 > $mbytes) @ mbytes = $lim1
@ lim1 = ((2 * $kpixel) + (10 * $MAXPIXELS)) / 1000
if ($lim1 > $mbytes) @ mbytes = $lim1

echo " "
echo "$mbytes MBytes of disk space will be needed for combining"

set ifok = "0"
while ($ifok == "0")
    echo "If you want to use a local temporary directory, enter the path name of a"
    echo " directory in which the temporary directory can be created (e.g., /usr/tmp)"
    echo -n " or Return for no temporary directory: "
    set tmproot = $<
    if ($tmproot == "") then
	set tmpdir = ""
	set tmppath = ""
	set ifmkdir = '#$if'
        set tempdirarg = " -tempdir "
	set tmpmatfile = $matfile
	set sedtmpdir = ""
	set sedmatfile = $matfile
	set ifok = "1"
    else
	if (! -d $tmproot) then
	    echo "$tmproot does not exist or is not a directory; try again"
	else if (! -w $tmproot) then
	    echo "You do not have permission to write in $tmproot; try again"
	else
	    set tmpdir = $tmproot/combine.$$
	    set tmppath = $tmpdir/
	    set ifmkdir = '$if'
	    set tempdirarg = "gibberish"
	    set tmpmatfile = $tmppath$matfile
	    set sedtmpdir = `echo $tmpdir | sed 's/\//\\\//g'`
	    set sedmatfile = $sedtmpdir\\/$matfile
	    set ifok = "1"
	endif
    endif
end

set sumname = sum.rec

# If there is an existing link to sum.rec, remove it
if (-e sum.rec) then
    set testlink = `ls -l sum.rec | awk '{print $1}' | grep l`
    if ($testlink != "") \rm sum.rec
endif

set handclean = "-1"
if ($tmpdir != "") then
    echo " "
    echo "The default is auto-cleanup of your temp directory.  You may choose"
    echo " to clean up by hand if you want fastest possible access to sum.rec,"
    echo " or if you want access to $matfile."
    while ($handclean == "-1")
	echo -n "Do you want to clean up by hand (enter y or n)? "
	set ifhand = $<
	if ($ifhand == "y" || $ifhand == "Y") set handclean = "1"
	if ($ifhand == "n" || $ifhand == "N") set handclean = "0"
    end
    echo " "
    if ($handclean == "1") then
	set sumname = $tmpdir/sum.rec
	if (! -e sum.rec) ln -s $sumname .
	echo "There should now be a link to sum.rec in the current directory."
	echo " $matfile and the real sum.rec will be left in $tmpdir"
	echo "You are responsible for deleting $tmpdir and its contents"
	echo " when you are done with these files."
    else
	echo "Your temporary directory is $tmpdir"
	echo "It and its contents will be deleted when combine.com finishes successfully".
    endif
endif

echo " "
echo "The number of patches for PATCHCRAWL3D is $npatchx in X, $npatchz in Y, and $npatchy in Z"
echo "   (Y and Z are not flipped on the PATCHCRAWL3D command line)"

if (-e combine.com) \mv -f combine.com combine.com~
if (-e $matchshift) \mv -f $matchshift $matchshift~
if (-e $matchmod) \mv -f $matchmod $matchmod~
if (-e $matchvol1) \mv -f $matchvol1 $matchvol1~
if (-e $matchvol2) \mv -f $matchvol2 $matchvol2~
if (-e $warpvol) \mv -f $warpvol $warpvol~
if (-e $patchcorr) \mv -f $patchcorr $patchcorr~
if (-e $matchorwarp) \mv -f $matchorwarp $matchorwarp~
if (-e $volcombine) \mv -f $volcombine $volcombine~

sed -e s/$from_srcname/$fromname/g\
    -e s/$to_srcname/$toname/g\
    -e "/$corrtext1/s/.*	/$corrlist1	/g"\
    -e "/$corrtext2/s/.*	/$corrlist2	/g"\
    -e "/X-axis tilt/s/.*	/$xaxisa[2],$xaxisb[2]	/g"\
	<$srcdir/$matchmod | cat >$matchmod

sed -e s/$from_srcname/$fromname/g\
    -e s/$to_srcname/$toname/g\
    -e "/$corrtext1/s/.*	/$corrlist1	/g"\
    -e "/$corrtext2/s/.*	/$corrlist2	/g"\
    -e "/X-axis tilt/s/.*	/$xaxisa[2],$xaxisb[2]	/g"\
    -e "/$surftext/s/.*	/$modsurf	/g"\
    -e "/matchshifts.*64 32 64/s/64 32 64/$MATCHSHIFTXZ $msy $MATCHSHIFTXZ/"\
	<$srcdir/$matchshift | cat >$matchshift

sed -e s/$from_srcname/$fromname/g\
    -e s/$to_srcname/$toname/g\
    -e "s/$tmp_srcname/$sedtmpdir/g"\
    -e s/$matfile/$sedmatfile/g\
    -e "/NX,NY,NZ of output/s/.*	/$size	/g"\
    -e "/savework-file/s//$backupsed/g"\
	<$srcdir/$matchvol1 | cat >$matchvol1

sed -e s/$from_srcname/$fromname/g\
    -e s/$to_srcname/$toname/g\
    -e "s/$tmp_srcname/$sedtmpdir/g"\
    -e s/$matfile/$sedmatfile/g\
    -e "/NX,NY,NZ of output/s/.*	/$size	/g"\
	<$srcdir/$matchvol2 | cat >$matchvol2

sed -e s/$from_srcname/$fromname/g\
    -e s/$to_srcname/$toname/g\
    -e "s/$tmp_srcname/$sedtmpdir/g"\
    -e s/$matfile/$sedmatfile/g\
    -e "/NX,NY,NZ of output/s/.*	/$size	/g"\
	<$srcdir/$warpvol | cat >$warpvol

sed -e "/patchcrawl3d *[0-9]/s/3d[ 0-9]*/3d  $PATCHXY[$indpatch] $PATCHZ[$indpatch] $PATCHXY[$indpatch]   $npatchx $npatchz $npatchy   $patchxl $patchxu   $patchzl $patchzu   $patchyl $patchyu /g"\
    -e s/$from_srcname/$fromname/g\
    -e s/$to_srcname/$toname/g\
    -e s/$matfile/$sedmatfile/g\
    -e s/36,36,36,36/$xyborder,$xyborder,$xyborder,$xyborder/g\
    -e "/boundary_model/s//$modelin/"\
	<$srcdir/$patchcorr | cat >$patchcorr

sed -e s/$from_srcname/$fromname/g\
    -e s/$to_srcname/$toname/g\
    -e "s/$tmp_srcname/$sedtmpdir/g"\
    -e s/$matfile/$sedmatfile/g\
    -e "/$modeltext/s/$modeltext/matchorwarp -modelfile $modelin -size/"\
    -e "/$tempdirarg/s///"\
	<$srcdir/$matchorwarp | cat >$matchorwarp

sed -e s/$from_srcname/$fromname/g\
    -e s/$to_srcname/$toname/g\
    -e "s/$tmp_srcname/$sedtmpdir/g"\
    -e s/$matfile/$sedmatfile/g\
    -e "/savework-file/s//$backupsed/g"\
    	<$srcdir/$volcombine | cat >$volcombine

sed -e "s/$tmp_srcname/$sedtmpdir/g"\
    -e "/mkdir/s/.*if/$ifmkdir/"\
    -e "/$comment/s/"'^[\$#]*\([ve]\)/#\$\1/g'\
    -e "/$uncomment/s/"'^[\$#]*\([ve]\)/\$\1/g'\
	<$srcdir/combine.com | cat >combine.com


set ranlist = `tomopieces $recfile $MAXMEMORY $TAPERPADXZ $TAPERPADY $MINOVERLAP`

if ($status) then
    echo "Error running tomopieces - does $recfile exist?"
    exit 1
endif

cat <<EOF | cat >> $volcombine
\$touch prevent-error
\$\\rm prevent-err* ${tmppath}*.mat~ ${tmppath}mat.fft* ${tmppath}rec.fft* ${tmppath}sum.fft* $sumname* ${tmppath}sum[1-9]*.rec*
#
\$echo STATUS: RUNNING FILLTOMO TO FILL IN GRAY AREAS IN THE .MAT FILE
\$echo 
#
\$filltomo
$tmpmatfile
$recfile
$origfile
$invfile
/
EOF
@ npiecex = $ranlist[1]
shift ranlist
@ npiecez = $ranlist[1]
shift ranlist

@ npiecetot = $npiecex * $npiecez
@ sumnum = 0
@ znum = 0
while ($znum < $npiecez)
    @ znum++
    @ xnum = 0
    while ($xnum < $npiecex)
	@ xnum++
	@ sumnum++
	cat <<EOCAT | cat >> $volcombine
#
\$echo STATUS: EXTRACTING AND COMBINING PIECE  $sumnum  of $npiecetot
\$echo
#
\$taperoutvol
$recfile
${tmppath}rec.st
$ranlist[1]
$TAPERPADXZ,$TAPERPADY,$TAPERPADXZ
\$clip fft -3d ${tmppath}rec.st ${tmppath}rec.fft
\$\\rm ${tmppath}rec.st
\$taperoutvol
$tmpmatfile
${tmppath}mat.st
$ranlist[1]
$TAPERPADXZ,$TAPERPADY,$TAPERPADXZ
\$clip fft -3d ${tmppath}mat.st ${tmppath}mat.fft
\$\\rm ${tmppath}mat.st
\$combinefft
${tmppath}rec.fft
${tmppath}mat.fft

$invfile
$atlt
$btlt
\$\\rm ${tmppath}rec.fft
\$clip fft -3d -m $mode ${tmppath}mat.fft ${tmppath}sum$sumnum.rec
\$\\rm ${tmppath}mat.fft
EOCAT
	shift ranlist
    end
end

cat <<EOCAT | cat >> $volcombine
#
\$echo STATUS: REASSEMBLING PIECES
\$echo
#
\$assemblevol
$sumname
$npiecex,1,$npiecez
EOCAT
@ xnum = 0
while ($xnum < $npiecex)
    echo $ranlist[1] | cat >> $volcombine
    shift ranlist
    @ xnum++
end
echo $ranlist[1] | cat >> $volcombine
shift ranlist
@ znum = 0
while ($znum < $npiecez)
    echo $ranlist[1] | cat >> $volcombine
    shift ranlist
    @ znum++
end
    
@ sumnum = 0
while ($sumnum < $npiecex * $npiecez)
  @ sumnum++
  echo ${tmppath}sum$sumnum.rec | cat >> $volcombine
end
cat <<EOCAT | cat >> $volcombine
#
\$echo 
\$echo STATUS: RUNNING FILLTOMO ON FINAL VOLUME
\$echo 
#
\$\\rm ${tmppath}sum[1-9]*.rec
\$filltomo
$sumname
$recfile
$origfile
$invfile
/
EOCAT


if ($handclean == "0") then
cat <<EOCAT | cat >> $volcombine
\$\\rm -r $tmpdir
EOCAT
endif

echo '$'"if (-e $backupname) $backupname" | cat >> $volcombine
