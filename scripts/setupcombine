#! /bin/csh -f
# SCRIPT TO COPY AND MODIFY COMBINE.COM AND ASSOCIATED COM FILES

set XYBORDERS = (24 36 54 68 80)    # border sizes per increment of minimum
set BORDERINC = 1000                # dimension
set PATCHXY = (64 80 100)
set PATCHZ = (32 40 50)
set DELPATCHXY = 100
set NZPATCH3 = 75      # Thickness at which to do 3 patches in Z
set NZPATCH4 = 150     # Thickness at which to do 4 patches in Z
set MAXPIXELS = 20000  # KPixels for maximum FFT - check FFT3D if increase
set TAPERPADXZ = 8       # Size of taper/pad for 3D ffts in X and Z
set TAPERPADY = 4       # Size of taper/pad for 3D ffts in Y
set MAXPIECEY = 1       # Maximum pieces in Y
set MINOVERLAP = 10     # Minimum overlap between pieces
set MATCHSHIFTXZ = 100   # size of 3-D box in X and Z for matchshifts
set MATCHSHIFTY  = (40 60 76 90)      # Y sizes per increment of Y dimension
set MATCHSHIFTINC = 100

# Set this to "clip fft" if MAXPIXELS is increased near to value in ftbuf.inc
set FFT3D = "fftrans -q"   # Command to get get fft - assumes -3d argument

set to_srcname = "g5a"
set from_srcname = "g5b"
set tmp_srcname = "g5tmpdir"
set backupname = "./savework"
set backupsed = ".\/savework"

set matchshift = solvematch.com
set matchvol1 = matchvol1.com
set patchcorr = patchcorr.com
set matchorwarp = matchorwarp.com
set warpvol = warpvol.com
set matchvol2 = matchvol2.com
set volcombine = volcombine.com


#  $Author$
#
#  $Date$
#
#  $Revision$
# Log at end of file
#

if ($?IMOD_DIR) then
    set srcdir = "$IMOD_DIR/com"
    set path = ($IMOD_DIR/bin $path)
else
    echo "Environment variable IMOD_DIR must be set to the top IMOD directory"
    exit 1
endif


if (! -d $srcdir) then
    echo "Source directory for command file, $srcdir, not found."
    echo "Edit $0 if necessary to set the source directory correctly"
    exit 1
endif

set noglob

echo " "
echo "This program sets up the file combine.com for combining two tomograms."
echo "There are no command line arguments."
echo "Just answer each of the questions in turn."
echo "To interrupt, type Ctrl-C then Return"
echo " "

echo -n "Enter root name of data sets (omitting a or b and extension): "
set rootname = $<
set tolet = "z"
while ($tolet != "a" && $tolet != "b")
    echo -n "Enter letter of tomogram being matched TO (a or b): "
    set tolet = $<
    if ($tolet == "a") then
        set fromlet = "b"
    else if ($tolet == "b") then
        set fromlet = "a"
    endif
end
set toname = $rootname$tolet
set fromname = $rootname$fromlet
set tilta = "tilt$tolet.com"
set tiltb = "tilt$fromlet.com"

if ((-e tilta.com) && (-e tiltb.com)) then
    # This ugliness is for Cygwin Windows, with nobinmode not set
    set xaxisa = `grep -i xaxistilt $tilta | sed '/.*/s/\(^.*[0-9\.]*\).*$/\1/'`
    set xaxisb = `grep -i xaxistilt $tiltb | sed '/.*/s/\(^.*[0-9\.]*\).*$/\1/'`
    if ("$xaxisa" == "") set xaxisa = "xaxistilt 0."
    if ("$xaxisb" == "") set xaxisb = "xaxistilt 0."
else
    echo " "
    echo2 "WARNING: CANNOT FIND tilta.com or tiltb.com; CANNOT SET X-AXIS TILTS CORRECTLY"
    set xaxisa = "xaxistilt 0."
    set xaxisb = "xaxistilt 0."
endif

set xaxisa = ($xaxisa)
set xaxisb = ($xaxisb)

set recfile = $toname.rec
set matfile = $fromname.mat
set origfile = $fromname.rec
set invfile = "inverse.xf"
set atlt = $toname.tlt
set btlt = $fromname.tlt
set mode = 1

if (-e $recfile) then
    set size = `header $recfile | sed -n '/rows, sections/p'| awk '{print $7, $8, $9}'`
    set modeline = `header $recfile | sed -n '/Map mode/p'`
    if ($modeline[4] == 2) set mode = 2
else
    set size = `echo "1024 60 1024"`
    echo " "
    echo2 "WARNING: $recfile NOT FOUND; SETTING SIZE TO $size FOR TEST PURPOSES"
endif

echo ""
echo "Specify the correspondence between fiducial points in the two tilt alignments."
echo "Enter a list of the points in tilt series $tolet for which you"
echo "are sure of the corresponding point in tilt series $fromlet"
echo " (ranges may be entered)."
echo "Or just Return if the points are in one-to-one correspondence"
echo "   or if there are no fiducial points"
#
# Need to strip spaces out of these lists
#
set corrlistin = "$<"
set corrlistin = ($corrlistin)
set corrlist1 = ""
while ($#corrlistin > 0)
    set corrlist1 = ${corrlist1}$corrlistin[1]
    shift corrlistin
end

set corrlist2 = "\/"
if ($corrlist1 != "") then
    echo "Enter a list of the corresponding points in tilt series $fromlet"
    set corrlistin = "$<"
    set corrlistin = ($corrlistin)
    set corrlist2 = ""
    while ($#corrlistin > 0)
        set corrlist2 = ${corrlist2}$corrlistin[1]
        shift corrlistin
    end
else
    set corrlist1 = "\/"
endif


set modsurf = "z"
while ($modsurf != "0" && $modsurf != "1" && $modsurf != "-1" && $modsurf != "2" && $modsurf != "-2")
echo ""
echo "Enter -2 to use just models of corresponding points ($toname.matmod and"
echo " $fromname.matmod) to specify initial registration between tomograms;"
echo " or 0 to use models of corresponding points along with relative fiducial"
echo "    coordinates (for old fiducial coordinates); otherwise enter:"
echo "   1 if fiducials are on only one surface and tomograms are NOT inverted,"
echo "  -1 if fiducials are on only one surface and tomograms are inverted"
echo "           relative to each other, or"
echo -n "   2 if there are fiducials on both surfaces: "
set modsurf = $<
end

@ nx = $size[1]
@ ny = $size[3]
@ nz = $size[2]

set ifok = "0"
while ($ifok == "0")
    echo ""
    echo "Enter s for small patches ($PATCHXY[1] x $PATCHZ[1] x $PATCHXY[1]), m for medium patches ($PATCHXY[2] x $PATCHZ[2] x $PATCHXY[2]),"
    echo -n " or l for large patches ($PATCHXY[3] x $PATCHZ[3] x $PATCHXY[3]) (Return for m): "
    set patchin = $<
    set ifok = "1"
    if ($patchin == "") set patchin = "M"
    if ($patchin == "s" || $patchin == "S") then
	set indpatch = 1
    else if ($patchin == "m" || $patchin == "M") then
	set indpatch = 2
    else if ($patchin == "l" || $patchin == "L") then
	set indpatch = 3
    else
	set ifok = "0"
    endif
end

@ minsize = $nx
if ($ny < $nx) @ minsize = $ny
@ borderindex = 1 + $minsize / $BORDERINC
if ($borderindex > $#XYBORDERS) @ borderindex = $#XYBORDERS
set xyborder = $XYBORDERS[$borderindex]

echo ""
echo "Now specify the limits of the volume from which patches will be"
echo "      extracted by patchcrawl3d."
echo "The default upper limits for X and Y are based on a border of $xyborder pixels."
set ifok = "0"
while ($ifok == "0")
    @ patchxl = $xyborder
    @ patchxu = $nx - $xyborder
    echo -n "Lower X (left) limit of area (Return for $patchxl): "
    set patchin = $<
    if ($patchin != "") @ patchxl = $patchin
    echo -n "Upper X (right) limit of area (Return for $patchxu): "
    set patchin = $<
    if ($patchin != "") @ patchxu = $patchin
    if ($patchxl < 0 ) then
	echo "Lower limit out of bounds, try again"
    else if ($patchxu > $nx) then
	echo "Upper limit out of bounds, try again"
    else if ($patchxl >= $patchxu) then
	echo "Lower limit greater than upper limit, try again"
    else
	set ifok = "1"
    endif
end
set ifok = "0"
while ($ifok == "0")
    @ patchyl = $xyborder
    @ patchyu = $ny - $xyborder
    echo -n "Lower Y (bottom) limit of area in flipped tomogram (Return for $patchyl): "
    set patchin = $<
    if ($patchin != "") @ patchyl = $patchin
    echo -n "Upper Y (top) limit of area in flipped tomogram (Return for $patchyu): "
    set patchin = $<
    if ($patchin != "") @ patchyu = $patchin
    if ($patchyl < 0 ) then
	echo "Lower limit out of bounds, try again"
    else if ($patchyu > $ny) then
	echo "Upper limit out of bounds, try again"
    else if ($patchyl >= $patchyu) then
	echo "Lower limit greater than upper limit, try again"
    else
	set ifok = "1"
    endif
end
set ifok = "0"
while ($ifok == "0")
    set patchin = ""
    while ($patchin == "")
	echo -n "Lower Z limit of volume (bottom slice) in flipped tomogram: "
	set patchin = $<
	if ($patchin != "") then
	    @ patchzl = $patchin
	endif
    end

    set patchin = ""
    while ($patchin == "")
	echo -n "Upper Z limit of volume (top slice) in flipped tomogram: "
	set patchin = $<
	if ($patchin != "") then
	    @ patchzu = $patchin
	endif
    end
    if ($patchzl < 0 ) then
	echo "Lower limit out of bounds, try again"
    else if ($patchzu > $nz) then
	echo "Upper limit out of bounds, try again"
    else if ($patchzl >= $patchzu) then
	echo "Lower limit greater than upper limit, try again"
    else
	set ifok = "1"
    endif
end

# figure out a size in Y for matchshift block
@ msyindex = $nz / $MATCHSHIFTINC
if ($msyindex == 0) then
    @ msy = $MATCHSHIFTY[1]
    if ($msy > $nz) @ msy = $nz
else if ($msyindex >= $#MATCHSHIFTY) then
    @ msy = $MATCHSHIFTY[$#MATCHSHIFTY]
else
    @ deltay = $nz - $msyindex * $MATCHSHIFTINC
    @ msy1 = $MATCHSHIFTY[$msyindex]
    @ msyindex++
    @ msy2 = $MATCHSHIFTY[$msyindex]
    @ deltamsy = $msy2 - $msy1
    @ msy = $msy1 + ($deltay * $deltamsy ) / $MATCHSHIFTINC
endif

# Set the size in X and Z, not bigger than 1/4 of X dimension
@ msxz = $MATCHSHIFTXZ
if ($msxz > $nx / 4) @ msxz = $nx / 4

# Get patch model file

set modeltext = "gibberish"
echo "Enter name of model file with contours enclosing patches to use for fits,"
echo -n "   or Return to use all patches: "
set modelin = $<
if ($modelin != "") then
    set modeltext = "matchorwarp -size"
    if (! -e $modelin) then
	echo " "
	echo2 "WARNING: file $modelin does not yet exist."
    endif
endif

@ npatchx = ($patchxu + $DELPATCHXY / 2 - $patchxl) / $DELPATCHXY
@ npatchy = ($patchyu + $DELPATCHXY / 2 - $patchyl) / $DELPATCHXY

# set number of patches in Z based on criteria, but if patch thickness
# is greater than two-thirds of extent, do only one row of patches
@ npatchz = 2
if (($patchzu - $patchzl) >= $NZPATCH3) @ npatchz = 3
if (($patchzu - $patchzl) >= $NZPATCH4) @ npatchz = 4
if ($PATCHZ[$indpatch] > (2 * ($patchzu - $patchzl)) / 3) then
    @ npatchz = 1
    echo " "
    echo2 "WARNING: Only one layer of patches will be computed in Z"
endif

# If patch thickness is greater than extent cut it down
#
@ patchnz = $PATCHZ[$indpatch]
if ($patchnz > $patchzu + 1 - $patchzl) then
    @ patchnz = $patchzu + 1 - $patchzl
    echo " "
    echo2 "WARNING: Patch thickness set to $patchnz to fit within Z limits"
endif

# compute disk space needed before asking about temp directory
@ kpixel = ((($nx * $nz) / 100) * $ny) / 10
@ mbytes = ((6 * $kpixel) + ($kpixel / 2)) / 1000
@ lim1 = ((4 * $kpixel) + ($kpixel / 2) + (8 * $MAXPIXELS)) / 1000
if ($lim1 > $mbytes) @ mbytes = $lim1
@ lim1 = ((2 * $kpixel) + (10 * $MAXPIXELS)) / 1000
if ($lim1 > $mbytes) @ mbytes = $lim1

echo " "
echo "$mbytes MBytes of disk space will be needed for combining"

set ifok = "0"
while ($ifok == "0")
    echo "If you want to use a local temporary directory, enter the path name of a"
    echo " directory in which the temporary directory can be created (e.g., /usr/tmp)"
    echo -n " or Return for no temporary directory: "
    set tmproot = $<
    if ($tmproot == "") then
	set tmpdir = ""
	set tmppath = ""
	set ifmkdir = '#$if'
        set tempdirarg = " -tempdir "
	set tmpmatfile = $matfile
	set sedtmpdir = ""
	set sedmatfile = $matfile
        set sedtempkey = "gibberish"
	set ifok = "1"
    else
	if (! -d $tmproot) then
	    echo "$tmproot does not exist or is not a directory; try again"
	else if (! -w $tmproot) then
	    echo "You do not have permission to write in $tmproot; try again"
	else
	    set tmpdir = $tmproot/combine.$$
	    set tmppath = $tmpdir/
	    set ifmkdir = '$if'
	    set tempdirarg = "gibberish"
	    set tmpmatfile = $tmppath$matfile
	    set sedtmpdir = `echo $tmpdir | sed 's/\//\\\//g'`
	    set sedmatfile = $sedtmpdir\\/$matfile
            set sedtempkey = "TemporaryDir"
	    set ifok = "1"
	endif
    endif
end

set sumname = sum.rec

# If there is an existing link to sum.rec, remove it
if (-e sum.rec) then
    set testlink = `ls -l sum.rec | awk '{print $1}' | grep l`
    if ($testlink != "") \rm sum.rec
endif

set handclean = "-1"
if ($tmpdir != "") then
    echo " "
    echo "The default is auto-cleanup of your temp directory.  You may choose"
    echo " to clean up by hand if you want fastest possible access to sum.rec,"
    echo " or if you want access to $matfile."
    while ($handclean == "-1")
	echo -n "Do you want to clean up by hand (enter y or n)? "
	set ifhand = $<
	if ($ifhand == "y" || $ifhand == "Y") set handclean = "1"
	if ($ifhand == "n" || $ifhand == "N") set handclean = "0"
    end
    echo " "
    if ($handclean == "1") then
	set sumname = $tmpdir/sum.rec
	if (! -e sum.rec) ln -s $sumname .
	echo "There should now be a link to sum.rec in the current directory."
	echo " $matfile and the real sum.rec will be left in $tmpdir"
	echo "You are responsible for deleting $tmpdir and its contents"
	echo " when you are done with these files."
    else
	echo "Your temporary directory is $tmpdir"
	echo "It and its contents will be deleted when combine.com finishes successfully".
    endif
endif

echo " "
echo "The number of patches for PATCHCRAWL3D is $npatchx in X, $npatchz in Y, and $npatchy in Z"
echo "   (Y and Z are not flipped on the PATCHCRAWL3D command line)"

if (-e combine.com) \mv -f combine.com combine.com~
if (-e $matchshift) \mv -f $matchshift $matchshift~
if (-e $matchvol1) \mv -f $matchvol1 $matchvol1~
if (-e $matchvol2) \mv -f $matchvol2 $matchvol2~
if (-e $warpvol) \mv -f $warpvol $warpvol~
if (-e $patchcorr) \mv -f $patchcorr $patchcorr~
if (-e $matchorwarp) \mv -f $matchorwarp $matchorwarp~
if (-e $volcombine) \mv -f $volcombine $volcombine~


sed -e s/$from_srcname/$fromname/g\
    -e s/$to_srcname/$toname/g\
    -e "/^ACorrespondenceList/s/[ 	].*/	$corrlist1/"\
    -e "/^BCorrespondenceList/s/[ 	].*/	$corrlist2/"\
    -e "/^XAxisTilts/s/[ 	].*/	$xaxisa[2],$xaxisb[2]/"\
    -e "/^SurfacesOrUseModel/s/[ 	].*/	$modsurf/"\
    -e "/matchshifts.*64 32 64/s/64 32 64/$msxz $msy $msxz/"\
	<$srcdir/$matchshift | cat >$matchshift

sed -e s/$from_srcname/$fromname/g\
    -e s/$to_srcname/$toname/g\
    -e "s/$tmp_srcname/$sedtmpdir/g"\
    -e "/mkdir/s/.*if/$ifmkdir/"\
    -e s/$matfile/$sedmatfile/g\
    -e "/$sedtempkey/s/\#//"\
    -e "/OutputSizeXYZ/s/\//$size/g"\
    -e "/savework-file/s//$backupsed/g"\
	<$srcdir/$matchvol1 | cat >$matchvol1

sed -e s/$from_srcname/$fromname/g\
    -e s/$to_srcname/$toname/g\
    -e "s/$tmp_srcname/$sedtmpdir/g"\
    -e "/mkdir/s/.*if/$ifmkdir/"\
    -e s/$matfile/$sedmatfile/g\
    -e "/$sedtempkey/s/\#//"\
    -e "/OutputSizeXYZ/s/\//$size/g"\
	<$srcdir/$matchvol2 | cat >$matchvol2

sed -e s/$from_srcname/$fromname/g\
    -e s/$to_srcname/$toname/g\
    -e "s/$tmp_srcname/$sedtmpdir/g"\
    -e "/mkdir/s/.*if/$ifmkdir/"\
    -e s/$matfile/$sedmatfile/g\
    -e "/$sedtempkey/s/\#//"\
    -e "/OutputSizeXYZ/s/\//$size/g"\
	<$srcdir/$warpvol | cat >$warpvol

sed -e "/patchcrawl3d *[0-9]/s/3d[ 0-9]*/3d  $PATCHXY[$indpatch] $patchnz $PATCHXY[$indpatch]   $npatchx $npatchz $npatchy   $patchxl $patchxu   $patchzl $patchzu   $patchyl $patchyu /g"\
    -e s/$from_srcname/$fromname/g\
    -e s/$to_srcname/$toname/g\
    -e s/$matfile/$sedmatfile/g\
    -e s/36,36,36,36/$xyborder,$xyborder,$xyborder,$xyborder/g\
    -e "/boundary_model/s//$modelin/"\
	<$srcdir/$patchcorr | cat >$patchcorr

sed -e s/$from_srcname/$fromname/g\
    -e s/$to_srcname/$toname/g\
    -e "s/$tmp_srcname/$sedtmpdir/g"\
    -e "/mkdir/s/.*if/$ifmkdir/"\
    -e s/$matfile/$sedmatfile/g\
    -e "/$modeltext/s/$modeltext/matchorwarp -modelfile $modelin -size/"\
    -e "/$tempdirarg/s///"\
	<$srcdir/$matchorwarp | cat >$matchorwarp

sed -e s/$from_srcname/$fromname/g\
    -e s/$to_srcname/$toname/g\
    -e "s/$tmp_srcname/$sedtmpdir/g"\
    -e s/$matfile/$sedmatfile/g\
    -e "/savework-file/s//$backupsed/g"\
    	<$srcdir/$volcombine | cat >$volcombine

\cp $srcdir/combine.com .

@ megamax = $MAXPIXELS
@ megamax /= 1000
set ranlist = `tomopieces -tomo $recfile -mega $megamax -xpad $TAPERPADXZ -ypad $TAPERPADY -zpad $TAPERPADXZ -min $MINOVERLAP -ymax $MAXPIECEY | sed '/[[:cntrl:]]/s///g'`

if ($status) then
    echo $ranlist
    echo "ERROR running tomopieces - does $recfile exist?"
    exit 1
endif


cat <<EOF | cat >> $volcombine
\$touch prevent-error
\$\\rm prevent-err* ${tmppath}*.mat~ ${tmppath}mat.fft* ${tmppath}rec.fft* ${tmppath}sum.fft* $sumname* ${tmppath}sum[1-9]*.rec*
#
\$echo STATUS: RUNNING FILLTOMO TO FILL IN GRAY AREAS IN THE .MAT FILE
\$echo 
#
\$filltomo
$tmpmatfile
$recfile
$origfile
$invfile
/
EOF

@ npiecex = $ranlist[1]
shift ranlist
@ npiecey = $ranlist[1]
shift ranlist
@ npiecez = $ranlist[1]
shift ranlist

@ npiecetot = $npiecex * $npiecey * $npiecez
@ sumnum = 0
@ znum = 0
while ($znum < $npiecez)
    @ znum++
    @ ynum = 0
    while ($ynum < $npiecey)
        @ ynum++
        @ xnum = 0
        while ($xnum < $npiecex)
            @ xnum++
            @ sumnum++
            cat <<EOCAT | cat >> $volcombine
#
\$dopiece${sumnum}:
\$echo STATUS: EXTRACTING AND COMBINING PIECE  $sumnum  of $npiecetot
\$echo
#
\$taperoutvol
$recfile
${tmppath}rec.st
$ranlist[1]
$TAPERPADXZ,$TAPERPADY,$TAPERPADXZ
\$$FFT3D -3d ${tmppath}rec.st ${tmppath}rec.fft
\$\\rm ${tmppath}rec.st
\$taperoutvol
$tmpmatfile
${tmppath}mat.st
$ranlist[1]
$TAPERPADXZ,$TAPERPADY,$TAPERPADXZ
\$$FFT3D -3d ${tmppath}mat.st ${tmppath}mat.fft
\$\\rm ${tmppath}mat.st
\$combinefft -StandardInput
AInputFFT	${tmppath}rec.fft
BInputFFT	${tmppath}mat.fft
InverseTransformFile	$invfile
ATiltFile	$atlt
BTiltFile	$btlt
ReductionFraction	\$combinefft_reduce
\$\\rm ${tmppath}rec.fft
\$$FFT3D -3d -m $mode ${tmppath}mat.fft ${tmppath}sum$sumnum.rec
\$\\rm ${tmppath}mat.fft
EOCAT
            shift ranlist
        end
    end
end

cat <<EOCAT | cat >> $volcombine
#
\$echo STATUS: REASSEMBLING PIECES
\$echo
#
\$assemblevol
$sumname
$npiecex,$npiecey,$npiecez
EOCAT

@ xnum = 0
while ($xnum < $npiecex)
    echo $ranlist[1] | cat >> $volcombine
    shift ranlist
    @ xnum++
end

@ ynum = 0
while ($ynum < $npiecey)
    echo $ranlist[1] | cat >> $volcombine
    shift ranlist
    @ ynum++
end

@ znum = 0
while ($znum < $npiecez)
    echo $ranlist[1] | cat >> $volcombine
    shift ranlist
    @ znum++
end
    
@ sumnum = 0
while ($sumnum < $npiecetot)
  @ sumnum++
  echo ${tmppath}sum$sumnum.rec | cat >> $volcombine
end
cat <<EOCAT | cat >> $volcombine
#
\$echo 
\$echo STATUS: RUNNING FILLTOMO ON FINAL VOLUME
\$echo 
#
\$\\rm ${tmppath}sum[1-9]*.rec
\$filltomo
$sumname
$recfile
$origfile
$invfile
/
EOCAT


if ($handclean == "0") then
cat <<EOCAT | cat >> $volcombine
\$\\rm -r $tmpdir
EOCAT
endif

echo '$'"if (-e $backupname) $backupname" | cat >> $volcombine

#
#  $Log$
#  Revision 3.27  2004/10/27 22:25:01  mast
#  Switched to using fftrans
#
#  Revision 3.26  2004/08/12 17:42:02  mast
#  Put back right version for 3.4
#
#  Revision 3.24  2004/07/22 18:17:12  mast
#  Change to better sed command for stripping Ctrl M
#
#  Revision 3.23  2004/07/13 18:15:40  mast
#  Changed to PIP format for combinefft with an option variable, added a
#  label for each piece for a goto at the start to jump to
#
#  Revision 3.22  2004/06/20 15:32:30  mast
#  Restore new solvematch and cut patch thickness to fit in limits
#
#  Revision 3.20  2004/06/14 19:29:10  mast
#  Changed to handle general 3D output of tomopieces but constrained to
#  one layer in Y
#
#  Revision 3.19  2004/06/10 22:46:08  mast
#  Changes for new solvematch command file
#
#  Revision 3.18  2004/04/27 14:55:11  mast
#  Removed warning for no xaxistilt line, it is fine if it is not there
#
#  Revision 3.17  2004/04/24 03:37:36  mast
#  Added check for xaxistilt lines and warning if they are not there
#
#  Revision 3.16  2004/01/13 20:02:06  mast
#  ($<) does not work in true csh on SGI, so make wordlist in two steps
#
#  Revision 3.15  2003/10/24 02:14:00  mast
#  source settmpdir to get tmpdir, better for Windows
#
#  Revision 3.14  2003/10/16 20:43:06  mast
#  Make matchshift patches bigger in X and Y to reduce check volume failures
#
#  Revision 3.13  2003/10/11 00:05:52  mast
#  Changes for new input methods for matchvol/warpvol
#
#  Revision 3.12  2003/05/23 00:38:25  mast
#  Move creation of temporary directory into sub-command files
#
#  Revision 3.11  2003/05/20 21:39:47  mast
#  Strip spaces from corresponding fiducial list
#
#  Revision 3.10  2003/05/19 22:50:25  mast
#  *** empty log message ***
#
#  Revision 3.9  2003/05/13 22:00:48  mast
#  Fix getting x axis tilt for Windows/Cygwin
#
#  Revision 3.8  2003/05/12 23:21:11  mast
#  remove test for piping
#
#  Revision 3.7  2003/05/12 18:53:24  mast
#  Pipe command files through cat for dos line endings in cygwin
#
#  Revision 3.6  2002/11/04 20:38:02  mast
#  Made WARNINGS go to standard error with echo2
#
#  Revision 3.5  2002/10/23 15:36:50  mast
#  Made it set up for one patch in Z if patch thickness is two-thirds of the
#  spacing between the limits in Z.  Also made warnings start on a new line
#  and all start with WARNING:
#
#  Revision 3.4  2002/08/03 00:36:02  mast
#  Added a blank line before last STATUS in volcombine.com
#
#  Revision 3.3  2002/07/27 23:57:02  mast
#  Change volcombine STATUS line to say piece n of m
#
#  Revision 3.2  2002/07/21 19:33:30  mast
#  Made default borders for patchcorr be based upon image size, and also
#  made thickness passed to Matchshifts bigger and based on image size
#
#  Revision 3.1  2002/06/19 16:06:29  mast
#  Conversion to multiple command files
#
#  Revision 3.0  2001/11/29 18:11:11  rickg
#  *** empty log message ***
#
#  Revision 1.2  2001/11/28 23:23:55  mast
#  Minor changes to accomodate changing from $! to # in command files.
#

