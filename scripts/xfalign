#! /bin/csh -f

#  $Author$
#
#  $Date$
#
#  $Revision$
#
#  $Log$

set tmpdir = /usr/tmp

set xcfilter = "0.01,0.05,0,0.25"

if ($#argv < 2) then
usage:
	echo "Usage: xfalign options input_file output_transform_file"
	echo "input_file: an image stack, or a text file with a list of sections or files"
	echo "options: "
	echo " -si[ze] X,Y              -  size to extract from image"
	echo " -o[ffset] dX,dY          -  center offset to subarea"
	echo " -f[ilter] s1,s2,r1,r2    -  Sigmas and Radii for prefilter"
	echo " -red[uce] n              -  # of times to reduce by 2 (default 1)"
	echo " -sk[ip] n1,n2,n3...      -  list of sections to skip (ranges OK)"
	echo " -m[att] f                -  fraction of image to omit at edges, or # of pixels"
	echo " -pa[rams] n              -  0 for formal params, or # of semi-natural params"
	echo " -b[ilinear]              -  to use bilinear interpolation"
	echo " -ref reference_file      -  to align stack to reference"
	echo " -pr[excorr]              -  to do initial cross-correlation alignment"
	echo " -x[cfilter] s1,s2,r1,r2  -  Sigmas and Radii for filter used in initial"
	echo "                               cross-correlation (default $xcfilter)"
	echo " -i[nitial] prexf_file    -  start with initial F alignments from file"
	exit 1
endif
if ($?IMOD_DIR) set path = ($IMOD_DIR/bin $path)

set pname      = $0
set com        = $pname:t
set prepfile   = $tmpdir/$com.prep.$$
set runenhance = $tmpdir/$com.enhance.$$
set runsearch  = $tmpdir/$com.search.$$
set tmpxf      = $tmpdir/$com.xf.$$
set tmppic     = $tmpdir/$com.pic.$$
set tmpprp     = $tmpdir/$com.prp.$$
set tmplprp    = $tmpdir/$com.lprp.$$
set refpic     = "0"
set ifskip     = "0"
set seclist    = $tmpdir/$com.secs.$$
set prexcorr   = "0"
set prexffile  = ""
set noglob
onintr clean

#
# Sections will be extracted one by one from the input stack using NEWSTACK
# NEWSIZE, NEWMODE, and NEWCEN control image extraction as follows:
#

# set NEWSIZE to a new x and y image size (e.g. "x,y") or leave as "/" for
# same size as input
# set by -size option
set NEWSIZE = "/"
#
# set NEWMODE to a new data mode, or leave as "/" for same mode as input
set NEWMODE = "/"
#
# set NEWCEN to a relative center offset if using a new image size
# set by -offset option
set NEWCEN = "0,0"
#
# Sections can then be prepared for alignment using the program ENHANCE
# Set FILTERPARAM to the "sigma1, sigma2, radius1, radius2" values required
# by ENHANCE (the same parameters used in VIEWFILT) or leave as "NONE" to
# omit filtering
# set by -filter option.
set FILTERPARAM = "NONE"
#

#
# Now specify the parameters to XFSIMPLEX.  Default values are in []
# Set tolerances in difference/distance measure and in transformation
# parameters for terminating final minimization [.0005 and .02, or .001 and
# .04 for images no larger than 128 by 128], tolerances for terminating
# initial search, or 0,0 to have only the final search [.005 and .2],
# factor to apply to basic step sizes to get initial step size [2], and
# 1 or 2 for trace, or 0 for no trace [0]
set TOLERANCES = ",,,,,,"
#
# Set NPARAM to 0 search for the six formal transformation parameters, or set
# it to the number of semi-natural parameters to vary [0]
# set by -params option
set NPARAM = "0"
#
# Set FRACMATT to the fraction of the image to ignore at each edge [0.05]
# set by -matt option
set FRACMATT = ","
#
# Set RANGEMEAN to 0 or 1 to float images to have same range or same mean,
# respectively [1]
set RANGEMEAN = ","
#
# Set NREDUCE to the # of times to reduce images by factor of 2 in x and y [1]
# set by -reduce option
set NREDUCE = "1"
#
# set DIFFDIST to 0 to use the difference between images as a measure of the
# match between images, or 1 to use the sum of distances between points in the
# images with corresponding intensities. [0]
set DIFFDIST = "0"
#
# If you select the difference measure, you just need to set IFBILINEAR to 1
# to use bilinear interpolation to assess image fit, or 0 not to [0]
# set by -bilinear option
set IFBILINEAR = "0"
#
# If instead you use the distance measure, there is no bilinear option, but
# you have 5 more parameters to select.
# Set NREDUNDANT to the distance in pixels to search from a "comparison point"
# to eliminate redundant points with similar densities.  [Default is 0 for
# images less than 240*180pixels after reduction by 2 (if any), 1 for images
# between 240*180 and 480*360, and, 2 for larger images]
set NREDUNDANT = ","
#
# Set RADIUS to the maximum distance in pixels to search from a comparison
# point for points in the other image with matching densities.  [Default is 4
# if images are reduced by 2, or 5 if they are not]
set RADIUS = ","
#
# Set MATCHDIFF to the maximum density difference constituting a match [0.05]
set MATCHDIFF = ","
#
# Set NPCRANGES to the # of ranges of densities to make comparisons with [2]
set NPCRANGES = ","
#
# Set PCRANGES to the lower and upper percentiles for those ranges.  [Default
# is 0,8,92,100 for images of 320*240 pixels or smaller (after reductions
# by 2, if any), and the ranges scale linearly down to 0,5,95,100 for images
# of 640*480 pixels or larger].
set PCRANGES = ",,,,"
#
#
# Here is the subroutine to prep a file.  You can add any desired functions
# here.  The image is in TMP.PIC upon entering the subroutine, and must be in
# TMP.PRP upon exiting from it.  You can put operations before and/or after
# the runenhance or replace the runenhance entirely.  To run a program that
# needs input other than from the command line, imitate the <<EOF style used
# below.
#
cat >! $prepfile <<EOCAT
$runenhance
EOCAT
# ----------------------------------------------------------------------
#                      YOU ARE DONE SETTING DEFAULT PARAMETERS
# ----------------------------------------------------------------------

# command line options
while($#argv > 2)
	switch($argv[1])
		case -si*:
			shift
			set NEWSIZE = $argv[1]
			breaksw

#		case -mode:
#			shift
#			set NEWMODE = $argv[1]
#			breaksw

		case -o*:
			shift
			set NEWCEN = $argv[1]
			breaksw

		case -f*:
			shift
			set FILTERPARAM = $argv[1]
			breaksw

		case -red*:
			shift
			set NREDUCE = $argv[1]
			breaksw

		case -sk*:
			shift
			set ifskip = "1"
			set words = (`echo $argv[1]| sed '/,/s// /g'`)
			breaksw

		case -m*:
			shift
			set FRACMATT = $argv[1]
			breaksw

		case -pa*:
			shift
			set NPARAM = $argv[1]
			breaksw

		case -b*:
			set IFBILINEAR = "1"
			breaksw

		case -ref*:
			shift
			set refpic = "1"
			set reffile = $argv[1]
			breaksw

		case -pr*:
			set prexcorr = "1"
			breaksw

		case -x*:
			shift
			set xcfilter = $argv[1]
			breaksw

		case -i*:
			shift
			set prexffile = $argv[1]
			breaksw

		default:
			echo Illegal option $argv[1]
			goto usage
	endsw
	shift
end

if ($prexcorr == "1" && $refpic == "1") then
    echo "You cannot use initial cross-correlation with alignment to one reference"
    exit 1
endif

if ($prexcorr == "1" && $prexffile != "") then
    echo "You cannot use initial cross-correlation with initial transforms"
    exit 1
endif

# input_file is either an MRC file or a filesectlist
# filesectlist format:
# Put either the MRC stack name on the first line then the
# successive section numbers (one per line), or a zero (0) on the first
# line and the successive file names, one per line.

set ftype = `file $argv[1]`

if ($ftype[2] == "ascii") then
	set filesectlist = $argv[1]
	if ($prexcorr == "1") then
	    echo "You cannot use initial cross-correlation with file lists"
	    exit 1
	endif
else
    @ numsec =  `header $argv[1] | sed -n '/rows, sections/p'| awk '{print $9}'`
    echo $argv[1] >! $seclist
    @ secnum = 0
    while ($secnum < $numsec)
	echo $secnum >> $seclist
	@ secnum++
    end
    set filesectlist = $seclist
endif


# Set XFLISTFILE to the name of the file to receive the list of F transforms
set XFLISTFILE = $argv[2]

# Set up the initial cross-correlation
#
if ($prexcorr == "1") then
    set preroot = $XFLISTFILE:r
    set prexffile = $preroot.xcxf
    if ($xcfilter == "NONE" || $xcfilter == "none") set xcfilter = "0.,0.,0.,0."
echo "RUNNING TILTXCORR FOR INITIAL CROSS-CORRELATION ALIGNMENTS"
tiltxcorr <<EOF
$argv[1]

$prexffile
1
0,0
0
$xcfilter
0
/
/
/
/
EOF
echo "INITIAL CROSS-CORRELATION ALIGNMENT TRANSFORMS WRITTEN TO $prexffile"
endif    

set tmpxfin = ""
if ($prexffile != "") set tmpxfin = $tmpdir/$com.xfin.$$

#
# set up the file to enhance or just rename tmp.pic
# 
if ( ($FILTERPARAM  == "0.,0.,0.,0.")  ||  ($FILTERPARAM == "NONE") ) then
   echo "mv -f $tmppic $tmpprp" >! $runenhance
else
   cat >! $runenhance <<EOCAT
enhance $tmppic $tmpprp > /dev/null <<EOF
$FILTERPARAM
1
EOF
EOCAT
endif
chmod +x $runenhance $prepfile
#
#     Initialize xflist file
#
if (-e $XFLISTFILE) \mv -f $XFLISTFILE $XFLISTFILE~
if ($refpic == "0") echo '   1.0000000   0.0000000   0.0000000   1.0000000       0.000       0.000' >! $XFLISTFILE
#
#      Set up file to run xfsimplex with the given parameters
#
cat >! $runsearch <<EOCAT
xfsimplex > /dev/null <<EOF
$tmplprp
$tmpprp
$tmpxf
$tmpxfin
$TOLERANCES
$NPARAM
$FRACMATT
$RANGEMEAN
$NREDUCE
$DIFFDIST
EOCAT

if ($DIFFDIST == "0") then
cat >> $runsearch <<EOCAT
$IFBILINEAR
EOF
EOCAT
else
cat >> $runsearch <<EOCAT
$NREDUNDANT
$RADIUS
$MATCHDIFF
$NPCRANGES
$PCRANGES
EOF
EOCAT
endif
chmod +x $runsearch

#
#	parse the skip list
#
echo "TRANSFORMS FOUND BY XFSIMPLEX:"
if ($ifskip == "1") then
    set skips = ""
    while ($#words > 0)
	switch ($words[1])
	    case *-*:
		set startend = (`echo $words[1]| sed '/-/s// /g'`)
		@ start = $startend[1]
		@ end = $startend[$#startend]
		@ num = $start
		while ($num <= $end)
		    set skips = ($skips $num)
		    @ num = $num + 1
		end
		breaksw
	    default:	
		set skips = ($skips $words[1])
		breaksw
	endsw
	shift words
    end
endif

#
# 	Get the file and section list as a wordlist
#
set filesect = `cat $filesectlist`
#
#	 first line is either a stack name or 0 for separate files
#
set nameorzero = $filesect[1]
shift filesect
#
# 	next should be specification for the first file/section
#
set firsttime = "0"

while ($#filesect != 0 )

    set docopy = "0"
#
#	If doing a reference file, set up to get from that file
#
    if ($refpic != "0" && $firsttime == "0") then
	set infile = $reffile
	set insect = "0"
    else	
	set fileorsect = $filesect[1]
	shift filesect

	if ($nameorzero != "0") then
	    set infile = $nameorzero
	    set insect = $fileorsect
	else	
	    set infile = $fileorsect
	    set insect = "0"
	    if ("$NEWSIZE" == "/" && "$NEWMODE" == "/" && "$NEWCEN" == "0,0") set docopy = "1"
	endif
    endif
#
#	if skipping some sections, and its not a reference image, check if
#	this is a section to skip
#
    set doskip = "0"
    if ($ifskip == "1" && ($refpic == "0" || $firsttime == "1")) then
	set skiptmp = ($skips)
	while ($#skiptmp > 0)
	    if ($skiptmp[1] == $insect) set doskip = "1"
	    shift skiptmp
	end
    endif
    if ($doskip == "0") then


	if ($docopy == "1") then
	    cp $infile $tmppic
	else
	    newstack > /dev/null << EOF
1
$infile
$insect
1
$tmppic
$NEWSIZE
$NEWMODE
1
$NEWCEN
0
0
EOF
	endif
#
# 	prep the file next with enhance or whatever

	$prepfile

	if ($firsttime == "0") then
#
#	 rename this prep'd file to "previous" prep file
#
	    \mv -f $tmpprp $tmplprp
	    set firsttime = "1"
	else
#
#      Extract the prexf if needed
#
	    if ($prexffile != "") then
		@ headnum = $insect + 1
		head -$headnum $prexffile | tail -1 >! $tmpxfin
	    endif
#
#      Now do search for transform
#
	    $runsearch
#
#      Add transform to file
#
	    cat $tmpxf >> $XFLISTFILE
	    echo -n "$insect : "
	    cat $tmpxf
#
#	Rename tmp.prp to tmpl.prp for next round
	    if ($refpic == "0") then
		\mv -f $tmpprp $tmplprp
	    endif

	endif
    else
#	if skipping, just output unit transform
	echo '   1.0000000   0.0000000   0.0000000   1.0000000       0.000       0.000' >> $XFLISTFILE
    endif
end

clean:
unset noglob
/bin/rm -f $tmpdir/$com.*.$$*
exit 0
