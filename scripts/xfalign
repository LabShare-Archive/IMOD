#! /bin/csh -f

#  $Id$
#  Log at end of file

nohup

set xcfilter = "0.01,0.05,0,0.25"

if ($#argv < 2) then
usage:
cat <<EOF
Usage: xfalign options input_file output_transform_file
input_file: an image stack, or a text file with a list of sections or files
options: 
 -si[ze] X,Y              Size to extract from image
 -o[ffset] dX,dY          Center offset to subarea
 -f[ilter] s1,s2,r1,r2    Sigmas and Radii for prefilter
 -red[uce] n              Binning factor to reduce by (default 2)
 -sk[ip] n1,n2,n3...      List of sections to skip (ranges OK)
 -br[eak] n1,n2,n3...     List of sections to break alignment at (ranges OK)
 -bp[air]                 Break alignment for paired images
 -m[att] f                Fraction of image to omit at edges, or # of pixels
 -pa[rams] n              0 for formal params, or # of semi-natural params
 -bi[linear]              To use bilinear interpolation
 -ref reference_file      To align stack to reference
 -pr[excorr]              To do initial cross-correlation alignment
 -x[cfilter] s1,s2,r1,r2  Sigmas and Radii for filter used in initial
                            cross-correlation (default $xcfilter)
 -i[nitial] prexf_file    Start with initial F alignments from file
 -t[omo]                  Align top/bottom averages from serial tomograms
 -d[iff]                  Output final difference measure for each pair
 -P                       Output process ID
EOF
	exit 1
endif

setenv LC_NUMERIC C

set tmpdir = /usr/tmp
if ($?IMOD_DIR) then
    setenv PATH "$IMOD_DIR/bin:$PATH"
    if (-e "$IMOD_DIR/bin/settmpdir") source "$IMOD_DIR/bin/settmpdir"
endif

set pname      = xfalign
set com        = $pname:t
set runenhance = "$tmpdir/$com.enhance.$$"
set runsearch  = "$tmpdir/$com.search.$$"
set tmpxf      = "$tmpdir/$com.xf.$$"
set tmppic     = "$tmpdir/$com.pic.$$"
set tmpprp     = "$tmpdir/$com.prp.$$"
set tmplprp    = "$tmpdir/$com.lprp.$$"
set tmplog     = "$tmpdir/$com.log.$$"
set refpic     = "0"
set ifskip     = "0"
set ifbreak    = "0"
set ifpair     = "0"
set seclist    = "$tmpdir/$com.secs.$$"
set prexcorr   = "0"
set prexffile  = ""
set iftomo     = 0
set exitstat   = 1
set diffout    = 0
set noglob
onintr clean

#
# Sections will be extracted one by one from the input stack using NEWSTACK
# NEWSIZE, NEWMODE, and NEWCEN control image extraction as follows:
#

# set NEWSIZE to a new x and y image size (e.g. "x,y") or leave as "/" for
# same size as input
# set by -size option
set NEWSIZE = "/"
#
# set NEWMODE to a new data mode, or leave as "/" for same mode as input
set NEWMODE = "/"
#
# set NEWCEN to a relative center offset if using a new image size
# set by -offset option
set NEWCEN = "0,0"
#
# Sections can then be prepared for alignment using the program ENHANCE
# Set FILTERPARAM to the "sigma1, sigma2, radius1, radius2" values required
# by ENHANCE (the same parameters used in VIEWFILT) or leave as "NONE" to
# omit filtering
# set by -filter option.
set FILTERPARAM = "NONE"
#

#
# Now specify the parameters to XFSIMPLEX.  Default values are in []
# Set tolerances in difference/distance measure and in transformation
# parameters for terminating final minimization [.0005 and .02, or .001 and
# .04 for images no larger than 128 by 128], tolerances for terminating
# initial search, or 0,0 to have only the final search [.005 and .2],
# factor to apply to basic step sizes to get initial step size [2], and
# 1 or 2 for trace, or 0 for no trace [0]
set TOLERANCES = ",,,,,,"
#
# Set NPARAM to 0 search for the six formal transformation parameters, or set
# it to the number of semi-natural parameters to vary [0]
# set by -params option
set NPARAM = "0"
#
# Set FRACMATT to the fraction of the image to ignore at each edge [0.05]
# set by -matt option
set FRACMATT = ","
#
# Set RANGEMEAN to 0 or 1 to float images to have same range or same mean,
# respectively [1]
set RANGEMEAN = ","
#
# Set NREDUCE to the binning factor to reduce images by in X and Y [2]
# set by -reduce option
set NREDUCE = "2"
#
# set DIFFDIST to 0 to use the difference between images as a measure of the
# match between images, or 1 to use the sum of distances between points in the
# images with corresponding intensities. [0]
set DIFFDIST = "0"
#
# If you select the difference measure, you just need to set IFBILINEAR to 1
# to use bilinear interpolation to assess image fit, or 0 not to [0]
# set by -bilinear option
set IFBILINEAR = "0"
#
# If instead you use the distance measure, there is no bilinear option, but
# you have 5 more parameters to select.
# Set NREDUNDANT to the distance in pixels to search from a "comparison point"
# to eliminate redundant points with similar densities.  [Default is 0 for
# images less than 240*180pixels after reduction by 2 (if any), 1 for images
# between 240*180 and 480*360, and, 2 for larger images]
set NREDUNDANT = ","
#
# Set RADIUS to the maximum distance in pixels to search from a comparison
# point for points in the other image with matching densities.  [Default is 4
# if images are reduced by 2, or 5 if they are not]
set RADIUS = ","
#
# Set MATCHDIFF to the maximum density difference constituting a match [0.05]
set MATCHDIFF = ","
#
# Set NPCRANGES to the # of ranges of densities to make comparisons with [2]
set NPCRANGES = ","
#
# Set PCRANGES to the lower and upper percentiles for those ranges.  [Default
# is 0,8,92,100 for images of 320*240 pixels or smaller (after reductions
# by 2, if any), and the ranges scale linearly down to 0,5,95,100 for images
# of 640*480 pixels or larger].
set PCRANGES = ",,,,"
#
#
# ALL THIS WAS NICE FOR PRETENDING SOMEONE COULD EDIT THE SCRIPT - BUT
# GOT RID OF "subroutine to prep a file" TO AVOID MULTIPLE SHELLS.
# you could edit runenhance to do other things as long as
# the image is in $tmppic at start and $tmpprp at end
#
# ----------------------------------------------------------------------
#                      YOU ARE DONE SETTING DEFAULT PARAMETERS
# ----------------------------------------------------------------------

# command line options
while($#argv > 2)
    switch($argv[1])
        case -si*:
            shift
            set NEWSIZE = $argv[1]
            breaksw

#        case -mode:
#            shift
#            set NEWMODE = $argv[1]
#            breaksw

        case -o*:
            shift
            set NEWCEN = $argv[1]
            breaksw

        case -f*:
            shift
            set FILTERPARAM = $argv[1]
            breaksw

        case -red*:
            shift
            set NREDUCE = $argv[1]
            breaksw

        case -sk*:
            shift
            set ifskip = "1"
            set words = (`echo $argv[1]| sed '/,/s// /g'`)
            breaksw

        case -br*:
            shift
            set ifbreak = "1"
            set words = (`echo $argv[1]| sed '/,/s// /g'`)
            breaksw

        case -bp*:
            set ifpair = "1"
            breaksw

        case -m*:
            shift
            set FRACMATT = $argv[1]
            breaksw

        case -pa*:
            shift
            set NPARAM = $argv[1]
            breaksw

        case -bi*:
            set IFBILINEAR = "1"
            breaksw

        case -ref*:
            shift
            set refpic = "1"
            set reffile = $argv[1]
            breaksw

        case -pr*:
            set prexcorr = "1"
            breaksw

        case -x*:
            shift
            set xcfilter = $argv[1]
            breaksw

        case -i*:
            shift
            set prexffile = $argv[1]
            breaksw

        case -t*:
            set iftomo = 1
            breaksw

        case -d*:
            set diffout = 1
            breaksw

        case -P:
            echo2 Shell PID: $$
            breaksw

        default:
            echo "ERROR: $com - Illegal option $argv[1]"
            goto usage
    endsw
    shift
end

if ($prexcorr == "1" && $refpic == "1") then
    echo "ERROR: $com - You cannot use initial cross-correlation with alignment to one reference"
    exit 1
endif

if ($prexcorr == "1" && $prexffile != "") then
    echo "ERROR: $com - You cannot use initial cross-correlation with initial transforms"
    exit 1
endif

if ($ifskip == 1 && $ifbreak == 1) then
    echo "ERROR: $com - You cannot use both a break list and skip list"
    exit 1
endif

if (! -e $argv[1]) then
    echo "ERROR: $com - Input image file $argv[1] does not exist"
    exit 1
endif

if ($prexffile != "") then
    if (! -e $prexffile) then
        echo "ERROR: $com - Initial transform file $prexffile does not exist"
        exit 1
    endif
endif

if ($refpic) then
    if (! -e $reffile) then
        echo "ERROR: $com - Reference image file $reffile does not exist"
        exit 1
    endif
endif

# input_file is either an MRC file or a filesectlist
# filesectlist format:
# Put either the MRC stack name on the first line then the
# successive section numbers (one per line), or a zero (0) on the first
# line and the successive file names, one per line.

set nxyz =  `header -si $argv[1] | sed '/[[:cntrl:]]/s///g'`

if ($#nxyz < 3) then
    set filesectlist = $argv[1]
    if ($prexcorr == "1") then
        echo "ERROR: $com - You cannot use initial cross-correlation with file lists"
        exit 1
    endif
    if ($iftomo == 0) echo "File is not identified as an MRC file and is assumed to be a section list"
else
    @ numsec =  $nxyz[3]
    echo $argv[1] >! "$seclist"
    @ secnum = 0
    while ($secnum < $numsec)
	echo $secnum >> "$seclist"
	@ secnum++
    end
    set filesectlist = "$seclist"

    # Make sure the size is good for enhance
    #
    if ( ("$FILTERPARAM"  != "0.,0.,0.,0.")  && ($FILTERPARAM != "NONE") ) then
        if ("$NEWSIZE" == "/") then
            set origsize = ($nxyz[1] $nxyz[2])
        else
            set origsize = `echo $NEWSIZE | sed '/,/s// /g'`
            if ($#origsize < 2) then
                echo "ERROR: $com - size entry must contain two numbers"
                exit 1
            endif
        endif
        set tempsize = `goodframe $origsize[1] $origsize[2] | sed '/[[:cntrl:]]/s///g'`
        if ($#tempsize < 2) then
            echo "ERROR: $com - Cannot run goodframe to get size for filtering"
            exit 1
        endif
        if ($tempsize[1] != $origsize[1] || $tempsize[2] != $origsize[2]) \
            set NEWSIZE = $tempsize[1],$tempsize[2]
    endif
endif

# If serial tomograms, check other options
#
if ($iftomo == 1 || $ifpair == 1) then
    if ($ifskip == 1 || $ifbreak == 1) then
        echo "ERROR: $com - You cannot enter a break or a skip list in tomogram or pair mode"
        exit 1
    endif
    if ($refpic == 1) then
        echo "ERROR: $com - You cannot use alignment to one reference with tomograms or pairs"
        exit 1
    endif
    if ($#nxyz < 3) then
        echo "ERROR: $com - Error reading image file header"
        exit 1
    endif

    # Set up break list as even sections
    #
    set ifbreak = 1
    set words = (2)
    @ secnum = 4
    while ($secnum < $numsec)
        set words = ($words $secnum)
        @ secnum += 2
    end
endif

# Set XFLISTFILE to the name of the file to receive the list of F transforms
set XFLISTFILE = $argv[2]

# Set up the initial cross-correlation
#
if ($prexcorr == "1") then
    set preroot = $XFLISTFILE:r
    set prexffile = $preroot.xcxf
    if ($xcfilter == "NONE" || $xcfilter == "none") set xcfilter = "0.,0.,0.,0."
echo "RUNNING TILTXCORR FOR INITIAL CROSS-CORRELATION ALIGNMENTS..."
    tiltxcorr >! "$tmplog" <<EOF
$argv[1]

$prexffile
1
0,0
0
$xcfilter
0
/
/
/
/
EOF
    if ($status) goto error
    echo "INITIAL CROSS-CORRELATION ALIGNMENT TRANSFORMS WRITTEN TO $prexffile"

    # trim the transform list for tomos
    #
    if ($iftomo == 1) then
        set tmptrim = $com.trim.$$
        head -n 2 $prexffile >! "$tmptrim"
        @ secnum = 4
        while ($secnum <= $numsec)
            head -n $secnum $prexffile | tail -n 1 >> "$tmptrim"
            @ secnum += 2
        end
        \mv -f "$tmptrim" $prexffile
    endif

    echo "X, Y SHIFTS FOUND:"
    awk '{printf "%9.2f  %9.2f\n", $5, $6}' $prexffile
endif    

set tmpxfin = ""
if ($prexffile != "") set tmpxfin = "$tmpdir/$com.xfin.$$"

#
# set up the file to enhance or just rename tmp.pic
# 
if ( ($FILTERPARAM  == "0.,0.,0.,0.")  ||  ($FILTERPARAM == "NONE") ) then
   cat >! "$runenhance" <<EOCAT
mv -f "$tmppic" "$tmpprp"
EOCAT
else
   cat >! "$runenhance" <<EOCAT
enhance "$tmppic" "$tmpprp" >! "$tmplog" <<EOF
$FILTERPARAM
1
EOF
if (\$status) exit 1
EOCAT
endif
#
#     Initialize xflist file; make backup.  If it is also the prexf file,
#     point to the backup file
#
if (-e $XFLISTFILE) \mv -f $XFLISTFILE $XFLISTFILE~
if ("$prexffile" == "$XFLISTFILE") set prexffile = $XFLISTFILE~
if ($refpic == "0") echo '   1.0000000   0.0000000   0.0000000   1.0000000       0.000       0.000' >! $XFLISTFILE
#
#      Set up file to run xfsimplex with the given parameters
#
cat >! "$runsearch" <<EOCAT
$tmplprp
$tmpprp
$tmpxf
$tmpxfin
$TOLERANCES
$NPARAM
$FRACMATT
$RANGEMEAN
$NREDUCE
$DIFFDIST
EOCAT

if ($DIFFDIST == "0") then
cat >> "$runsearch" <<EOCAT
$IFBILINEAR
EOCAT
else
cat >> "$runsearch" <<EOCAT
$NREDUNDANT
$RADIUS
$MATCHDIFF
$NPCRANGES
$PCRANGES
EOCAT
endif
#
#	parse the skip list
#
echo "TRANSFORMS FOUND BY XFSIMPLEX:"
if ($ifskip == "1" || $ifbreak == 1) then
    set skips = ""
    while ($#words > 0)
	switch ($words[1])
	    case *-*:
		set startend = (`echo $words[1]| sed '/-/s// /g'`)
		@ start = $startend[1]
		@ end = $startend[$#startend]
		@ num = $start
		while ($num <= $end)
		    set skips = ($skips $num)
		    @ num = $num + 1
		end
		breaksw
	    default:	
		set skips = ($skips $words[1])
		breaksw
	endsw
	shift words
    end
endif

#
# 	Get the file and section list as a wordlist
#
set filesect = `cat $filesectlist`
#
#	 first line is either a stack name or 0 for separate files
#
set nameorzero = $filesect[1]
shift filesect
#
# 	next should be specification for the first file/section
#
set firsttime = "0"

while ($#filesect != 0 )

    set docopy = "0"
#
#	If doing a reference file, set up to get from that file
#
    if ($refpic != "0" && $firsttime == "0") then
	set infile = $reffile
	set insect = "0"
    else	
	set fileorsect = $filesect[1]
	shift filesect

	if ($nameorzero != "0") then
	    set infile = $nameorzero
	    set insect = $fileorsect
	else	
	    set infile = $fileorsect
	    set insect = "0"
	    if ("$NEWSIZE" == "/" && "$NEWMODE" == "/" && "$NEWCEN" == "0,0") set docopy = "1"
	endif
    endif
#
#	if skipping some sections, and its not a reference image, check if
#	this is a section to skip
#
    set doskip = 0
    set dobreak = 0
    if (($ifskip || $ifbreak) && ($refpic == 0 || $firsttime == 1)) then
	set skiptmp = ($skips)
	while ($#skiptmp > 0)
	    if ($skiptmp[1] == $insect) then
                if ($ifskip) set doskip = 1
                if ($ifbreak) set dobreak = 1
                break
            endif
	    shift skiptmp
	end
    endif

    if ($doskip == "0") then

	if ($docopy == "1") then
	    \cp $infile "$tmppic"
            chmod u+rw "$tmppic"
	else
            newstack -sec $insect -size $NEWSIZE -mode $NEWMODE -off $NEWCEN $infile "$tmppic" >! "$tmplog"
            if ($status) goto error
	endif
#
# 	prep the file next with enhance or whatever

	csh -f "$runenhance"
        if ($status) then
            echo "ERROR: $com - running the enhance routine"
            exit
            goto clean
        endif

	if ($firsttime == "0" || $dobreak) then
            #
            # first time or at break, rename this prep'd file to "previous" 
            # prep file, and put out a unit transform unless doing tomo
            #
	    \mv -f "$tmpprp" "$tmplprp"
            if ($firsttime == 1 && $iftomo == 0) \
                echo '   1.0000000   0.0000000   0.0000000   1.0000000       0.000       0.000' >> $XFLISTFILE
	    set firsttime = "1"
	else
#
#      Extract the prexf if needed, adjust line number for tomo mode
#
	    if ($prexffile != "") then
		@ headnum = $insect + 1
                if ($iftomo == 1) @ headnum = ($insect + 1) / 2 + 1
		head -n $headnum $prexffile | tail -n 1 >! "$tmpxfin"
	    endif
#
#      Now do search for transform
#
	    xfsimplex < "$runsearch" >! "$tmplog"
            if ($status) then
                echo "ERROR: $com - running xfsimplex"
                goto error
            endif
            if ($diffout) then
                set values = `awk '/FINAL VALUES/,/[0-9]/' "$tmplog" | tail -n 1`
                if ($#values > 1) then
                    echo "Difference:  $values[2]"
                endif
            endif
#
#      Add transform to file
#
	    cat "$tmpxf" >> $XFLISTFILE
	    echo -n "$insect : "
	    cat "$tmpxf"
#
#	Rename tmp.prp to tmpl.prp for next round
	    if ($refpic == "0") then
		\mv -f "$tmpprp" "$tmplprp"
	    endif

	endif
    else if ($iftomo == 0) then
#	if skipping, just output unit transform
	echo '   1.0000000   0.0000000   0.0000000   1.0000000       0.000       0.000' >> $XFLISTFILE
    endif
end
set exitstat = 0
goto clean

error:
grep ERROR "$tmplog"

clean:
unset noglob
/bin/rm -f "$tmpdir/"$com.*.$$* $com.trim.$$
exit $exitstat

#  $Log$
#  Revision 3.21  2008/05/08 00:08:26  mast
#  Do not escape quotes in a cat!
#
#  Revision 3.20  2008/01/04 07:03:38  mast
#  Fixed for space in IMOD_DIR, possibly for space in tmpdir
#
#  Revision 3.19  2006/08/17 18:36:55  mast
#  Added locale statement to keep output of awk from having instead of .
#
#  Revision 3.18  2006/06/08 18:47:57  mast
#  Changed to specify binning rather than reductions by 2 to xfsimplex
#
#  Revision 3.17  2006/05/14 03:02:54  mast
#  Added option to output the difference measure
#
#  Revision 3.16  2006/02/17 21:50:20  mast
#  Filter output of goodframe
#
#  Revision 3.15  2006/02/16 06:47:09  mast
#  Stripped control chars from output of sed/header etc for Windows
#
#  Revision 3.14  2006/01/16 05:32:46  mast
#  Added option for breaking at all pairs
#
#  Revision 3.13  2005/12/13 17:05:36  mast
#  Fixed problem with filtering odd sizes that result from rotations
#
#  Revision 3.12  2005/11/19 04:31:26  mast
#  Quote path setting to preserve spaces
#
#  Revision 3.11  2004/10/16 02:42:04  mast
#  Fixed bug in that prevented using a filter
#
#  Revision 3.10  2004/10/11 19:06:31  mast
#  Added option -P to output PID
#
#  Revision 3.9  2004/08/27 05:46:48  mast
#  Switched to using head -n and tail -n
#
#  Revision 3.8  2004/07/21 14:19:59  mast
#  Added option to break alignment instead of skipping section and added
#  special serial tomogram mode that maintains fewer transforms
#
#  Revision 3.7  2004/06/29 03:50:57  mast
#  Added nohup
#
#  Revision 3.6  2003/10/24 02:14:00  mast
#  source settmpdir to get tmpdir, better for Windows
#
#  Revision 3.5  2003/07/29 16:08:24  mast
#  For Windows, needed to run script files explicitly with csh
#
#  Revision 3.4  2003/07/28 16:43:37  mast
#  Switch from using 'file' command to using 'header' to test for MRC file
#  versus text input file, because there is no 'file' in cygwin
#
#  Revision 3.3  2003/06/20 20:10:33  mast
#  Let tmpdir be defined and fall back to /tmp if /usr/tmp does not exist
#
#  Revision 3.2  2003/05/13 20:15:26  mast
#  Eliminate using $0 to get temp file name, doesn't work on Windows
#
#  Revision 3.1  2002/04/29 22:03:34  mast
#  Made first write to $seclist be via >! rather than >>
#
