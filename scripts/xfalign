#! /bin/csh -f

#  $Author$
#
#  $Date$
#
#  $Revision$
#
#  $Log$
#  Revision 3.12  2005/11/19 04:31:26  mast
#  Quote path setting to preserve spaces
#
#  Revision 3.11  2004/10/16 02:42:04  mast
#  Fixed bug in that prevented using a filter
#
#  Revision 3.10  2004/10/11 19:06:31  mast
#  Added option -P to output PID
#
#  Revision 3.9  2004/08/27 05:46:48  mast
#  Switched to using head -n and tail -n
#
#  Revision 3.8  2004/07/21 14:19:59  mast
#  Added option to break alignment instead of skipping section and added
#  special serial tomogram mode that maintains fewer transforms
#
#  Revision 3.7  2004/06/29 03:50:57  mast
#  Added nohup
#
#  Revision 3.6  2003/10/24 02:14:00  mast
#  source settmpdir to get tmpdir, better for Windows
#
#  Revision 3.5  2003/07/29 16:08:24  mast
#  For Windows, needed to run script files explicitly with csh
#
#  Revision 3.4  2003/07/28 16:43:37  mast
#  Switch from using 'file' command to using 'header' to test for MRC file
#  versus text input file, because there is no 'file' in cygwin
#
#  Revision 3.3  2003/06/20 20:10:33  mast
#  Let tmpdir be defined and fall back to /tmp if /usr/tmp does not exist
#
#  Revision 3.2  2003/05/13 20:15:26  mast
#  Eliminate using $0 to get temp file name, doesn't work on Windows
#
#  Revision 3.1  2002/04/29 22:03:34  mast
#  Made first write to $seclist be via >! rather than >>
#

nohup

set xcfilter = "0.01,0.05,0,0.25"

if ($#argv < 2) then
usage:
cat <<EOF
Usage: xfalign options input_file output_transform_file
input_file: an image stack, or a text file with a list of sections or files
options: 
 -si[ze] X,Y              -  size to extract from image
 -o[ffset] dX,dY          -  center offset to subarea
 -f[ilter] s1,s2,r1,r2    -  Sigmas and Radii for prefilter
 -red[uce] n              -  # of times to reduce by 2 (default 1)
 -sk[ip] n1,n2,n3...      -  list of sections to skip (ranges OK)
 -br[eak] n1,n2,n3...     -  list of sections to break alignment at (ranges OK)
 -m[att] f                -  fraction of image to omit at edges, or # of pixels
 -pa[rams] n              -  0 for formal params, or # of semi-natural params
 -bi[linear]              -  to use bilinear interpolation
 -ref reference_file      -  to align stack to reference
 -pr[excorr]              -  to do initial cross-correlation alignment
 -x[cfilter] s1,s2,r1,r2  -  Sigmas and Radii for filter used in initial
                               cross-correlation (default $xcfilter)
 -i[nitial] prexf_file    -  start with initial F alignments from file
 -t[omo]                  -  align top/bottom averages from serial tomograms
 -P                       -  Output process ID
EOF
	exit 1
endif

set tmpdir = /usr/tmp
if ($?IMOD_DIR) then
    setenv PATH "$IMOD_DIR/bin:$PATH"
    if (-e $IMOD_DIR/bin/settmpdir) source $IMOD_DIR/bin/settmpdir
endif

set pname      = xfalign
set com        = $pname:t
set runenhance = $tmpdir/$com.enhance.$$
set runsearch  = $tmpdir/$com.search.$$
set tmpxf      = $tmpdir/$com.xf.$$
set tmppic     = $tmpdir/$com.pic.$$
set tmpprp     = $tmpdir/$com.prp.$$
set tmplprp    = $tmpdir/$com.lprp.$$
set tmplog     = $tmpdir/$com.log.$$
set refpic     = "0"
set ifskip     = "0"
set ifbreak    = "0"
set seclist    = $tmpdir/$com.secs.$$
set prexcorr   = "0"
set prexffile  = ""
set iftomo     = 0
set exitstat   = 1
set noglob
onintr clean

#
# Sections will be extracted one by one from the input stack using NEWSTACK
# NEWSIZE, NEWMODE, and NEWCEN control image extraction as follows:
#

# set NEWSIZE to a new x and y image size (e.g. "x,y") or leave as "/" for
# same size as input
# set by -size option
set NEWSIZE = "/"
#
# set NEWMODE to a new data mode, or leave as "/" for same mode as input
set NEWMODE = "/"
#
# set NEWCEN to a relative center offset if using a new image size
# set by -offset option
set NEWCEN = "0,0"
#
# Sections can then be prepared for alignment using the program ENHANCE
# Set FILTERPARAM to the "sigma1, sigma2, radius1, radius2" values required
# by ENHANCE (the same parameters used in VIEWFILT) or leave as "NONE" to
# omit filtering
# set by -filter option.
set FILTERPARAM = "NONE"
#

#
# Now specify the parameters to XFSIMPLEX.  Default values are in []
# Set tolerances in difference/distance measure and in transformation
# parameters for terminating final minimization [.0005 and .02, or .001 and
# .04 for images no larger than 128 by 128], tolerances for terminating
# initial search, or 0,0 to have only the final search [.005 and .2],
# factor to apply to basic step sizes to get initial step size [2], and
# 1 or 2 for trace, or 0 for no trace [0]
set TOLERANCES = ",,,,,,"
#
# Set NPARAM to 0 search for the six formal transformation parameters, or set
# it to the number of semi-natural parameters to vary [0]
# set by -params option
set NPARAM = "0"
#
# Set FRACMATT to the fraction of the image to ignore at each edge [0.05]
# set by -matt option
set FRACMATT = ","
#
# Set RANGEMEAN to 0 or 1 to float images to have same range or same mean,
# respectively [1]
set RANGEMEAN = ","
#
# Set NREDUCE to the # of times to reduce images by factor of 2 in x and y [1]
# set by -reduce option
set NREDUCE = "1"
#
# set DIFFDIST to 0 to use the difference between images as a measure of the
# match between images, or 1 to use the sum of distances between points in the
# images with corresponding intensities. [0]
set DIFFDIST = "0"
#
# If you select the difference measure, you just need to set IFBILINEAR to 1
# to use bilinear interpolation to assess image fit, or 0 not to [0]
# set by -bilinear option
set IFBILINEAR = "0"
#
# If instead you use the distance measure, there is no bilinear option, but
# you have 5 more parameters to select.
# Set NREDUNDANT to the distance in pixels to search from a "comparison point"
# to eliminate redundant points with similar densities.  [Default is 0 for
# images less than 240*180pixels after reduction by 2 (if any), 1 for images
# between 240*180 and 480*360, and, 2 for larger images]
set NREDUNDANT = ","
#
# Set RADIUS to the maximum distance in pixels to search from a comparison
# point for points in the other image with matching densities.  [Default is 4
# if images are reduced by 2, or 5 if they are not]
set RADIUS = ","
#
# Set MATCHDIFF to the maximum density difference constituting a match [0.05]
set MATCHDIFF = ","
#
# Set NPCRANGES to the # of ranges of densities to make comparisons with [2]
set NPCRANGES = ","
#
# Set PCRANGES to the lower and upper percentiles for those ranges.  [Default
# is 0,8,92,100 for images of 320*240 pixels or smaller (after reductions
# by 2, if any), and the ranges scale linearly down to 0,5,95,100 for images
# of 640*480 pixels or larger].
set PCRANGES = ",,,,"
#
#
# ALL THIS WAS NICE FOR PRETENDING SOMEONE COULD EDIT THE SCRIPT - BUT
# GOT RID OF "subroutine to prep a file" TO AVOID MULTIPLE SHELLS.
# you could edit runenhance to do other things as long as
# the image is in $tmppic at start and $tmpprp at end
#
# ----------------------------------------------------------------------
#                      YOU ARE DONE SETTING DEFAULT PARAMETERS
# ----------------------------------------------------------------------

# command line options
while($#argv > 2)
    switch($argv[1])
        case -si*:
            shift
            set NEWSIZE = $argv[1]
            breaksw

#        case -mode:
#            shift
#            set NEWMODE = $argv[1]
#            breaksw

        case -o*:
            shift
            set NEWCEN = $argv[1]
            breaksw

        case -f*:
            shift
            set FILTERPARAM = $argv[1]
            breaksw

        case -red*:
            shift
            set NREDUCE = $argv[1]
            breaksw

        case -sk*:
            shift
            set ifskip = "1"
            set words = (`echo $argv[1]| sed '/,/s// /g'`)
            breaksw

        case -br*:
            shift
            set ifbreak = "1"
            set words = (`echo $argv[1]| sed '/,/s// /g'`)
            breaksw

        case -m*:
            shift
            set FRACMATT = $argv[1]
            breaksw

        case -pa*:
            shift
            set NPARAM = $argv[1]
            breaksw

        case -bi*:
            set IFBILINEAR = "1"
            breaksw

        case -ref*:
            shift
            set refpic = "1"
            set reffile = $argv[1]
            breaksw

        case -pr*:
            set prexcorr = "1"
            breaksw

        case -x*:
            shift
            set xcfilter = $argv[1]
            breaksw

        case -i*:
            shift
            set prexffile = $argv[1]
            breaksw

        case -t*:
            set iftomo = 1
            breaksw

        case -P:
            echo2 Shell PID: $$
            breaksw

        default:
            echo "ERROR: $com - Illegal option $argv[1]"
            goto usage
    endsw
    shift
end

if ($prexcorr == "1" && $refpic == "1") then
    echo "ERROR: $com - You cannot use initial cross-correlation with alignment to one reference"
    exit 1
endif

if ($prexcorr == "1" && $prexffile != "") then
    echo "ERROR: $com - You cannot use initial cross-correlation with initial transforms"
    exit 1
endif

if ($ifskip == 1 && $ifbreak == 1) then
    echo "ERROR: $com - You cannot use both a break list and skip list"
    exit 1
endif

if (! -e $argv[1]) then
    echo "ERROR: $com - Input image file $argv[1] does not exist"
    exit 1
endif

if ($prexffile != "") then
    if (! -e $prexffile) then
        echo "ERROR: $com - Initial transform file $prexffile does not exist"
        exit 1
    endif
endif

if ($refpic) then
    if (! -e $reffile) then
        echo "ERROR: $com - Reference image file $reffile does not exist"
        exit 1
    endif
endif

# input_file is either an MRC file or a filesectlist
# filesectlist format:
# Put either the MRC stack name on the first line then the
# successive section numbers (one per line), or a zero (0) on the first
# line and the successive file names, one per line.

set nxyz =  `header $argv[1] | sed -n '/rows, sections/p'| awk '{print $7, $8, $9}'`

if ($#nxyz < 3) then
    set filesectlist = $argv[1]
    if ($prexcorr == "1") then
        echo "ERROR: $com - You cannot use initial cross-correlation with file lists"
        exit 1
    endif
    if ($iftomo == 0) echo "File is not identified as an MRC file and is assumed to be a section list"
else
    @ numsec =  $nxyz[3]
    echo $argv[1] >! $seclist
    @ secnum = 0
    while ($secnum < $numsec)
	echo $secnum >> $seclist
	@ secnum++
    end
    set filesectlist = $seclist

    # Make sure the size is good for enhance
    #
    if ( ("$FILTERPARAM"  != "0.,0.,0.,0.")  && ($FILTERPARAM != "NONE") ) then
        if ("$NEWSIZE" == "/") then
            set origsize = ($nxyz[1] $nxyz[2])
        else
            set origsize = `echo $NEWSIZE | sed '/,/s// /g'`
            if ($#origsize < 2) then
                echo "ERROR: $com - size entry must contain two numbers"
                exit 1
            endif
        endif
        set tempsize = `goodframe $origsize[1] $origsize[2]`
        if ($#tempsize < 2) then
            echo "ERROR: $com - Cannot run goodframe to get size for filtering"
            exit 1
        endif
        if ($tempsize[1] != $origsize[1] || $tempsize[2] != $origsize[2]) \
            set NEWSIZE = $tempsize[1],$tempsize[2]
    endif
endif

# If serial tomograms, check other options
#
if ($iftomo == 1) then
    if ($ifskip == 1 || $ifbreak == 1) then
        echo "ERROR: $com - You cannot enter a break or a skip list in serial tomogram mode"
        exit 1
    endif
    if ($refpic == 1) then
        echo "ERROR: $com - You cannot use alignment to one reference with serial tomograms"
        exit 1
    endif
    if ($#nxyz < 3) then
        echo "ERROR: $com - Error reading image file header"
        exit 1
    endif

    # Set up break list as even sections
    #
    set ifbreak = 1
    set words = (2)
    @ secnum = 4
    while ($secnum < $numsec)
        set words = ($words $secnum)
        @ secnum += 2
    end
endif

# Set XFLISTFILE to the name of the file to receive the list of F transforms
set XFLISTFILE = $argv[2]

# Set up the initial cross-correlation
#
if ($prexcorr == "1") then
    set preroot = $XFLISTFILE:r
    set prexffile = $preroot.xcxf
    if ($xcfilter == "NONE" || $xcfilter == "none") set xcfilter = "0.,0.,0.,0."
echo "RUNNING TILTXCORR FOR INITIAL CROSS-CORRELATION ALIGNMENTS..."
    tiltxcorr >! $tmplog <<EOF
$argv[1]

$prexffile
1
0,0
0
$xcfilter
0
/
/
/
/
EOF
    if ($status) goto error
    echo "INITIAL CROSS-CORRELATION ALIGNMENT TRANSFORMS WRITTEN TO $prexffile"

    # trim the transform list for tomos
    #
    if ($iftomo == 1) then
        set tmptrim = $com.trim.$$
        head -n 2 $prexffile >! $tmptrim
        @ secnum = 4
        while ($secnum <= $numsec)
            head -n $secnum $prexffile | tail -n 1 >> $tmptrim
            @ secnum += 2
        end
        \mv -f $tmptrim $prexffile
    endif

    echo "X, Y SHIFTS FOUND:"
    awk '{printf "%9.2f  %9.2f\n", $5, $6}' $prexffile
endif    

set tmpxfin = ""
if ($prexffile != "") set tmpxfin = $tmpdir/$com.xfin.$$

#
# set up the file to enhance or just rename tmp.pic
# 
if ( ($FILTERPARAM  == "0.,0.,0.,0.")  ||  ($FILTERPARAM == "NONE") ) then
   echo "mv -f $tmppic $tmpprp" >! $runenhance
else
   cat >! $runenhance <<EOCAT
enhance $tmppic $tmpprp >! $tmplog <<EOF
$FILTERPARAM
1
EOF
if (\$status) exit 1
EOCAT
endif
#
#     Initialize xflist file; make backup.  If it is also the prexf file,
#     point to the backup file
#
if (-e $XFLISTFILE) \mv -f $XFLISTFILE $XFLISTFILE~
if ("$prexffile" == "$XFLISTFILE") set prexffile = $XFLISTFILE~
if ($refpic == "0") echo '   1.0000000   0.0000000   0.0000000   1.0000000       0.000       0.000' >! $XFLISTFILE
#
#      Set up file to run xfsimplex with the given parameters
#
cat >! $runsearch <<EOCAT
$tmplprp
$tmpprp
$tmpxf
$tmpxfin
$TOLERANCES
$NPARAM
$FRACMATT
$RANGEMEAN
$NREDUCE
$DIFFDIST
EOCAT

if ($DIFFDIST == "0") then
cat >> $runsearch <<EOCAT
$IFBILINEAR
EOCAT
else
cat >> $runsearch <<EOCAT
$NREDUNDANT
$RADIUS
$MATCHDIFF
$NPCRANGES
$PCRANGES
EOCAT
endif
#
#	parse the skip list
#
echo "TRANSFORMS FOUND BY XFSIMPLEX:"
if ($ifskip == "1" || $ifbreak == 1) then
    set skips = ""
    while ($#words > 0)
	switch ($words[1])
	    case *-*:
		set startend = (`echo $words[1]| sed '/-/s// /g'`)
		@ start = $startend[1]
		@ end = $startend[$#startend]
		@ num = $start
		while ($num <= $end)
		    set skips = ($skips $num)
		    @ num = $num + 1
		end
		breaksw
	    default:	
		set skips = ($skips $words[1])
		breaksw
	endsw
	shift words
    end
endif

#
# 	Get the file and section list as a wordlist
#
set filesect = `cat $filesectlist`
#
#	 first line is either a stack name or 0 for separate files
#
set nameorzero = $filesect[1]
shift filesect
#
# 	next should be specification for the first file/section
#
set firsttime = "0"

while ($#filesect != 0 )

    set docopy = "0"
#
#	If doing a reference file, set up to get from that file
#
    if ($refpic != "0" && $firsttime == "0") then
	set infile = $reffile
	set insect = "0"
    else	
	set fileorsect = $filesect[1]
	shift filesect

	if ($nameorzero != "0") then
	    set infile = $nameorzero
	    set insect = $fileorsect
	else	
	    set infile = $fileorsect
	    set insect = "0"
	    if ("$NEWSIZE" == "/" && "$NEWMODE" == "/" && "$NEWCEN" == "0,0") set docopy = "1"
	endif
    endif
#
#	if skipping some sections, and its not a reference image, check if
#	this is a section to skip
#
    set doskip = 0
    set dobreak = 0
    if (($ifskip || $ifbreak) && ($refpic == 0 || $firsttime == 1)) then
	set skiptmp = ($skips)
	while ($#skiptmp > 0)
	    if ($skiptmp[1] == $insect) then
                if ($ifskip) set doskip = 1
                if ($ifbreak) set dobreak = 1
                break
            endif
	    shift skiptmp
	end
    endif

    if ($doskip == "0") then

	if ($docopy == "1") then
	    cp $infile $tmppic
	else
            newstack -sec $insect -size $NEWSIZE -mode $NEWMODE -off $NEWCEN $infile $tmppic >! $tmplog
            if ($status) goto error
	endif
#
# 	prep the file next with enhance or whatever

	csh -f $runenhance
        if ($status) then
            echo "ERROR: $com - running the enhance routine"
            goto clean
        endif

	if ($firsttime == "0" || $dobreak) then
            #
            # first time or at break, rename this prep'd file to "previous" 
            # prep file, and put out a unit transform unless doing tomo
            #
	    \mv -f $tmpprp $tmplprp
            if ($firsttime == 1 && $iftomo == 0) \
                echo '   1.0000000   0.0000000   0.0000000   1.0000000       0.000       0.000' >> $XFLISTFILE
	    set firsttime = "1"
	else
#
#      Extract the prexf if needed, adjust line number for tomo mode
#
	    if ($prexffile != "") then
		@ headnum = $insect + 1
                if ($iftomo == 1) @ headnum = ($insect + 1) / 2 + 1
		head -n $headnum $prexffile | tail -n 1 >! $tmpxfin
	    endif
#
#      Now do search for transform
#
	    xfsimplex < $runsearch > /dev/null
            if ($status) then
                echo "ERROR: $com - running xfsimplex"
                goto clean
        endif
#
#      Add transform to file
#
	    cat $tmpxf >> $XFLISTFILE
	    echo -n "$insect : "
	    cat $tmpxf
#
#	Rename tmp.prp to tmpl.prp for next round
	    if ($refpic == "0") then
		\mv -f $tmpprp $tmplprp
	    endif

	endif
    else if ($iftomo == 0) then
#	if skipping, just output unit transform
	echo '   1.0000000   0.0000000   0.0000000   1.0000000       0.000       0.000' >> $XFLISTFILE
    endif
end
set exitstat = 0
goto clean

error:
grep ERROR $tmplog

clean:
unset noglob
/bin/rm -f $tmpdir/$com.*.$$* $com.trim.$$
exit $exitstat
