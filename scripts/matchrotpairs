#! /bin/csh -f
# matchrotpairs will find the best matching pair of rotated images
# and find the alignment between them
# It was derived from transferfid
#
#  $Author$
#
#  $Date$
#
#  $Revision$
#
#  $Log$
#  Revision 1.4  2004/08/27 05:46:48  mast
#  Switched to using head -n and tail -n
#
#  Revision 1.3  2004/07/08 22:54:18  mast
#  Switched some echos to \echo to dodge Cygwin tcsh bug
#
#  Revision 1.2  2004/03/16 06:58:58  mast
#  Fixed something with section limits
#
#  Revision 1.1  2004/02/29 18:54:13  mast
#  Initial version
#

# Filter for tiltxcorr
set sigma1 = 0.03
set sigma2 = 0.05
set radius2 = 0.25

# Number of wins more in one rotation direction than the other that will
# make it abandon the other direction
@ DIRECTION_WIN_THRESH = 4

set tmpdir = /usr/tmp
if ($?IMOD_DIR) then
    setenv PATH "$IMOD_DIR/bin:$PATH"
    if (-e $IMOD_DIR/bin/settmpdir) source $IMOD_DIR/bin/settmpdir
endif

onintr searchdone

#
# set names of temp files
#
set pn      = matchrotpairs
set com        = $pn:t
set tmpstack   = $tmpdir/$com.stack.$$
set tmpimga    = $tmpdir/$com.imga.$$
set tmpimgb    = $tmpdir/$com.imgb.$$
set tmpxcxf    = $tmpdir/$com.xcxf.$$
set tmpxfin    = $tmpdir/$com.xfin.$$
set tmpxf1    = $tmpdir/$com.xf1.$$
set tmpxf2    = $tmpdir/$com.xf2.$$
set tmprot90    = $tmpdir/$com.rot90.$$
set tmpminxf    = $tmpdir/$com.minxf.$$
set tmpxflog    = $tmpdir/$com.xflog.$$
set tmpmidxf   = $tmpdir/$com.midxf.$$
set tmperrlog    = $tmpdir/$com.errlog.$$

#
# set other defaults or values to indicate no argument was entered
#
set zsea = ""
set zseb = ""
set pmstart = 0
set pmend = 1
set leavetmp = 0
set midas = 0
set distort = ""
set imbin = ""

if ($#argv < 1) goto usage

while ($#argv > 3)
  switch ($argv[1])
    case -za:
      set zsea = $argv[2]
      shift; shift
      breaksw
    case -zb:
      set zseb = $argv[2]
      shift; shift
      breaksw
    case -a:
      @ angle = $argv[2]
      if ($angle < 0) set pmend = 0
      if ($angle > 0) set pmstart = 1
      shift; shift
      breaksw
    case -t:
      set leavetmp = 1
      shift
      breaksw
    case -m:
      set midas = 1
      shift
      breaksw
    case -h:
      goto usage
    case -P:
      echo2 Shell PID: $$
      shift
      breaksw
    case -d*
      set distort = "-dist $argv[2]"
      shift; shift
      breaksw
    case -b*
      set imbin = "-image $argv[2]"
      shift; shift
      breaksw

    default:
      echo "ERROR: ${pn} - bad argument $argv[1]"
      goto usage
  endsw
end

set imagea = $argv[1]
set imageb = $argv[2]
set outfile = $argv[3]
set beststack   = $outfile:r.stack

if (! -e $imagea) then
    echo "ERROR: $pn - Image file $imagea does not exist"
    exit 1
endif

if (! -e $imageb) then
    echo "ERROR: $pn - Image file $imageb does not exist"
    exit 1
endif

#
# Get image sizes
#
set nxyz =  `header $imagea | sed -n '/rows, sections/p'| awk '{print $7, $8, $9}'`
@ nxa = $nxyz[1]
@ nya = $nxyz[2]
@ nza = $nxyz[3]

set nxyz =  `header $imageb | sed -n '/rows, sections/p'| awk '{print $7, $8, $9}'`
@ nxb = $nxyz[1]
@ nyb = $nxyz[2]
@ nzb = $nxyz[3]

#
# Set the number of reductions by 2 needed to get image size to 512 or less
#
@ size = $nxb
if ($nyb > $size) @ size = $nyb
@ reduce = 0
@ sizered = $size
while ($sizered > 512)
    @ sizered = $sizered / 2
    @ reduce++
end

# Get starting and ending section numbers
#
if ($zsea != "") then
    set zsetmp = `echo $zsea | sed 's/,/ /'`
    @ asecstr = $zsetmp[1]
    @ asecend = $zsetmp[2]
    @ asecstr--
    @ asecend--
else
    @ asecstr = 0
    @ asecend = $nza - 1
endif

if ($zseb != "") then
    set zsetmp = `echo $zseb | sed 's/,/ /'`
    @ bsecstr = $zsetmp[1]
    @ bsecend = $zsetmp[2]
    @ bsecstr--
    @ bsecend--
else
    @ bsecstr = 0
    @ bsecend = $nzb - 1
endif

#
# Check section numbers
# 
if ($asecstr < 0 || $asecend >= $nza) then
    echo "ERROR: $pn - The starting or ending section numbers for A are out of range ($asecstr and $asecend)"
    exit 1
endif
if ($bsecstr < 0 || $bsecend >= $nzb) then
    echo "ERROR: $pn - The starting or ending section numbers for B are out of range ($bsecstr and $bsecend)"
    exit 1
endif

#
# Set up lists to do sections from center out
#
@ zeroa = ($asecstr + $asecend) / 2
@ zerob = ($bsecstr + $bsecend) / 2
set aseclist = ($zeroa)
set bseclist = ($zerob)
@ nviewa = 3 + $asecend - $asecstr
@ nviewb = 3 + $bsecend - $bsecstr
if ($nviewa < $nviewb) @ nviewa = $nviewb
@ incr = 1
@ count = 1
while ($count <= $nviewa)
    @ asec = $zeroa + $incr
    @ bsec = $zerob + $incr
    if ($asec >= $asecstr && $asec <= $asecend) set aseclist = ($aseclist $asec)
    if ($bsec >= $bsecstr && $bsec <= $bsecend) set bseclist = ($bseclist $bsec)
    if ($incr > 0) then
	@ incr = - ($incr)
    else
	@ incr = 1 - ($incr)
    endif
    @ count++
end

#
# Set up scaling based on range of density in B
#
set densities = `header $imageb | sed -n '/mum dens/p'`
set diffscale = `echo 1000. $densities[4] $densities[8] | awk '{print $1 / ($3 - $2)}'`

#
# set up for midas
#
if ($midas) then
    if ($pmend != $pmstart) set pmend = 0
else
    echo "Finding the best matched pair of views in the two series:"
    echo "              (Type Ctrl-C to end search)"
endif


#
# Loop on section from b, section from a, and -/+90 rotations
#
@ diffmin = 2000000000
@ pluswin = 0
@ minuswin = 0
@ bsecind = 1
while ($bsecind <= $#bseclist)
    @ bsec = $bseclist[$bsecind]
    @ asecind = 1
    while ($asecind <= $#aseclist)
	@ asec = $aseclist[$asecind]
	@ plusminus = $pmstart
	set pmdiffs = ()
	while ($plusminus <= $pmend)
	    if ($plusminus) then
		\echo "0 -1 1 0 -1 0" >! $tmprot90
		set pmangle = +90
	    else
		\echo "0 1 -1 0 0 -1" >! $tmprot90
		set pmangle = -90
	    endif
	    # 
	    # extract the rotated section from A
	    #
            newstack -sec $asec -size $nxb,$nyb -xf $tmprot90 $distort $imbin -use 0 $imagea $tmpimga >! $tmperrlog
	    if ($status) then
		grep ERROR $tmperrlog
		echo "ERROR: Matchrotpairs - extracting rotated section from A"
		goto clean
	    endif
            newstack -sec $bsec $distort $imbin -use 0 $imageb $tmpimgb >! $tmperrlog
	    #
	    # Stack this rotated section on top of the sec from b
	    #
            newstack $tmpimgb $tmpimga $tmpstack >! $tmperrlog
	    if ($status) then
		grep ERROR $tmperrlog
		echo "ERROR: Matchrotpairs - Stacking rotated A on B"
		goto clean
	    endif
	    if ($midas) then
		if ($asecind == 1 && $bsecind == 1) then
		    # 
		    # first time, run midas
		    # set box to 1 in case a 180 rotation is needed
		    #
		    echo "Starting midas - you should align translation and rotation,"
		    echo " and save the transform to the already-defined output file"
		    echo " "
		    sleep 3
		    midas -D -b 1 $tmpstack $tmpmidxf
		    if (! -e $tmpmidxf) then
			echo "ERROR: Matchrotpairs - Transform file not found - cannot proceed"
			goto clean
		    endif
		    tail -n 1 $tmpmidxf >! $tmpxf1
		    echo "Finding the best matched pair of views in the two series:"
		    echo "              (Type Ctrl-C to end search)"

		endif
	    else
		#
		# Run tiltxcorr
		#
tiltxcorr -angles 0,0 -radius2 $radius2 -sigma1 $sigma1 -sigma2 $sigma2 $tmpstack $tmpxcxf >! $tmperrlog
		if ($status) then
		    grep ERROR $tmperrlog
		    echo "ERROR: Matchrotpairs - Running Tiltxcorr"
		    goto clean
		endif
		#
		# Run xfsimplex looking for rotation only
		#
		#	    echo "first simplex"
		tail -n 1 $tmpxcxf >! $tmpxfin
xfsimplex <<EOF  >! $tmperrlog
$tmpstack
$tmpimga
$tmpxf1
$tmpxfin
,,,,,0
3
/
/
$reduce
0
0
EOF
		if ($status) then
		    grep ERROR $tmperrlog
		    echo "ERROR: Matchrotpairs - Running first Xfsimplex"
		    goto clean
		endif
	    endif
	    #
	    # Run xfsimplex again from there, looking for full transform
	    #
#echo "second simplex"
xfsimplex  >! $tmpxflog <<EOF
$tmpstack
$tmpimga
$tmpxf2
$tmpxf1
/
0
/
/
$reduce
0
0
EOF
	    if ($status) then
		grep ERROR $tmpxflog
		echo "ERROR: Matchrotpairs - Running second Xfsimplex"
		goto clean
	    endif

	    # 
	    # extract the difference from the log file
	    # 
	    set simplexout = `tail -n 1 $tmpxflog`
	    @ diff = `echo $simplexout[2] $diffscale | awk '{print int($1 * $2)}'`
	    @ aview = $asec + 1
	    @ bview = $bsec + 1
	    echo -n "A $aview  B $bview  rotation $pmangle  difference $diff"
	    if ($diff < $diffmin) then
		#
		# If new minimum, save sections and real transform
		echo '*'
		@ diffmin = $diff
		@ asecbest = $asec
		@ bsecbest = $bsec
                xfproduct $tmprot90 $tmpxf2 $tmpminxf >! $tmperrlog
		if ($status) then
		    grep ERROR $tmperrlog
		    echo "ERROR: Matchrotpairs - Running Xfproduct"
		    goto clean
		endif
	    else
		echo ' '
	    endif
	    #
	    # Accumulate differences from plus and minus
	    #
	    set pmdiffs = ($pmdiffs $diff)
	    @ plusminus++
	end
	#
	# If there are both plus and minus, count who wins
	# and stop doing a consistent loser
	#
	if ($#pmdiffs == 2) then
	    if ($pmdiffs[1] < $pmdiffs[2]) @ minuswin++
	    if ($pmdiffs[1] > $pmdiffs[2]) @ pluswin++
	    if ($pluswin >= $minuswin + $DIRECTION_WIN_THRESH) set pmstart = 1
	    if ($minuswin >= $pluswin + $DIRECTION_WIN_THRESH) set pmend = 0
	endif
	@ asecind++
    end
    @ bsecind++
end

searchdone:
onintr clean

#
# Stack the two best sections
#
\echo "1 0 0 1 0 0" >! $outfile
cat $tmpminxf >> $outfile
newstack -sec $bsecbest -sec $asecbest -float 2 $distort $imbin $imageb $imagea $beststack >! $tmperrlog
if ($status) then
    grep ERROR $tmperrlog
    echo "ERROR: Matchrotpairs - Stacking two best views"
    goto clean
endif


clean:
if ($leavetmp == 0) then
    \rm -f $tmpdir/$com.*.$$*
else
    echo "Temporary files left in $tmpdir"
endif
exit 0

usage:
cat <<EOF
Usage: $pn [options] image_file_a image_file_b output_file
   Will search for the best matching pair of sections between file A and file 
   B and output a transformation aligning the two, as well as a stack 
   containing the best two sections, possibly undistorted.
   Options:
     -za #,#       Starting & ending sections in A to search (numbered from 1) 
     -zb #,#       Starting & ending sections in ABto search
     -a #          Rotation direction or angle to search (+1, -1, +90, -90
                      all work, default is to search both directions)
     -d file       Name of (zero-stretch) distortion field file to apply
     -b #          Binning of images, needed if undistorting
     -m            Run Midas to set initial translational/rotational alignment
     -t            Leave temporary files in $tmpdir
     -P            Output process ID (PID)
     -h            Help - print this usage
EOF
exit 1
