#! /bin/csh -f
# default setting for entering flipped versus unflipped coordinates, index
# versus imod coordinates
set flipyz = "0"
set index = "0"
set pn = "trimvol"
set doflip = "0"

if ($#argv == 0)then
  echo "Usage: $pn [options] input_file output_file"
cat <<EOF
  Can trim out a subset of a volume, determine scaling, and convert to bytes
  Options:
     -x start,end    Starting and ending X coordinate of region to cut out
     -y start,end    Starting and ending Y coordinate of region to cut out
     -z start,end    Starting and ending Z coordinate of region to cut out
     -nx x_size      Size to cut out in X, around center X coordinate
     -ny y_size      Size to cut out in Y, around center Y coordinate
     -nz z_size      Size to cut out in Z, around center Z coordinate
     -c black,white  Contrast levels for scaling and converting to bytes
     -s start,end    Starting and ending slices (section # in flipped volume)
                           to use to find contrast levels for scaling to bytes
     -yz             Flip Y and Z in output volume
     -i              Treat as index coordinates (numbered from 0) rather than
                           as Imod coordinates (numbered from 1, the default)
     -f              Treat coordinates as coming from a flipped volume

  Notes:
     You cannot use both -x and -nx; -y and -ny; -z and -nz; or -c and -s.
     If a size or starting and ending coordinates are not entered, the default
            is the full size for that dimension.
     If you use the -c or -s option, the output file will be bytes; otherwise
            the output file will have the same mode as the input file.
EOF
  exit 0
endif

if ($?IMOD_DIR) set path = ($IMOD_DIR/bin $path)

while ($#argv > 2)
  switch ($argv[1])
    case -x:
      set ix = $argv[2]
      shift; shift
      breaksw
    case -y:
      set iyt = $argv[2]
      shift; shift
      breaksw
    case -z:
      set izt = $argv[2]
      shift; shift
      breaksw
    case -nx:
      set inx = $argv[2]
      shift; shift
      breaksw
    case -ny:
      set inyt = $argv[2]
      shift; shift
      breaksw
    case -nz:
      set inzt = $argv[2]
      shift; shift
      breaksw
    case -c:
      set contrast = $argv[2]
      shift; shift
      breaksw
    case -s:
      set slices = $argv[2]
      shift; shift
      breaksw
    case -yz:
      set doflip = "1"
      shift
      breaksw
    case -f:
      set flipyz = "1"
      shift
      breaksw
    case -u:
      set flipyz = "0"
      shift
      breaksw
    case -i:
      set index = "1"
      shift
      breaksw
    default:
      echo "${pn}: bad argument $argv[1]"
      exit 1
  endsw
end
if (! -e $argv[1])then
  echo "${pn}: input file $argv[1] does not exist"
  exit 1
endif

if ($?slices && $?contrast) then
    echo "${pn}: cannot use both -c and -s options"
    exit 1
endif

if ($?ix && $?inx) then
    echo "${pn}: cannot use both -x and -nx options"
    exit 1
endif

if ($?iyt && $?inyt) then
    echo "${pn}: cannot use both -y and -ny options"
    exit 1
endif

if ($?izt && $?inzt) then
    echo "${pn}: cannot use both -z and -nz options"
    exit 1
endif

if ($flipyz == "0") then
    if ($?iyt) then
	set iy = $iyt
    endif
    if ($?izt) then
	set iz = $izt
    endif
    if ($?inyt) then
	set iny = $inyt
    endif
    if ($?inzt) then
	set inz = $inzt
    endif
else
    if ($?iyt) then
	set iz = $iyt
    endif
    if ($?izt) then
	set iy = $izt
    endif
    if ($?inyt) then
	set inz = $inyt
    endif
    if ($?inzt) then
	set iny = $inzt
    endif
endif

set nxyz =  `header $argv[1] | sed -n '/rows, sections/p'| awk '{print $7, $8, $9}'`

@ nx = $nxyz[1]
@ ny = $nxyz[2]
@ nz = $nxyz[3]

@ xsize = $nx
@ ysize = $ny
@ xoffset = 0
@ yoffset = 0

if ($?inx) then
    @ xsize = $inx
    if ($xsize <= 0 || $xsize > $nx) then
	echo "${pn}: illegal x size in -nx $inx"
	exit 1
    endif
endif

if ($?ix) then
    set xentry = `echo $ix | sed 's/,/ /g'`
    if ($#xentry < 2) then
	echo "${pn}: incorrect argument -x $ix"
	exit 1
    endif
    @ xst = $xentry[1]
    @ xnd = $xentry[2]
    if ($index == "0") then
	@ xst--
	@ xnd--
    endif
    if ($xst < 0 || $xnd >= $nx || $xst > $xnd) then
	echo "${pn}: coordinates out of range for file in -x $ix"
	exit 1
    endif

    @ xsize = $xnd + 1 - $xst
    @ xoffset = ($xst + $xnd + 1 - $nx) / 2
endif

set inlet = "y"
if ($flipyz == "1") set inlet = "z"

if ($?iny) then
    @ ysize = $iny
    if ($ysize <= 0 || $ysize > $ny) then
	echo "${pn}: illegal $inlet size in -n$inlet $iny"
	exit 1
    endif
endif

if ($?iy) then
    set yentry = `echo $iy | sed 's/,/ /g'`
    if ($#yentry < 2) then
	echo "${pn}: incorrect argument -$inlet $iy"
	exit 1
    endif
    @ yst = $yentry[1]
    @ ynd = $yentry[2]
    if ($index == "0") then
	@ yst--
	@ ynd--
    endif
    if ($yst < 0 || $ynd >= $ny || $yst > $ynd) then
	echo "${pn}: $inlet coordinates out of range for file in -$inlet $iy"
	exit 1
    endif

    @ ysize = $ynd + 1 - $yst
    @ yoffset = ($yst + $ynd + 1 - $ny) / 2
endif

set inlet = "y"
if ($flipyz == "0") set inlet = "z"
set secout = ""

if ($?inz) then
    @ zsize = $inz
    if ($zsize <= 0 || $zsize > $nz) then
	echo "${pn}: illegal $inlet size in -n$inlet $inz"
	exit 1
    endif
    @ zst = ($nz - $zsize) / 2
    @ znd = $zst + $zsize - 1
    set secout = "-sec $zst-$znd"
endif

if ($?iz) then
    set zentry = `echo $iz | sed 's/,/ /g'`
    if ($#zentry < 2) then
	echo "${pn}: incorrect argument -$inlet $iz"
	exit 1
    endif
    @ zst = $zentry[1]
    @ znd = $zentry[2]
    if ($index == "0") then
	@ zst--
	@ znd--
    endif
    if ($zst < 0 || $znd >= $nz || $zst > $znd) then
	echo "${pn}: $inlet coordinates out of range for file in -$inlet $iz"
	exit 1
    endif
    set secout = "-sec $zst-$znd"
endif

set contout = ""
if ($?contrast) then
    set contout = "-mo 0 -co $contrast"
endif

set newstout = $argv[2]
if ($doflip == "1") set newstout = $argv[1].tmp.$$

if ($?slices) then
    set contslice = `echo $slices | sed 's/,/ /g'`
    if ($#contslice < 2) then
	echo "${pn}: incorrect argument -s $slices"
	exit 1
    endif
    @ slicest = $contslice[1]
    @ slicend = $contslice[2]
    if ($slicest < 1 || $slicend > $ny || $slicest > $slicend) then
	echo "${pn}: slices out of range for file in -s $slices"
	exit 1
    endif
    echo $slicest,$slicend
    set tmpfil = /tmp/trimvol.$$
    onintr clean
    echo "Determining byte scaling of $argv[1] ..."
    findcontrast > $tmpfil <<EOF
$argv[1]
$slicest,$slicend
/
/
EOF
    set bwout = `sed -n '/Implied/s/Imp.*are *//p' $tmpfil`
    \rm -f $tmpfil
    if ($#bwout != 3) then
	echo 'findcontrast failed to return scaling values'
	exit 1
    endif

    set contout = "-mo 0 -co $bwout[1],$bwout[3]"
endif

newst -si $xsize,$ysize -of $xoffset,$yoffset $contout $secout $argv[1] $newstout

if ($?slices) then
    echo " "
    echo "Contrast black/white levels determined from file were $bwout[1],$bwout[3]"
endif
echo " "
echo "The newstack command was:"
echo "newst -si $xsize,$ysize -of $xoffset,$yoffset $contout $secout $argv[1] $newstout"

if ($doflip == "1") then
    echo "Flipping Y and Z..."
    clip flipyz $newstout $argv[2]
    \rm -f $newstout
endif

exit 0

clean:
\rm -f $tmpfil
exit 1
