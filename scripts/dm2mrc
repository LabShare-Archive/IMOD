#! /bin/csh -f
# A script to convert Digital Micrograph files of version 2 from Mac, version
# 2 exported from a PC running version 3, and version 3
#
#  $Author$
#
#  $Date$
#
#  $Revision$
#
#  $Log$
#  Revision 3.7  2005/05/08 03:11:24  mast
#  Use hexdump instead of od if it exists; it's needed on Mac
#
#  Revision 3.6  2004/08/27 05:46:12  mast
#  Switched to head -n
#
#  Revision 3.5  2004/06/06 00:48:12  mast
#  Added options for dealing with long and unsigned data better
#
#  Revision 3.4  2003/10/24 02:14:00  mast
#  source settmpdir to get tmpdir, better for Windows
#
#  Revision 3.3  2003/06/20 20:04:28  mast
#  Let tmpdir be defined and fall back to /tmp if /usr/tmp does not exist
#
#  Revision 3.2  2002/01/07 18:21:58  mast
#  Change usage output to say dm2mrc, not dm3mrc
#
#  Revision 3.1  2001/12/31 19:18:58  mast
#  Addition to IMOD suite
#

set tmpdir = /usr/tmp
if ($?IMOD_DIR) then
    set path = ($IMOD_DIR/bin $path)
    if (-e $IMOD_DIR/bin/settmpdir) source $IMOD_DIR/bin/settmpdir
endif

if ($#argv < 2) then
cat <<EOF
Usage: dm2mrc [options] Input_files Output_file
  Options:
    -d    Files may have different headers, sizes, or types so scan each 
             one for header offset, size, and type
    -s    Treat unsigned data as signed (use if < 32768)
    -r    Reduce (divide by 2) unsigned 16-bit data or 32-bit integer data
    -u    Save unsigned data in unsigned 16-bit file mode
    -c    Convert 32-bit integer data to 16-bit integers instead of floats
EOF
	exit 0
endif

set scan = 0
set divide
set convert
set unsigned
set done = 0
set signed = 0
@ signopt = 0

while ($#argv > 2 && $done == 0)
    switch ($argv[1])
    case -d:
        set scan = 1
        shift
        breaksw

    case -c:
        set convert = "-c"
        shift
        breaksw

    case -r:
        set divide = "-d"
        @ signopt++
        shift
        breaksw

    case -u:
        set unsigned = "-u"
        @ signopt++
        shift
        breaksw

    case -s:
        set signed = 1
        @ signopt++
        shift
        breaksw

    default:
        set done = 1
        breaksw
    endsw
end

if ($signopt > 1) then
    echo "You can enter only one of -r, -u, and -s"
    exit 1
endif

# Build a wordlist of critical values if we do scan the data

set xsizes = ( )
set ysizes = ( )
set dmtypes = ( )
set offsets = ( )

set differ = 0
set sizedif = 0
set typedif = 0
set swap = 0
set dm2 = 0
set dm3 = 0
set test = `which hexdump`
set useod = $status

# Read first file or all files

@ num = 1
@ end = 2
if ($scan == 1) @ end = $#argv
while ($num < $#argv)

    # Byte dump is most easily interpreted, short decimal dump is used to
    # detect if swapping is needed

    if ($useod) then
        set header = `od -t u1 $argv[$num] | head -n 2`
        if ("$swap" == 0) set ddump = `od -d $argv[1] | head -n 1`
    else
        set header = `hexdump -e '"%07.7_ao  " 16/1 "%3u " "\n"' $argv[$num] | head -n 2`
        if ("$swap" == 0) set ddump = `hexdump -d $argv[1] | head -n 1`
    endif
    @ byte2 = $header[3]
    @ byte4 = $header[5]

    if ($byte2 == 61) then
	
	# Old DM 2 format

	if ("$swap" == 0) then
	    @ word1 = $ddump[2]
	    set swap = ""
	    if ($word1 != 61) set swap = "-s"
	endif

	@ xsize1 = $header[19]
	@ ysize1 = $header[21]
	@ xsize2 = $header[20]
	@ ysize2 = $header[22]
	@ xsizet = 256 * $xsize1 + $xsize2
	@ ysizet = 256 * $ysize1 + $ysize2
	@ dmtypet = $header[26]
	set props = ($xsizet $ysizet $dmtypet 24)
	set dm2 = 1

    else if ($byte2 == 255) then

	# New DM 2 format

	if ("$swap" == 0) then
	    @ word8 = $ddump[8]
	    set swap = ""
	    if ($word8 > 100) set swap = "-s"
	endif

	@ xsize1 = $header[8]
	@ ysize1 = $header[10]
	@ xsize2 = $header[9]
	@ ysize2 = $header[11]
	@ xsizet = 256 * $xsize1 + $xsize2
	@ ysizet = 256 * $ysize1 + $ysize2
	@ dmtypet = $header[15]
	set props = ($xsizet $ysizet $dmtypet 14)
	set dm2 = 1

    else if ($byte4 == 3) then

	# DM3 format
	
	if ("$swap" == 0) then
	    @ word2 = $ddump[3]
	    set swap = ""
	    if ($word2 == 3) set swap = "-s"
	endif

	set props = `dm3props $argv[$num]`
	set dm3 = 1

    else
	echo "$argv[$num] is not recognized as a DM file"
	exit 1
    endif

    # add properties to wordlists, and check for consistency

    set xsizes = ($xsizes $props[1])
    set ysizes = ($ysizes $props[2])
    set dmtypes = ($dmtypes $props[3])
    set offsets = ($offsets $props[4])
    if ($num > 1) then
	if ($props[1] != $xsize || $props[2] != $ysize) set sizedif = 1
	if ($props[3] != $dmtype) set typedif = 1
	if ($props[4] != $offset) set differ = 1
    else
	set xsize = $props[1]
	set ysize = $props[2]
	set dmtype = $props[3]
	set offset = $props[4]
    endif

    @ num++
end

if ($sizedif == 1 || $typedif == 1) set differ = 1
if ($sizedif == 1) echo 'Warning: images are not all of the same dimensions'
if ($typedif == 1) echo 'Warning: images are not all of the same data type'
if ($dm2 == 1 && $dm3 == 1) then
    echo "You can not stack both DM2 and DM3 files in one operation"
    exit 1
endif

# scan the types next, build a list of them too

@ num = 1
@ end = 2
if ($differ == 1) @ end = $#argv
set types = ( )
while ($num < $end)
    switch ($dmtypes[$num])
	case "6":
	    set type = "byte"
	    breaksw
	case "9":
	    set type = "sbyte"
	    breaksw
	case "10"
	    set type = "ushort"
            if ($signed == 1) set type = "short"
	    breaksw
	case "1"
	    set type = "short"
	    breaksw
	case "11"
	    set type = "ulong"
            if ($signed == 1) set type = "long"
	    breaksw
	case "7"
	    set type = "long"
	    breaksw
	case "2"
	    set type = "float"
	    breaksw
	default:
	    echo "Unrecognized data type for file $argv[$num]"
	    exit 1
	    breaksw
    endsw
    set types = ($types $type)
    @ num++
end

# make a backup file if output exists

if (-e $argv[$#argv]) then
    \mv $argv[$#argv] $argv[$#argv]~
    echo "Output file $argv[$#argv] already exists - saving it as $argv[$#argv]~"
endif

# No differences: all in one operation

if ($differ == 0) then
    raw2mrc -f -o $offset $swap -t $type -x $xsize -y $ysize $convert $divide \
      $unsigned $argv
    exit 0
endif

onintr clean

# Otherwise, loop and convert each one to temp file, then stack the temp files

@ i = 1
@ num = $#argv - 1;
set newstfil = $tmpdir/dmnewst.$$
echo $num >! $newstfil

while ($i < $#argv)
    set outfil = $tmpdir/$argv[$i].$$
    raw2mrc -f -o $offsets[$i] $swap -t $types[$i] -x $xsizes[$i] \
      -y $ysizes[$i] $convert $divide $unsigned $argv[$i] $outfil
    echo $outfil >> $newstfil
    echo 0 >> $newstfil
    @ i++
end



cat <<EOF >> $newstfil
1
$argv[$#argv]
/
/
0
0
-1
1,1
EOF

echo Stacking temporary files...
newstack < $newstfil > /dev/null

clean:
\rm -f $tmpdir/*.$$

