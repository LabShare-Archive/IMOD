#! /bin/csh -f
# MATCHORWARP: script to run refinewarp and matchvol if fit is good enough
# or findwarp with progressively worse criteria, then warpvol

#  $Author$
#
#  $Date$
#
#  $Revision$
#
#  $Log$


set patchfile = "patch.out"
set solvefile = "solve.xf"
set refinefile = "refine.xf"
set warpfile = "warp.xf"
set inversefile = "inverse.xf"
set refinelimit = "0.3"
set warplimit = "0.2,0.27,0.35"
set modelfile = ""
set sizein = ""
set tempdir = ""
set xlower = "0"
set zlower = "0"
set xupper = "0"
set zupper = "0"
set trial = ""
set pn = "matchorwarp"
if ($?IMOD_DIR) set path = ($IMOD_DIR/bin $path)

if ($#argv == 0) then
cat <<EOF
Usage: ${pn} [options] input.file output.file
      Will find transforms using REFINEMATCH or FINDWARP and transform
        the input.file to the output.file using MATCHVOL or WARPVOL
      Options are: 
 -size size                Where size is a filename or NX,NY,NZ values
 -patchfile patch_file     File of patch displacements (default ($patchfile)
 -modelfile model_file     Model file defining patches to include
 -refinelimit #            Mean residual limit for using refinematch and
                             matchvol (default $refinelimit)
 -warplimit #,#,...        Mean residual limits which findwarp will try to
                             achieve, or 0 not to warp (default $warplimit)
 -solvefile solve_file     Initial transform file (default $solvefile)
 -refinefile refine_file   Refining transform file (default $refinefile)
 -inversefile inverse_file Inverse transform file (default $inversefile)
 -warpfile warp_file       Warp transform file (default $warpfile)
 -tempdir temp_directory   Directory for temporary files
 -xlowerexclude #          Columns to exclude on the left side
 -xupperexclude #          Columns to exclude on the right side
 -zlowerexclude #          Rows to exclude at high Z
 -zupperexclude #          Rows to exclude at low Z
 -trial                    Run Refinewarp/Findwarp but not Matchvol/Warpvol
EOF
exit 0
endif
while ($#argv > 2)
  switch ($argv[1])
    case -si*:
      set sizein = $argv[2]
      shift; shift
      breaksw
    case -pa*:
      set patchfile = $argv[2]
      shift; shift
      breaksw
    case -mo*:
      set modelfile = $argv[2]
      if (! -e $modelfile)then
	echo "${pn}: model file does not exist"
	exit 1
      endif
      shift; shift
      breaksw
    case -so*:
      set solvefile = $argv[2]
      shift; shift
      breaksw
    case -refinef*:
      set refinefile = $argv[2]
      shift; shift
      breaksw
    case -warpf*:
      set warpfile = $argv[2]
      shift; shift
      breaksw
    case -in*:
      set inversefile = $argv[2]
      shift; shift
      breaksw
    case -refinel*:
      set refinelimit = $argv[2]
      shift; shift
      breaksw
    case -warpl*:
      set warplimit = $argv[2]
      shift; shift
      breaksw
    case -te*:
      set tempdir = $argv[2]
      shift; shift
      breaksw
    case -xl*:
      set xlower = $argv[2]
      shift; shift
      breaksw
    case -xu*:
      set xupper = $argv[2]
      shift; shift
      breaksw
    case -zl*:
      set zlower = $argv[2]
      shift; shift
      breaksw
    case -zu*:
      set zupper = $argv[2]
      shift; shift
      breaksw
    case -tr*
      set trial = "1"
      shift
      breaksw

    default:
      echo "ERROR: matchorwarp - bad argument $argv[1]"
      exit 1
  endsw
end
set recfile = $argv[1]
set matfile = $argv[2]
if (! -e $recfile)then
  echo "${pn}: input file $recfile does not exist"
  exit 1
endif
if (! -e $patchfile)then
  echo "${pn}: input file $patchfile does not exist"
  exit 1
endif
if (! -e $solvefile)then
  echo "${pn}: input file $solvefile does not exist"
  exit 1
endif

# set up size variable; use mat file if none entered
if ($sizein == "") then
    set sizein = $matfile
    if (! -e $sizein) then
	echo "${pn}: cannot deduce size; $matfile does not exist"
	exit 1
    endif
endif

# If it is not an existing file, use as is and hope it is numbers
# if it is a file, get the nx, ny, nz of it
if (! -e $sizein) then
    set size = $sizein
else
    set size = `header $sizein | sed -n '/rows, sections/p'| awk '{print $7, $8, $9}'`
endif

# Run refinematch

echo "MATCHORWARP: RUNNING REFINEMATCH TO TRY TO FIND SINGLE TRANSFORMATION"

refinematch <<EOF
$patchfile
$size
$modelfile
$refinelimit
$refinefile
EOF

set savestat = $status
if ($savestat == 1) exit 1

if (! $savestat) then

    echo " "
    if ($trial == "1") then
	echo "MATCHORWARP: REFINEMATCH FOUND A GOOD TRANSFORMATION"
	exit 0
    endif

    # If refinematch did not have error exit, run matchvol

    echo "MATCHORWARP: REFINEMATCH FOUND A GOOD TRANSFORMATION: NEXT RUNNING MATCHVOL"
    echo " "


    matchvol <<EOF
$recfile
$matfile
$tempdir
$size
2
$solvefile
$refinefile
$inversefile
EOF
    exit 0

endif

# If there is an error exit, run findwarp as long as warplimit not 0
if ($warplimit == "0" || $warplimit == "0." || $warplimit == ".0" \
	|| $warplimit == "0.0") exit 1

set warplist = `echo $warplimit | sed 's/,/ /g'`

set lastwarp = $warplist[$#warplist]

# Try one limit after another

while ($#warplist)
    echo " "
    echo "MATCHORWARP: RUNNING FINDWARP TO FIND A WARPING WITH A RESIDUAL LIMIT OF $warplist[1]"
    findwarp <<EOF
$patchfile
$size
$modelfile
1
$warplist[1]
/
1
$xlower,$xupper
0,0
$zlower,$zupper
$solvefile
$warpfile
EOF
    set savestat = $status

    if ($savestat == 1) exit 1

    # If succeed, run warpvol
    if (! $savestat) then
	echo " "
	if ($trial == "1") then
	    echo "MATCHORWARP: FINDWARP FOUND A GOOD WARPING"
	    exit 0
	endif

	echo "MATCHORWARP: FINDWARP FOUND A GOOD WARPING: NEXT RUNNING WARPVOL"
	echo " "
	warpvol <<EOF
$recfile
$matfile
$tempdir
$size
$warpfile
EOF

	exit 0
    endif
    shift warplist
end

# IF get out of loop, it's all over
echo " "
echo "MATCHORWARP: FINDWARP COULD NOT FIND WARPING WITH RESIDUAL UNDER $lastwarp"
echo "YOU NEED TO GET BETTER PATCHES, EDIT PATCHES, ELIMINATE ROWS OR COLUMNS,"
echo "  OR RUN FINDWARP INTERACTIVELY"
exit 1
