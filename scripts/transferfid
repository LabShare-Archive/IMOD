#! /bin/csh -f
# transferfid will find best matching pair of views between two tilt series
# and transfer the fiducial model from one to make a seed model for the other

#  $Author$
#
#  $Date$
#
#  $Revision$
#  Log at end
#

nohup

# Filter for tiltxcorr
set sigma1 = 0.03
set sigma2 = 0.05
set radius2 = 0.25

# Number of wins more in one rotation direction than the other that will
# make it abandon the other direction
@ DIRECTION_WIN_THRESH = 4

# Line number of beadtrack input for input file, # of reshoot lines,
# and bead radius when there are no reshoot lines
@ BEADTRACK_INPUTFILE_LINE = 1
@ BEADTRACK_RESHOOT_LINE = 7
@ BEADTRACK_RADIUS_LINE = 13

set tmpdir = /usr/tmp
if ($?IMOD_DIR) then
    setenv PATH "$IMOD_DIR/bin:$PATH"
    if (-e $IMOD_DIR/bin/settmpdir) source $IMOD_DIR/bin/settmpdir
endif

onintr searchdone

#
# set names of temp files
#
set pn      = transferfid
set com        = $pn:t
set tmpstack   = $tmpdir/$com.stack.$$
set tmpimga    = $tmpdir/$com.imga.$$
set tmpxcxf    = $tmpdir/$com.xcxf.$$
set tmpxfin    = $tmpdir/$com.xfin.$$
set tmpxf1    = $tmpdir/$com.xf1.$$
set tmpxf2    = $tmpdir/$com.xf2.$$
set tmprot90    = $tmpdir/$com.rot90.$$
set tmpminxf    = $tmpdir/$com.minxf.$$
set tmptwoxf    = $tmpdir/$com.twoxf.$$
set tmpxflog    = $tmpdir/$com.xflog.$$
set tmpbtlog    = $tmpdir/$com.btlog.$$
set tmprplog    = $tmpdir/$com.rplog.$$
set tmpclip    = $tmpdir/$com.clip.$$
set tmpxfmod    = $tmpdir/$com.xfmod.$$
set tmpseed    = $tmpdir/$com.seed.$$
set tmpmap1    = $tmpdir/$com.map1.$$
set tmpmap2    = $tmpdir/$com.map2.$$
set tmpmap3    = $tmpdir/$com.map3.$$
set tmpmidxf   = $tmpdir/$com.midxf.$$
set tmperrlog    = $tmpdir/$com.errlog.$$

#
# set default set name from current directory - NOT ANY MORE
# 
#set cwd = `pwd`
#set setname = $cwd:t

#
# set other defaults or values to indicate no argument was entered
#
set radius = ""
@ nviews = 5
set imagea = ""
set imageb = ""
set fidfile = ""
set zeroa = ""
set zerob = ""
set lightdark = 0
set outfile = ""
set pmstart = 0
set pmend = 1
set leavetmp = 0
set midas = 0
set src = a
set dst = b
set AA = A
set BB = B
set ifbtoa = 0
set correspond = ""

if ($#argv < 1) goto usage

while ($#argv > 1)
  switch ($argv[1])
#    case -s:
#      set setname = $argv[2]
#      shift; shift
#      breaksw
    case -ia:
      set imagea = $argv[2]
      shift; shift
      breaksw
    case -ib:
      set imageb = $argv[2]
      shift; shift
      breaksw
    case -f:
      set fidfile = $argv[2]
      shift; shift
      breaksw
    case -n:
      @ nviews = $argv[2]
      shift; shift
      breaksw
    case -za:
      @ zeroa = $argv[2]
      shift; shift
      breaksw
    case -zb:
      @ zerob = $argv[2]
      shift; shift
      breaksw
    case -r:
      set radius = $argv[2]
      shift; shift
      breaksw
    case -o:
      set outfile = $argv[2]
      shift; shift
      breaksw
    case -c:
      set correspond = $argv[2]
      shift; shift
      breaksw
    case -a:
      @ angle = $argv[2]
      if ($angle < 0) set pmend = 0
      if ($angle > 0) set pmstart = 1
      shift; shift
      breaksw
    case -l:
      set lightdark = 1
      shift
      breaksw
    case -t:
      set leavetmp = 1
      shift
      breaksw
    case -m:
      set midas = 1
      shift
      breaksw
    case -b:
      set src = b
      set dst = a
      set AA = B
      set BB = A
      set ifbtoa = 1
      shift
      breaksw
    case -h:
      goto usage
    case -P:
      echo2 Shell PID: $$
      shift
      breaksw
    default:
      echo "ERROR: ${pn} - bad argument $argv[1]"
      goto usage
  endsw
end

set setname = $argv[1]

if ($nviews < 1) then
    echo "ERROR: $pn - The number of views to sample must be at least 1; you entered $nviews"
    exit 1
endif

#
# swap inputs for filename and center z's if going backwards
#
if ($src == "b") then
    set tmp = $imagea
    set imagea = $imageb
    set imageb = $tmp
    set tmp = $zeroa
    set zeroa = $zerob
    set zerob = $tmp
endif

#
# check existence of files needed
#

if (($imagea == "" || $radius == "") && (! -e track$src.com)) then
    echo "ERROR: $pn - track$src.com not found - it is needed unless you enter both "
    echo " the $AA image file with -i$src and the bead radius with -r"
    exit 1
endif

if ($imageb == "" && (! -e track$dst.com)) then
    echo "ERROR: $pn - track$dst.com not found - it is needed unless you enter"
    echo " the $BB image file with -i$dst"
    exit 1
endif

set tiltfilea = ${setname}$src.rawtlt
set tiltfileb = ${setname}$dst.rawtlt
if ($zeroa == "" && (! -e $tiltfilea)) then
    echo "ERROR: $pn - $tiltfilea not found - it is needed unless you enter"
    echo " the zero-tilt view number for $AA with -z$src"
    exit 1
endif
if ($zerob == "" && (! -e $tiltfileb)) then
    echo "ERROR: $pn - $tiltfileb not found - it is needed unless you enter"
    echo " the zero-tilt view number for $BB with -z$dst"
    exit 1
endif

#
# Get the image file names if they don't exist already
#
if ($imagea == "") then
    set test = `grep 'beadtrack.*-StandardInput' track$src.com`
    if ($status) then
        @ topline  = `vmstocsh < track$src.com | awk '/beadtrack/{print NR}'`
        @ nextline = $topline + $BEADTRACK_INPUTFILE_LINE
        set imagea = `vmstocsh < track$src.com | awk '{if (NR==LINE) print}' LINE=$nextline | sed '/[[:cntrl:]]/s///g'`
    else
        set imagea = `sed -n '/^ImageFile/s/ImageFile[ 	]*//p' track$src.com | sed '/[[:cntrl:]]/s///g'`
    endif
endif

if (! -e $imagea) then
    echo "ERROR: $pn - Image file $imagea does not exist"
    exit 1
endif

if ($imageb == "") then
    set test = `grep 'beadtrack.*-StandardInput' track$dst.com`
    if ($status) then
        @ topline  = `vmstocsh < track$dst.com | awk '/beadtrack/{print NR}'`
        @ nextline = $topline + $BEADTRACK_INPUTFILE_LINE
        set imageb = `vmstocsh < track$dst.com | awk '{if (NR==LINE) print}' LINE=$nextline | sed '/[[:cntrl:]]/s///g'`
    else
        set imageb = `sed -n '/^ImageFile/s/ImageFile[ 	]*//p' track$dst.com | sed '/[[:cntrl:]]/s///g'`
    endif
endif

if (! -e $imageb) then
    echo "ERROR: $pn - Image file $imageb does not exist"
    exit 1
endif

#
# get fiducial file name and check existence
#
if ($fidfile == "") set fidfile = ${setname}$src.fid
if (! -e $fidfile) then
    echo "ERROR: $pn - Fiducial file $fidfile not found"
    exit 1
endif
if ($outfile == "") set outfile = ${setname}$dst.seed

#
# Get the views with minimum tilt angles
#
if ($zeroa == "") then
    set atilts = `awk '{print int(100. * $1)}' $tiltfilea`
    @ tiltmin = 1000000
    @ ind = 1
    while ($ind <= $#atilts)
	@ tilt = $atilts[$ind]
	if ($tilt < 0) @ tilt = -($tilt)
	if ($tilt < $tiltmin) then
	    @ zeroa = $ind
	    @ tiltmin = $tilt
	endif
	@ ind++
    end
endif

if ($zerob == "") then
    set btilts = `awk '{print int(100. * $1)}' $tiltfileb`
    @ tiltmin = 1000000
    @ ind = 1
    while ($ind <= $#btilts)
	@ tilt = $btilts[$ind]
	if ($tilt < 0) @ tilt = -($tilt)
	if ($tilt < $tiltmin) then
	    @ zerob = $ind
	    @ tiltmin = $tilt
	endif
	@ ind++
    end
endif

#
# Get image sizes
#
set nxyz =  `header -si $imagea | sed '/[[:cntrl:]]/s///g'`
if ($#nxyz < 3) then
    echo "ERROR: $pn - reading image size from header of $imagea"
    exit 1
endif
@ nxa = $nxyz[1]
@ nya = $nxyz[2]
@ nza = $nxyz[3]

set nxyz =  `header -si $imageb | sed '/[[:cntrl:]]/s///g'`
if ($#nxyz < 3) then
    echo "ERROR: $pn - reading image size from header of $imageb"
    exit 1
endif
@ nxb = $nxyz[1]
@ nyb = $nxyz[2]
@ nzb = $nxyz[3]

#
# Check pixel size
#
set pixela = `header -pi $imagea | sed '/[[:cntrl:]]/s///g'`
set pixelb = `header -pi $imageb | sed '/[[:cntrl:]]/s///g'`
if ($#pixela < 1 || $#pixelb < 1) then
    echo "ERROR: $pn - reading pixel size from image file headers"
    exit 1
endif
if ($pixela[1] != $pixelb[1]) then
    echo "ERROR: $pn - pixel sizes do not match:"
    echo "  $imagea = $pixela[1], $imageb = $pixelb[1]"
    exit 1
endif

#
# Set the number of reductions by 2 needed to get image size to 512 or less
#
@ size = $nxb
if ($nyb > $size) @ size = $nyb
@ reduce = 0
@ sizered = $size
while ($sizered > 512)
    @ sizered = $sizered / 2
    @ reduce++
end

#echo "reduce = $reduce"
#
# Get starting and ending section numbers
#
@ zeroa--
@ zerob--
@ asecstr = $zeroa - ($nviews / 2)
@ asecend = $asecstr + $nviews - 1
@ bsecstr = $zerob - ($nviews / 2)
@ bsecend = $bsecstr + $nviews - 1

#
# Check section numbers
# 
if ($asecstr < 0 || $asecend >= $nza) then
    echo "ERROR: $pn - The starting or ending section numbers for $AA are out of range ($asecstr and $asecend)"
    exit 1
endif
if ($bsecstr < 0 || $bsecend >= $nzb) then
    echo "ERROR: $pn - The starting or ending section numbers for $BB are out of range ($bsecstr and $bsecend)"
    exit 1
endif

#
# Set up lists to do sections from center out
#
set aseclist = ($zeroa)
set bseclist = ($zerob)
@ ind = 1
@ incr = 1
while ($ind < $nviews)
    @ asec = $zeroa + $incr
    @ bsec = $zerob + $incr
    set aseclist = ($aseclist $asec)
    set bseclist = ($bseclist $bsec)
    if ($incr > 0) then
	@ incr = - ($incr)
    else
	@ incr = 1 - ($incr)
    endif
    @ ind++
end

#
# Set up scaling based on range of density in B
# 5/13/06: Not any more, xfsimplex is normalizing to # Sd per pixel
#set densities = `header -min -max $imageb | sed '/[[:cntrl:]]/s///g'`
#set diffscale = `echo 1000. $densities[1] $densities[2] | awk '{print $1 / ($3 - $2)}'`
set diffscale = 1000000

#
# set up for midas
#
if ($midas) then
    if ($pmend != $pmstart) set pmend = 0
else
    echo "Finding the best matched pair of views in the two series:"
    echo "              (Type Ctrl-C to end search)"
endif


#
# Loop on section from b, section from a, and -/+90 rotations
#
@ diffmin = 2000000000
@ pluswin = 0
@ minuswin = 0
@ bsecind = 1
while ($bsecind <= $nviews)
    @ bsec = $bseclist[$bsecind]
    @ asecind = 1
    while ($asecind <= $nviews)
	@ asec = $aseclist[$asecind]
	@ plusminus = $pmstart
	set pmdiffs = ()
	while ($plusminus <= $pmend)
	    if ($plusminus) then
		\echo "0 -1 1 0 -1 0" >! $tmprot90
		set pmangle = +90
	    else
		\echo "0 1 -1 0 0 -1" >! $tmprot90
		set pmangle = -90
	    endif
	    # 
	    # extract the rotated section from A
	    #
            newstack -sec $asec -size $nxb,$nyb -xf $tmprot90 -use 0 $imagea $tmpimga >! $tmperrlog
	    if ($status) then
		grep ERROR $tmperrlog
		echo "ERROR: Transferfid - extracting rotated section from $AA"
		goto clean
	    endif
	    #
	    # Stack this rotated section on top of the sec from b
	    #
            newstack -sec $bsec -sec 0 $imageb $tmpimga $tmpstack >! $tmperrlog
	    if ($status) then
		grep ERROR $tmperrlog
		echo "ERROR: Transferfid - Stacking rotated $AA on $BB"
		goto clean
	    endif
	    if ($midas) then
		if ($asecind == 1 && $bsecind == 1) then
		    # 
		    # first time, run midas
		    # set box to 1 in case a 180 rotation is needed
		    #
		    echo "Starting midas - you should align translation and rotation,"
		    echo " and save the transform to the already-defined output file"
		    echo " "
		    sleep 3
		    midas -D -b 1 $tmpstack $tmpmidxf
		    if (! -e $tmpmidxf) then
			echo "ERROR: Transferfid - Transform file not found - cannot proceed"
			goto clean
		    endif
		    tail -n 1 $tmpmidxf >! $tmpxf1
		    echo "Finding the best matched pair of views in the two series:"
		    echo "              (Type Ctrl-C to end search)"

		endif
	    else
		#
		# Run tiltxcorr
		#
tiltxcorr -angles 0,0 -radius2 $radius2 -sigma1 $sigma1 -sigma2 $sigma2 $tmpstack $tmpxcxf >! $tmperrlog
		if ($status) then
		    grep ERROR $tmperrlog
		    echo "ERROR: Transferfid - Running Tiltxcorr"
		    goto clean
		endif
		#
		# Run xfsimplex looking for rotation only
		#
		#	    echo "first simplex"
		tail -n 1 $tmpxcxf >! $tmpxfin
xfsimplex <<EOF  >! $tmperrlog
$tmpstack
$tmpimga
$tmpxf1
$tmpxfin
,,,,,0
3
/
/
$reduce
0
0
EOF
		if ($status) then
		    grep ERROR $tmperrlog
		    echo "ERROR: Transferfid - Running first Xfsimplex"
		    goto clean
		endif
	    endif
	    #
	    # Run xfsimplex again from there, looking for full transform
	    #
#echo "second simplex"
xfsimplex  >! $tmpxflog <<EOF
$tmpstack
$tmpimga
$tmpxf2
$tmpxf1
/
0
/
/
$reduce
0
0
EOF
	    if ($status) then
		grep ERROR $tmpxflog
		echo "ERROR: Transferfid - Running second Xfsimplex"
		goto clean
	    endif

	    # 
	    # extract the difference from the log file
	    # 
	    set simplexout = `tail -n 1 $tmpxflog`
	    @ diff = `echo $simplexout[2] $diffscale | awk '{print int($1 * $2)}'`
	    @ aview = $asec + 1
	    @ bview = $bsec + 1
	    echo -n "$AA $aview  $BB $bview  rotation $pmangle  difference $diff"
	    if ($diff < $diffmin) then
		#
		# If new minimum, save sections and real transform
		echo '*'
		@ diffmin = $diff
		@ asecbest = $asec
		@ bsecbest = $bsec
                xfproduct $tmprot90 $tmpxf2 $tmpminxf >! $tmperrlog
		if ($status) then
		    grep ERROR $tmperrlog
		    echo "ERROR: Transferfid - Running Xfproduct"
		    goto clean
		endif
	    else
		echo ' '
	    endif
	    #
	    # Accumulate differences from plus and minus
	    #
	    set pmdiffs = ($pmdiffs $diff)
	    @ plusminus++
	end
	#
	# If there are both plus and minus, count who wins
	# and stop doing a consistent loser
	#
	if ($#pmdiffs == 2) then
	    if ($pmdiffs[1] < $pmdiffs[2]) @ minuswin++
	    if ($pmdiffs[1] > $pmdiffs[2]) @ pluswin++
	    if ($pluswin >= $minuswin + $DIRECTION_WIN_THRESH) set pmstart = 1
	    if ($minuswin >= $pluswin + $DIRECTION_WIN_THRESH) set pmend = 0
	endif
	@ asecind++
    end
    @ bsecind++
end

searchdone:
onintr clean

#
# Stack the two best sections
#
\echo "1 0 0 1 0 0" >! $tmptwoxf
cat $tmpminxf >> $tmptwoxf
newstack -sec $bsecbest -sec $asecbest -xf $tmptwoxf -use 0,1 -float 2 $imageb $imagea $tmpstack >! $tmperrlog
if ($status) then
    grep ERROR $tmperrlog
    echo "ERROR: Transferfid - Stacking two best views"
    goto clean
endif

#
# clip out the model and remap it to z = 1
#
set seclower = `echo $asecbest | awk '{print $1 - 0.5}'`
set secupper = `echo $asecbest | awk '{print $1 + 0.5}'`

clipmodel >! $tmperrlog <<EOF
$fidfile
$tmpclip
0
0
0
/
$seclower,$secupper
0
EOF
if ($status) then
    grep ERROR $tmperrlog
    echo "ERROR: Transferfid - Clipping out best view from $AA fiducial model"
    goto clean
endif

remapmodel >! $tmperrlog <<EOF
$tmpclip
$tmpmap1
1
0,0,0
EOF
if ($status) then
    grep ERROR $tmperrlog
    echo "ERROR: Transferfid - Remapping $AA fiducials to section 1"
    goto clean
endif

#
# transform model then adjust its coordinates to new center
#
@ xadd = ($nxb - $nxa) / 2
@ yadd = ($nyb - $nya) / 2
xfmodel >! $tmperrlog <<EOF
$imagea

$tmpmap1
1
0
$tmpxfmod
$tmptwoxf
EOF
if ($status) then
    grep ERROR $tmperrlog
    echo "ERROR: Transferfid - Transforming $AA fiducials to match $BB image"
    goto clean
endif

remapmodel >! $tmperrlog <<EOF
$tmpxfmod
$tmpmap2
1
$xadd,$yadd,0
EOF
if ($status) then
    grep ERROR $tmperrlog
    echo "ERROR: Transferfid - Recentering transformed $AA fiducials"
    goto clean
endif

#
# Get the bead radius and light/dark
# WATCH FOR THE TABS IN THE SED CONVERSIONS PRIOR TO THE cntrl REMOVAL
#
set boxsize = 48
if ($radius == "") then
    set test = `grep 'beadtrack.*-StandardInput' tracka.com`
    if ($status) then

        # Old style command file: have to convert tabs to spaces!
        #
        @ topline  = `vmstocsh < tracka.com | awk '/beadtrack/{print NR}'`
        @ reshootline = $topline + $BEADTRACK_RESHOOT_LINE
        set reshoots = `vmstocsh < tracka.com | awk '{if (NR==LINE) print}' LINE=$reshootline | sed -e '/	/s// /g' -e '/[[:cntrl:]]/s///g'`
        @ reshootnum = $reshoots[1]
        @ radline = $topline + $BEADTRACK_RADIUS_LINE + $reshootnum
        set radiusdark = `vmstocsh < tracka.com | awk '{if (NR==LINE) print}' LINE=$radline | sed -e '/[,	]/s// /g' -e '/[[:cntrl:]]/s///g'`
        set radius = $radiusdark[1]
        if ($#radiusdark > 1) then
            set lightdark = $radiusdark[2]
        endif
    else

        # PIP command file
        #
        set radiusline = `sed -n '/^CentroidRadius/s/CentroidRadius[ 	]*//p' tracka.com | sed '/[[:cntrl:]]/s///g'`
        if ($#radiusline < 1) then
            echo "ERROR: Transferfid - Cannot extract radius from tracka.com"
            goto clean
        endif
        set radius = $radiusline[1]

        set lightline = `sed -n '/^LightBeads/p' tracka.com | sed -e '/	/s// /g' -e '/[[:cntrl:]]/s///g'`
        if ("$lightline" != "") then
            if ($#lightline == 1) then
                set lightdark = 1
            else
                set lightdark = $lightline[2]
            endif
        endif

        set boxline = `sed -n '/^BoxSizeXandY/p' tracka.com | sed -e '/	/s// /g' -e '/[[:cntrl:]]/s///g'`
        if ($#boxline > 1) then
            set boxsize = $boxline[2]
        endif
    endif
endif

#
# run beadtrack.
#
@ aview = $asecbest + 1
@ bview = $bsecbest + 1
echo "Transferring fiducials from view $aview in $AA to view $bview in $BB with Beadtrack:"
echo "              (Type Ctrl-C to interrupt)"
beadtrack -StandardInput >! $tmpbtlog <<EOF
ImageFile $tmpstack
InputSeedModel $tmpmap2
OutputModel $tmpseed
RotationAngle   0
FirstTiltAngle	0
TiltIncrement	0
TiltDefaultGrouping	7
MagDefaultGrouping	5
CentroidRadius	$radius
LightBeads      $lightdark
BoxSizeXandY    $boxsize,$boxsize
TrackObjectsTogether
RoundsOfTracking	1
MinViewsForTiltalign    4
MinTiltRangeToFindAxis 10.0
MinTiltRangeToFindAngles        20.0
MaxBeadsToAverage       4
PointsToFitMaxAndMin    7,3
DensityRescueFractionAndSD      0.6,1
DistanceRescueCriterion 10
RescueRelaxationDensityAndDistance      0.7,0.9
PostFitRescueResidual   2.5
DensityRelaxationPostFit        0.9
MaxRescueDistance       2.5
ResidualsToAnalyzeMaxAndMin     9,5
DeletionCriterionMinAndSD       0.04,2
EOF

if ($status) then
    grep ERROR $tmpbtlog
    echo "ERROR: Transferfid - Running Beadtrack to get fiducials onto $BB view "
    goto clean
endif
set btresult = `tail -n 1 $tmpbtlog`
echo "Number of fiducials that failed to transfer: $btresult[$#btresult]"
    
#
# Remap seed model to the section in B
remapmodel <<EOF  >! $tmperrlog
$tmpseed
$tmpmap3
$bsecbest,-999
0,0,0
EOF
if ($status) then
    grep ERROR $tmperrlog
    echo "ERROR: Transferfid - Remapping seed model up to view in $BB"
    goto clean
endif
#
# Repack the model to remove empty points, and pass through mapping report
# First find out if the fid.xyz is availabel and has contour data
#
set xyzname = ${setname}${src}fid.xyz
if (-e $xyzname) then
    set xyzwc = `wc $xyzname`
    @ lines = $xyzwc[1]
    @ words = $xyzwc[2]
    if ($lines * 6 > $words) set xyzname = ""
else
    set xyzname = ""
endif

repackseed <<EOF > $tmprplog
$fidfile
$xyzname
$tmpmap3
$outfile
$correspond
$asecbest,$bsecbest,$ifbtoa
EOF
echo " "
awk '/follow/, /junk/' $tmprplog

clean:
if ($leavetmp == 0) then
    \rm -f $tmpdir/$com.*.$$*
else
    echo "Temporary files left in $tmpdir"
endif
exit 0

usage:
cat <<EOF
Usage: $pn [options] setname
  Will make a fiducial seed model for one axis from the fiducial model for
  the other axis.  By default, it will transfer fiducials from A to B.
  For setname, give the name of the data set, omitting a or b.
  Options:
     -b            Transfer fiducials in backwards direction, from B to A
     -ia imagefile Name of axis A image file (default taken from tracka.com)
     -ib imagefile Name of axis B image file (default taken from trackb.com)
     -f fidmodel   Name of axis A fiducial model (default setnamea.fid, or
                      setnameb.fid with -b option)
     -o seedmodel  Name of output file (default setnameb.seed, or 
                      setnamea.seed with -b option)
     -n #          Number of views to search to find best pair (default $nviews)
     -za #         Number of view in A to center search around (default is 
                      view closest to zero tilt in setnamea.rawtlt)
     -zb #         Number of view in B to center search around (default is 
                      view closest to zero tilt in setnameb.rawtlt)
     -a #          Rotation direction or angle to search (+1, -1, +90, -90
                      all work, default is to search both directions)
     -m            Run Midas to set initial translational/rotational alignment
     -r radius     Bead radius for Beadtrack; default is taken from tracka.com
     -l            Search for light rather than dark beads (only works with -r)
     -c name       File to place corresponding coordinates in
     -t            Leave temporary files in $tmpdir
     -P            Output process ID (PID)
     -h            Help - print this usage
EOF
exit 1

#
#  $Log$
#  Revision 3.26  2006/05/05 18:11:57  mast
#  Added -c option to usage
#
#  Revision 3.25  2006/05/04 23:07:49  mast
#  Added argument to provide file for repackseed to place corresponding coords
#
#  Revision 3.24  2006/02/16 06:47:09  mast
#  Stripped control chars from output of sed/header etc for Windows
#
#  Revision 3.23  2005/11/19 04:31:26  mast
#  Quote path setting to preserve spaces
#
#  Revision 3.22  2005/10/07 17:59:31  mast
#  Fixed tracka.com sed lines to turn tabs to spaces before they get stripped
#
#  Revision 3.21  2005/05/11 15:05:02  mast
#  Fixed bugs with light beads
#
#  Revision 3.20  2005/05/11 06:02:33  mast
#  Changes for PIP version of track.com
#
#  Revision 3.19  2004/08/27 05:46:48  mast
#  Switched to using head -n and tail -n
#
#  Revision 3.18  2004/08/03 02:05:55  mast
#  Made it insist both prealis have same pixel size
#
#  Revision 3.17  2004/07/22 18:16:45  mast
#  Change to better sed command for stripping Ctrl M
#
#  Revision 3.16  2004/07/08 22:54:18  mast
#  Switched some echos to \echo to dodge Cygwin tcsh bug
#
#  Revision 3.15  2004/06/29 03:50:14  mast
#  Added nohup
#
#  Revision 3.14  2004/03/06 21:36:14  mast
#  Converted newstack commands to command-line format
#
#  Revision 3.13  2003/10/24 02:04:25  mast
#  Add filters for Windows line endings, change tmpdir usage
#
#  Revision 3.12  2003/06/20 20:09:51  mast
#  Let tmpdir be defined and fall back to /tmp if /usr/tmp does not exist
#
#  Revision 3.11  2003/06/05 04:28:54  mast
#  Change PID output to match vmstocsh output to stderr
#
#  Revision 3.10  2003/05/22 23:35:04  mast
#  Added -P to output PID and made all startup errors include ERROR:
#
#  Revision 3.9  2003/05/13 20:16:09  mast
#  Eliminate using $0 to get temp file name, doesn't work on Windows
#
#  Revision 3.8  2003/02/07 00:01:35  mast
#  Added option to go from B to A easily
#
#  Revision 3.7  2002/12/03 21:53:32  mast
#  Made it set limits at z-0.5 and z+0.5 for clipmodel
#  Added complete error detection and reporting from each program that is run
#
#  Revision 3.6  2002/09/05 05:42:14  mast
#  Fixed output of chosen view numbers
#
#  Revision 3.5  2002/07/28 21:59:44  mast
#  Modified high-pass filter from 0.1 (which was based on default in xfalign)
#  to match new value of 0.03 for Tiltxcorr, based on alignment failures in
#  SerialEM
#
#  Revision 3.4  2002/07/28 20:23:23  mast
#  Changed to require setname argument, call repackseed with a fiducial
#  coordinate file if an appropriate on exists, and have option to call midas
#  to get the initial alignment.
#
#  Revision 3.3  2002/06/19 16:07:13  mast
#  Added option to leave temporary files
#
#  Revision 3.2  2002/05/23 04:43:12  mast
#  Changes to call repackseed and provide for Ctrl-C to stop search
#
#  Revision 3.1  2002/05/20 19:48:17  mast
#  Initial deposit into repository
#
