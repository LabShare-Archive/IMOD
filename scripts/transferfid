#! /bin/csh -f
# transferfid will find best matching pair of views between two tilt series
# and transfer the fiducial model from one to make a seed model for the other
#
#  $Id$
#  Log at end of file
#

nohup

# Filter for tiltxcorr
set sigma1 = 0.03
set sigma2 = 0.05
set radius2 = 0.25

# Search limit parameters
@ xylimitfrac = 5
set rotlimit = 15
set otherlimits = .1,.05,2

# Number of wins more in one rotation direction than the other that will
# make it abandon the other direction
@ DIRECTION_WIN_THRESH = 4

# Line number of beadtrack input for input file, # of reshoot lines,
# and bead radius when there are no reshoot lines
@ BEADTRACK_INPUTFILE_LINE = 1
@ BEADTRACK_RESHOOT_LINE = 7
@ BEADTRACK_RADIUS_LINE = 13

setenv LC_NUMERIC C

set tmpdir = /usr/tmp
if ($?IMOD_DIR) then
    setenv PATH "$IMOD_DIR/bin:$PATH"
    if (-e "$IMOD_DIR/bin/settmpdir") source "$IMOD_DIR/bin/settmpdir"
endif

onintr searchdone

#
# set names of temp files
#
set pn      = transferfid
set com        = $pn:t
set tmpstack   = "$tmpdir/$com.stack.$$"
set tmpimga    = "$tmpdir/$com.imga.$$"
set tmpxcxf    = "$tmpdir/$com.xcxf.$$"
set tmpxfin    = "$tmpdir/$com.xfin.$$"
set tmpxf1    = "$tmpdir/$com.xf1.$$"
set tmpxf2    = "$tmpdir/$com.xf2.$$"
set tmprot90    = "$tmpdir/$com.rot90.$$"
set tmpminxf    = "$tmpdir/$com.minxf.$$"
set tmptwoxf    = "$tmpdir/$com.twoxf.$$"
set tmpxflog    = "$tmpdir/$com.xflog.$$"
set tmpbtlog    = "$tmpdir/$com.btlog.$$"
set tmprplog    = "$tmpdir/$com.rplog.$$"
set tmpclip    = "$tmpdir/$com.clip.$$"
set tmpxfmod    = "$tmpdir/$com.xfmod.$$"
set tmpseed    = "$tmpdir/$com.seed.$$"
set tmpmap1    = "$tmpdir/$com.map1.$$"
set tmpmap2    = "$tmpdir/$com.map2.$$"
set tmpmap3    = "$tmpdir/$com.map3.$$"
set tmpmidxf   = "$tmpdir/$com.midxf.$$"
set tmperrlog    = "$tmpdir/$com.errlog.$$"

#
# set default set name from current directory - NOT ANY MORE
# 
#set cwd = `pwd`
#set setname = $cwd:t

#
# set other defaults or values to indicate no argument was entered
#
set diameter = ""
@ nviews = 5
set imagea = ""
set imageb = ""
set fidfile = ""
set zeroa = ""
set zerob = ""
set lightdark = 0
set outfile = ""
set pmstart = 0
set pmend = 1
set leavetmp = 0
set midas = 0
set src = a
set dst = b
set AA = A
set BB = B
set ifbtoa = 0
set correspond = ""
set mirror = 0

if ($#argv < 1) goto usage

while ($#argv > 1)
  switch ($argv[1])
#    case -s:
#      set setname = $argv[2]
#      shift; shift
#      breaksw
    case -ia:
      set imagea = $argv[2]
      shift; shift
      breaksw
    case -ib:
      set imageb = $argv[2]
      shift; shift
      breaksw
    case -f:
      set fidfile = $argv[2]
      shift; shift
      breaksw
    case -n:
      @ nviews = $argv[2]
      shift; shift
      breaksw
    case -za:
      @ zeroa = $argv[2]
      shift; shift
      breaksw
    case -zb:
      @ zerob = $argv[2]
      shift; shift
      breaksw
    case -d:
      set diameter = $argv[2]
      shift; shift
      breaksw
    case -o:
      set outfile = $argv[2]
      shift; shift
      breaksw
    case -c:
      set correspond = $argv[2]
      shift; shift
      breaksw
    case -a:
      @ angle = $argv[2]
      if ($angle < 0) set pmend = 0
      if ($angle > 0) set pmstart = 1
      shift; shift
      breaksw
    case -l:
      set lightdark = 1
      shift
      breaksw
    case -t:
      set leavetmp = 1
      shift
      breaksw
    case -m:
      set midas = 1
      shift
      breaksw
    case -x:
      set mirror = 1
      shift
      breaksw
    case -b:
      set src = b
      set dst = a
      set AA = B
      set BB = A
      set ifbtoa = 1
      shift
      breaksw
    case -h:
      goto usage
    case -P:
      echo2 Shell PID: $$
      shift
      breaksw
    default:
      echo "ERROR: ${pn} - bad argument $argv[1]"
      goto usage
  endsw
end

set setname = $argv[1]

if ($nviews < 1) then
    echo "ERROR: $pn - The number of views to sample must be at least 1; you entered $nviews"
    exit 1
endif

#
# swap inputs for filename and center z's if going backwards
#
if ($src == "b") then
    set tmp = $imagea
    set imagea = $imageb
    set imageb = "$tmp"
    set tmp = $zeroa
    set zeroa = $zerob
    set zerob = "$tmp"
endif

#
# check existence of files needed
#

if (($imagea == "" || $diameter == "") && (! -e track$src.com)) then
    echo "ERROR: $pn - track$src.com not found - it is needed unless you enter both "
    echo " the $AA image file with -i$src and the bead diameter with -d"
    exit 1
endif

if ($imageb == "" && (! -e track$dst.com)) then
    echo "ERROR: $pn - track$dst.com not found - it is needed unless you enter"
    echo " the $BB image file with -i$dst"
    exit 1
endif

set tiltfilea = ${setname}$src.rawtlt
set tiltfileb = ${setname}$dst.rawtlt
if ($zeroa == "" && (! -e $tiltfilea)) then
    echo "ERROR: $pn - $tiltfilea not found - it is needed unless you enter"
    echo " the zero-tilt view number for $AA with -z$src"
    exit 1
endif
if ($zerob == "" && (! -e $tiltfileb)) then
    echo "ERROR: $pn - $tiltfileb not found - it is needed unless you enter"
    echo " the zero-tilt view number for $BB with -z$dst"
    exit 1
endif

#
# Get the image file names if they don't exist already
#
if ($imagea == "") then
    set test = `grep 'beadtrack.*-StandardInput' track$src.com`
    if ($status) then
        @ topline  = `vmstocsh < track$src.com | awk '/beadtrack/{print NR}'`
        @ nextline = $topline + $BEADTRACK_INPUTFILE_LINE
        set imagea = `vmstocsh < track$src.com | awk '{if (NR==LINE) print}' LINE=$nextline | sed '/[[:cntrl:]]/s///g'`
    else
        set imagea = `sed -n '/^ImageFile/s/ImageFile[ 	]*//p' track$src.com | sed '/[[:cntrl:]]/s///g'`
    endif
endif

if (! -e $imagea) then
    echo "ERROR: $pn - Image file $imagea does not exist"
    exit 1
endif

if ($imageb == "") then
    set test = `grep 'beadtrack.*-StandardInput' track$dst.com`
    if ($status) then
        @ topline  = `vmstocsh < track$dst.com | awk '/beadtrack/{print NR}'`
        @ nextline = $topline + $BEADTRACK_INPUTFILE_LINE
        set imageb = `vmstocsh < track$dst.com | awk '{if (NR==LINE) print}' LINE=$nextline | sed '/[[:cntrl:]]/s///g'`
    else
        set imageb = `sed -n '/^ImageFile/s/ImageFile[ 	]*//p' track$dst.com | sed '/[[:cntrl:]]/s///g'`
    endif
endif

if (! -e $imageb) then
    echo "ERROR: $pn - Image file $imageb does not exist"
    exit 1
endif

#
# get fiducial file name and check existence
#
if ($fidfile == "") set fidfile = ${setname}$src.fid
if (! -e $fidfile) then
    echo "ERROR: $pn - Fiducial file $fidfile not found"
    exit 1
endif
if ($outfile == "") set outfile = ${setname}$dst.seed

#
# Get the views with minimum tilt angles
#
if ($zeroa == "") then
    set atilts = `awk '{print int(100. * $1)}' $tiltfilea`
    @ tiltmin = 1000000
    @ ind = 1
    while ($ind <= $#atilts)
	@ tilt = $atilts[$ind]
	if ($tilt < 0) @ tilt = -($tilt)
	if ($tilt < $tiltmin) then
	    @ zeroa = $ind
	    @ tiltmin = $tilt
	endif
	@ ind++
    end
endif

if ($zerob == "") then
    set btilts = `awk '{print int(100. * $1)}' $tiltfileb`
    @ tiltmin = 1000000
    @ ind = 1
    while ($ind <= $#btilts)
	@ tilt = $btilts[$ind]
	if ($tilt < 0) @ tilt = -($tilt)
	if ($tilt < $tiltmin) then
	    @ zerob = $ind
	    @ tiltmin = $tilt
	endif
	@ ind++
    end
endif

#
# Get image sizes
#
set nxyz =  `header -si $imagea | sed '/[[:cntrl:]]/s///g'`
if ($#nxyz < 3) then
    echo "ERROR: $pn - reading image size from header of $imagea"
    exit 1
endif
@ nxa = $nxyz[1]
@ nya = $nxyz[2]
@ nza = $nxyz[3]

set nxyz =  `header -si $imageb | sed '/[[:cntrl:]]/s///g'`
if ($#nxyz < 3) then
    echo "ERROR: $pn - reading image size from header of $imageb"
    exit 1
endif
@ nxb = $nxyz[1]
@ nyb = $nxyz[2]
@ nzb = $nxyz[3]

#
# Check pixel size
#
set pixela = `header -pi $imagea | sed '/[[:cntrl:]]/s///g'`
set pixelb = `header -pi $imageb | sed '/[[:cntrl:]]/s///g'`
if ($#pixela < 1 || $#pixelb < 1) then
    echo "ERROR: $pn - reading pixel size from image file headers"
    exit 1
endif
set thoudiff = `echo $pixela[1] $pixelb[1] | awk '{print int(1000. * ($2 - $1)/ $2)}'`
if ($thoudiff < -25 || $thoudiff > 25) then
    echo "ERROR: $pn - pixel sizes do not match:"
    echo "  $imagea = $pixela[1], $imageb = $pixelb[1]"
    exit 1
endif

#
# Set the binning needed to get image size to 512 or less unless the size is
# bigger than 4K, in which case bin to 1024.  Limit binning to 4 between 2048
# and 4096.  Set limits on X/Y in search
@ size = `echo $nxa  $nxb | awk '{print int(sqrt($1 * $2))}'`
@ limit = 512
if ($size >= 4096) @ limit = 1024
@ reduce = ($size + $limit - 1) / $limit
if ($size < 4096 && $reduce > 4) @ reduce = 4
@ xlimit = $nxb / 5
@ ylimit = $nyb / 5

#echo $xlimit, $ylimit, $reduce

#
# Get starting and ending section numbers
#
@ zeroa--
@ zerob--
@ asecstr = $zeroa - ($nviews / 2)
@ asecend = $asecstr + $nviews - 1
@ bsecstr = $zerob - ($nviews / 2)
@ bsecend = $bsecstr + $nviews - 1

#
# Check section numbers
# 
if ($asecstr < 0 || $asecend >= $nza) then
    echo "ERROR: $pn - The starting or ending section numbers for $AA are out of range ($asecstr and $asecend)"
    exit 1
endif
if ($bsecstr < 0 || $bsecend >= $nzb) then
    echo "ERROR: $pn - The starting or ending section numbers for $BB are out of range ($bsecstr and $bsecend)"
    exit 1
endif

#
# Set up lists to do sections from center out
#
set aseclist = ($zeroa)
set bseclist = ($zerob)
@ ind = 1
@ incr = 1
while ($ind < $nviews)
    @ asec = $zeroa + $incr
    @ bsec = $zerob + $incr
    set aseclist = ($aseclist $asec)
    set bseclist = ($bseclist $bsec)
    if ($incr > 0) then
	@ incr = - ($incr)
    else
	@ incr = 1 - ($incr)
    endif
    @ ind++
end

#
# Set up scaling based on range of density in B
# 5/13/06: Not any more, xfsimplex is normalizing to # Sd per pixel
#set densities = `header -min -max $imageb | sed '/[[:cntrl:]]/s///g'`
#set diffscale = `echo 1000. $densities[1] $densities[2] | awk '{print $1 / ($3 - $2)}'`
set diffscale = 1000000

#
# set up for midas
#
if ($midas) then
    if ($pmend != $pmstart) set pmend = 0
else
    echo "Finding the best matched pair of views in the two series:"
    echo "              (Type Ctrl-C to end search)"
endif

#
# Loop on section from b, section from a, and -/+90 rotations
#
@ diffmin = 2000000000
@ pluswin = 0
@ minuswin = 0
@ bsecind = 1
while ($bsecind <= $nviews)
    @ bsec = $bseclist[$bsecind]
    @ asecind = 1
    while ($asecind <= $nviews)
	@ asec = $aseclist[$asecind]
	@ plusminus = $pmstart
	set pmdiffs = ()
	while ($plusminus <= $pmend)
	    if ($plusminus) then
		if ($mirror) then
                    \echo "0 -1 -1 0 -1 -1" >! "$tmprot90"
                else
                    \echo "0 -1 1 0 -1 0" >! "$tmprot90"
                endif
		set pmangle = +90
	    else
		if ($mirror) then
                    \echo "0 1 1 0 0 0" >! "$tmprot90"
                else
                    \echo "0 1 -1 0 0 -1" >! "$tmprot90"
                endif
		set pmangle = -90
	    endif
	    # 
	    # extract the rotated section from A
	    #
            newstack -sec $asec -size $nxb,$nyb -xf "$tmprot90" -use 0 $imagea "$tmpimga" >! "$tmperrlog"
	    if ($status) then
		grep ERROR "$tmperrlog"
		echo "ERROR: Transferfid - extracting rotated section from $AA"
		goto clean
	    endif
	    #
	    # Stack this rotated section on top of the sec from b
	    #
            newstack -sec $bsec -sec 0 $imageb "$tmpimga" "$tmpstack" >! "$tmperrlog"
	    if ($status) then
		grep ERROR "$tmperrlog"
		echo "ERROR: Transferfid - Stacking rotated $AA on $BB"
		goto clean
	    endif
	    if ($midas) then
		if ($asecind == 1 && $bsecind == 1) then
		    # 
		    # first time, run midas
		    # set box to 1 in case a 180 rotation is needed
		    #
		    echo "Starting midas - you should align translation and rotation,"
		    echo " and save the transform to the already-defined output file"
		    echo " "
		    sleep 3
		    midas -D -b 1 "$tmpstack" "$tmpmidxf"
		    if (! -e "$tmpmidxf") then
			echo "ERROR: Transferfid - Transform file not found - cannot proceed"
			goto clean
		    endif
		    tail -n 1 "$tmpmidxf" >! "$tmpxf1"
		    echo "Finding the best matched pair of views in the two series:"
		    echo "              (Type Ctrl-C to end search)"

		endif
	    else
		#
		# Run tiltxcorr
		#
tiltxcorr -angles 0,0 -radius2 $radius2 -sigma1 $sigma1 -sigma2 $sigma2 "$tmpstack" "$tmpxcxf" >! "$tmperrlog"
		if ($status) then
		    grep ERROR "$tmperrlog"
		    echo "ERROR: Transferfid - Running Tiltxcorr"
		    goto clean
		endif
		#
		# Run xfsimplex looking for rotation only
		#
		#	    echo "first simplex"
		tail -n 1 "$tmpxcxf" >! "$tmpxfin"
xfsimplex -StandardInput <<EOF  >! "$tmperrlog"
AImageFile $tmpstack
BImageFile $tmpimga
OutputFile $tmpxf1
InitialTransformFile $tmpxfin
VariablesToSearch 3
BinningToApply $reduce
LimitsOnSearch $xlimit,$ylimit,$rotlimit
EOF
		if ($status) then
		    grep ERROR "$tmperrlog"
		    echo "ERROR: Transferfid - Running first Xfsimplex"
		    goto clean
		endif
	    endif
	    #
	    # Run xfsimplex again from there, looking for full transform
	    #
#echo "second simplex"
xfsimplex -StandardInput  >! "$tmpxflog" <<EOF
AImageFile $tmpstack
BImageFile $tmpimga
OutputFile $tmpxf2
InitialTransformFile $tmpxf1
VariablesToSearch 6
BinningToApply $reduce
LimitsOnSearch $xlimit,$ylimit,$rotlimit,$otherlimits
EOF
	    if ($status) then
		grep ERROR "$tmpxflog"
		echo "ERROR: Transferfid - Running second Xfsimplex"
		goto clean
	    endif

	    # 
	    # extract the difference from the log file
	    # Need two lines when using natural transforms
	    set simplexout = `tail -n 2 "$tmpxflog"`
	    @ diff = `echo $simplexout[2] $diffscale | awk '{print int($1 * $2)}'`
	    @ aview = $asec + 1
	    @ bview = $bsec + 1
	    echo -n "$AA $aview  $BB $bview  rotation $pmangle  difference $diff"
	    if ($diff < $diffmin) then
		#
		# If new minimum, save sections and real transform
		echo '*'
		@ diffmin = $diff
		@ asecbest = $asec
		@ bsecbest = $bsec
                xfproduct "$tmprot90" "$tmpxf2" "$tmpminxf" >! "$tmperrlog"
		if ($status) then
		    grep ERROR "$tmperrlog"
		    echo "ERROR: Transferfid - Running Xfproduct"
		    goto clean
		endif
	    else
		echo ' '
	    endif
	    #
	    # Accumulate differences from plus and minus
	    #
	    set pmdiffs = ($pmdiffs $diff)
	    @ plusminus++
	end
	#
	# If there are both plus and minus, count who wins
	# and stop doing a consistent loser
	#
	if ($#pmdiffs == 2) then
	    if ($pmdiffs[1] < $pmdiffs[2]) @ minuswin++
	    if ($pmdiffs[1] > $pmdiffs[2]) @ pluswin++
	    if ($pluswin >= $minuswin + $DIRECTION_WIN_THRESH) set pmstart = 1
	    if ($minuswin >= $pluswin + $DIRECTION_WIN_THRESH) set pmend = 0
	endif
	@ asecind++
    end
    @ bsecind++
end

searchdone:
onintr clean

#
# Stack the two best sections
#
\echo "1 0 0 1 0 0" >! "$tmptwoxf"
cat "$tmpminxf" >> "$tmptwoxf"
newstack -sec $bsecbest -sec $asecbest -xf "$tmptwoxf" -use 0,1 -float 2 $imageb $imagea "$tmpstack" >! "$tmperrlog"
if ($status) then
    grep ERROR "$tmperrlog"
    echo "ERROR: Transferfid - Stacking two best views"
    goto clean
endif

# Find the pixel size of the model a scale factor
#
set modpixel = `imodinfo -h $fidfile | sed -n -e '/[[:cntrl:]]/s///g' -e '/.*SCALE.*( \([0-9.]*\).*/s//\1/p'`
set modscale = `echo $pixela[1] $modpixel | awk '{print $1 / $2}'`
#
# clip out the model and remap it to z = 1
#
set seclower = `echo $asecbest | awk '{print $1 - 0.5}'`
set secupper = `echo $asecbest | awk '{print $1 + 0.5}'`

clipmodel >! "$tmperrlog" <<EOF
$fidfile
$tmpclip
0
0
0
/
$seclower,$secupper
0
EOF
if ($status) then
    grep ERROR "$tmperrlog"
    echo "ERROR: Transferfid - Clipping out best view from $AA fiducial model"
    goto clean
endif

remapmodel -new 1 $tmpclip $tmpmap1 >! "$tmperrlog"
if ($status) then
    grep ERROR "$tmperrlog"
    echo "ERROR: Transferfid - Remapping $AA fiducials to section 1"
    goto clean
endif

#
# transform model then adjust its coordinates to new center
#
set xadd = `echo $modscale $nxb $nxa | awk '{print $1 * ($2 - $3) / 2.}'`
set yadd = `echo $modscale $nyb $nya | awk '{print $1 * ($2 - $3) / 2.}'`
xfmodel -xforms $tmptwoxf -scale $modscale $tmpmap1 $tmpxfmod >! "$tmperrlog" 
if ($status) then
    grep ERROR "$tmperrlog"
    echo "ERROR: Transferfid - Transforming $AA fiducials to match $BB image"
    goto clean
endif

remapmodel -new 1 -add $xadd,$yadd,0 $tmpxfmod $tmpmap2 >! "$tmperrlog" 
if ($status) then
    grep ERROR "$tmperrlog"
    echo "ERROR: Transferfid - Recentering transformed $AA fiducials"
    goto clean
endif

#
# Get the bead diameter and light/dark
# WATCH FOR THE TABS IN THE SED CONVERSIONS PRIOR TO THE cntrl REMOVAL
#
set boxsize = 48
set binning = 1
if ($diameter == "") then
    set test = `grep 'beadtrack.*-StandardInput' tracka.com`
    if ($status) then

        # Old style command file: have to convert tabs to spaces!
        #
        @ topline  = `vmstocsh < tracka.com | awk '/beadtrack/{print NR}'`
        @ reshootline = $topline + $BEADTRACK_RESHOOT_LINE
        set reshoots = `vmstocsh < tracka.com | awk '{if (NR==LINE) print}' LINE=$reshootline | sed -e '/	/s// /g' -e '/[[:cntrl:]]/s///g'`
        @ reshootnum = $reshoots[1]
        @ radline = $topline + $BEADTRACK_RADIUS_LINE + $reshootnum
        set radiusdark = `vmstocsh < tracka.com | awk '{if (NR==LINE) print}' LINE=$radline | sed -e '/[,	]/s// /g' -e '/[[:cntrl:]]/s///g'`
        set radius = $radiusdark[1]
        if ($#radiusdark > 1) then
            set lightdark = $radiusdark[2]
        endif
        set diameter = `echo $radius | awk '{print 2 * $1 - 3}'`
    else

        # PIP command file
        #
        set radiusline = `sed -n '/^CentroidRadius/s/CentroidRadius[ 	]*//p' tracka.com | sed '/[[:cntrl:]]/s///g'`
        set diamline = `sed -n '/^BeadDiameter/s/BeadDiameter[ 	]*//p' tracka.com | sed '/[[:cntrl:]]/s///g'`
        if ($#radiusline < 1 && $#diamline < 1) then
            echo "ERROR: Transferfid - Cannot extract radius or diameter from tracka.com"
            goto clean
        endif
        if ( $#diamline < 1) then
            set radius = $radiusline[1]
            set diameter = `echo $radius | awk '{print 2 * $1 - 3}'`
        else
            set diameter = $diamline[1]
        endif


        set lightline = `sed -n '/^LightBeads/p' tracka.com | sed -e '/	/s// /g' -e '/[[:cntrl:]]/s///g'`
        if ("$lightline" != "") then
            if ($#lightline == 1) then
                set lightdark = 1
            else
                set lightdark = $lightline[2]
            endif
        endif

        set boxline = `sed -n '/^BoxSizeXandY/p' tracka.com | sed -e '/	/s// /g' -e '/[[:cntrl:]]/s///g'`
        if ($#boxline > 1) then
            set boxsize = $boxline[2]
        endif

        set binline = `sed -n '/^ImagesAreBinned/p' tracka.com | sed -e '/	/s// /g' -e '/[[:cntrl:]]/s///g'`
        if ($#binline > 1) then
            set binning = $binline[2]
        endif
    endif
endif

#
# run beadtrack.
#
@ aview = $asecbest + 1
@ bview = $bsecbest + 1
echo "Transferring fiducials from view $aview in $AA to view $bview in $BB with Beadtrack:"
echo "              (Type Ctrl-C to interrupt)"
beadtrack -StandardInput >! "$tmpbtlog" <<EOF
ImageFile $tmpstack
InputSeedModel $tmpmap2
OutputModel $tmpseed
RotationAngle   0
FirstTiltAngle	0
TiltIncrement	0
TiltDefaultGrouping	7
MagDefaultGrouping	5
BeadDiameter    $diameter
ImagesAreBinned $binning
LightBeads      $lightdark
BoxSizeXandY    $boxsize,$boxsize
TrackObjectsTogether
RoundsOfTracking	1
MinViewsForTiltalign    4
MinTiltRangeToFindAxis 10.0
MinTiltRangeToFindAngles        20.0
MaxBeadsToAverage       4
PointsToFitMaxAndMin    7,3
DensityRescueFractionAndSD      0.6,1
DistanceRescueCriterion 10
RescueRelaxationDensityAndDistance      0.7,0.9
PostFitRescueResidual   2.5
DensityRelaxationPostFit        0.9
MaxRescueDistance       2.5
ResidualsToAnalyzeMaxAndMin     9,5
DeletionCriterionMinAndSD       0.04,2
EOF

if ($status) then
    grep ERROR "$tmpbtlog"
    echo "ERROR: Transferfid - Running Beadtrack to get fiducials onto $BB view "
    goto clean
endif
set btresult = `tail -n 1 "$tmpbtlog"`
echo "Number of fiducials that failed to transfer: $btresult[$#btresult]"
    
#
# Remap seed model to the section in B
remapmodel -new $bsecbest,-999 $tmpseed $tmpmap3 >! "$tmperrlog"
if ($status) then
    grep ERROR "$tmperrlog"
    echo "ERROR: Transferfid - Remapping seed model up to view in $BB"
    goto clean
endif
#
# Repack the model to remove empty points, and pass through mapping report
# First find out if the fid.xyz is availabel and has contour data
#
set xyzname = ${setname}${src}fid.xyz
if (-e $xyzname) then
    set xyzwc = `wc $xyzname`
    @ lines = $xyzwc[1]
    @ words = $xyzwc[2]
    if ($lines * 6 > $words) set xyzname = ""
else
    set xyzname = ""
endif

repackseed <<EOF > "$tmprplog"
$fidfile
$xyzname
$tmpmap3
$outfile
$correspond
$asecbest,$bsecbest,$ifbtoa
EOF
echo " "
awk '/follow/, /junk/' "$tmprplog"

clean:
if ($leavetmp == 0) then
    \rm -f "$tmpdir"/$com.*.$$*
else
    echo "Temporary files left in $tmpdir"
endif
exit 0

usage:
cat <<EOF
Usage: $pn [options] setname
  Will make a fiducial seed model for one axis from the fiducial model for
  the other axis.  By default, it will transfer fiducials from A to B.
  For setname, give the name of the data set, omitting a or b.
  Options:
     -b            Transfer fiducials in backwards direction, from B to A
     -ia imagefile Name of axis A image file (default taken from tracka.com)
     -ib imagefile Name of axis B image file (default taken from trackb.com)
     -f fidmodel   Name of axis A fiducial model (default setnamea.fid, or
                      setnameb.fid with -b option)
     -o seedmodel  Name of output file (default setnameb.seed, or 
                      setnamea.seed with -b option)
     -n #          Number of views to search to find best pair (default $nviews)
     -za #         Number of view in A to center search around (default is 
                      view closest to zero tilt in setnamea.rawtlt)
     -zb #         Number of view in B to center search around (default is 
                      view closest to zero tilt in setnameb.rawtlt)
     -a #          Rotation direction or angle to search (+1, -1, +90, -90
                      all work, default is to search both directions)
     -x            Mirror one image around X axis
     -m            Run Midas to set initial translational/rotational alignment
     -d diameter   Bead diameter in pixels; default is taken from tracka.com
     -l            Search for light rather than dark beads (only works with -d)
     -c name       File to place corresponding coordinates in
     -t            Leave temporary files in $tmpdir
     -P            Output process ID (PID)
     -h            Help - print this usage
EOF
exit 1

#
#  $Log$
#  Revision 3.34  2008/12/10 21:27:03  mast
#  Made it work if fiducial model last loaded at different binning from stacks
#
#  Revision 3.33  2008/12/09 15:35:59  mast
#  Modified to work with diameter instead of centroid radius
#
#  Revision 3.32  2008/07/01 17:41:28  mast
#  Changed to use PIP input to xfsimplex and limit search ranges
#
#  Revision 3.31  2008/01/04 07:03:38  mast
#  Fixed for space in IMOD_DIR, possibly for space in tmpdir
#
#  Revision 3.30  2006/08/17 18:36:55  mast
#  Added locale statement to keep output of awk from having instead of .
#
#  Revision 3.29  2006/06/08 18:48:57  mast
#  Changed to specify binning rather than reductions to xfsimplex and to
#  use the total pixel count instead of minimum size
#
#  Revision 3.28  2006/06/03 00:00:06  mast
#  Added option to mirror around X
#
#  Revision 3.27  2006/05/14 03:14:00  mast
#  Changed scaling to accomodate xfsimplex change
#
#  Revision 3.26  2006/05/05 18:11:57  mast
#  Added -c option to usage
#
#  Revision 3.25  2006/05/04 23:07:49  mast
#  Added argument to provide file for repackseed to place corresponding coords
#
#  Revision 3.24  2006/02/16 06:47:09  mast
#  Stripped control chars from output of sed/header etc for Windows
#
#  Revision 3.23  2005/11/19 04:31:26  mast
#  Quote path setting to preserve spaces
#
#  Revision 3.22  2005/10/07 17:59:31  mast
#  Fixed tracka.com sed lines to turn tabs to spaces before they get stripped
#
#  Revision 3.21  2005/05/11 15:05:02  mast
#  Fixed bugs with light beads
#
#  Revision 3.20  2005/05/11 06:02:33  mast
#  Changes for PIP version of track.com
#
#  Revision 3.19  2004/08/27 05:46:48  mast
#  Switched to using head -n and tail -n
#
#  Revision 3.18  2004/08/03 02:05:55  mast
#  Made it insist both prealis have same pixel size
#
#  Revision 3.17  2004/07/22 18:16:45  mast
#  Change to better sed command for stripping Ctrl M
#
#  Revision 3.16  2004/07/08 22:54:18  mast
#  Switched some echos to \echo to dodge Cygwin tcsh bug
#
#  Revision 3.15  2004/06/29 03:50:14  mast
#  Added nohup
#
#  Revision 3.14  2004/03/06 21:36:14  mast
#  Converted newstack commands to command-line format
#
#  Revision 3.13  2003/10/24 02:04:25  mast
#  Add filters for Windows line endings, change tmpdir usage
#
#  Revision 3.12  2003/06/20 20:09:51  mast
#  Let tmpdir be defined and fall back to /tmp if /usr/tmp does not exist
#
#  Revision 3.11  2003/06/05 04:28:54  mast
#  Change PID output to match vmstocsh output to stderr
#
#  Revision 3.10  2003/05/22 23:35:04  mast
#  Added -P to output PID and made all startup errors include ERROR:
#
#  Revision 3.9  2003/05/13 20:16:09  mast
#  Eliminate using $0 to get temp file name, doesn't work on Windows
#
#  Revision 3.8  2003/02/07 00:01:35  mast
#  Added option to go from B to A easily
#
#  Revision 3.7  2002/12/03 21:53:32  mast
#  Made it set limits at z-0.5 and z+0.5 for clipmodel
#  Added complete error detection and reporting from each program that is run
#
#  Revision 3.6  2002/09/05 05:42:14  mast
#  Fixed output of chosen view numbers
#
#  Revision 3.5  2002/07/28 21:59:44  mast
#  Modified high-pass filter from 0.1 (which was based on default in xfalign)
#  to match new value of 0.03 for Tiltxcorr, based on alignment failures in
#  SerialEM
#
#  Revision 3.4  2002/07/28 20:23:23  mast
#  Changed to require setname argument, call repackseed with a fiducial
#  coordinate file if an appropriate on exists, and have option to call midas
#  to get the initial alignment.
#
#  Revision 3.3  2002/06/19 16:07:13  mast
#  Added option to leave temporary files
#
#  Revision 3.2  2002/05/23 04:43:12  mast
#  Changes to call repackseed and provide for Ctrl-C to stop search
#
#  Revision 3.1  2002/05/20 19:48:17  mast
#  Initial deposit into repository
#
