#!/bin/csh -f
# submfg runs a sequence of .com files and gives completion and error messages
#
#  $Author$
#
#  $Date$
#
#  $Revision$
#
#  $Log$
#  Revision 3.8  2005/03/16 17:27:25  mast
#  Passed on the error status when exiting
#
#  Revision 3.7  2004/08/27 05:46:48  mast
#  Switched to using head -n and tail -n
#
#  Revision 3.6  2004/07/07 18:56:40  mast
#  Fixed bug in scanning arguments
#
#  Revision 3.5  2004/06/29 03:41:22  mast
#  Added nice option and nohup
#
#  Revision 3.4  2004/06/24 15:32:55  mast
#  Added -c option to continue if one file fails
#
#  Revision 3.3  2004/06/15 01:55:55  mast
#  Added an option to get time output
#
#  Revision 3.2  2003/05/20 23:39:52  mast
#  Change to echo -n for "Running..." to accommodate PID output
#
#  Revision 3.1  2003/04/18 22:52:21  mast
#  Initial addition to package
#
 
if ($#argv < 1) then
cat <<EOF
subm or submfg will execute a series of command files in sequence
Usage:  submfg [options] command_file1 command_file2 ...
        Command files must have extension .com
        If the filename is comfile.com, you can enter 
                 comfile    comfile.    or  comfile.com
        submfg will execute the files in the foreground
        To run jobs in the background, set up an alias:  
               alias subm 'submfg \!* &'
        Set the environment variable SUBM_MESSAGE to modify the message upon
                completion
    Options:
        -t     report the execution time
        -c     continue with the next command file if one fails
        -n #   Run niced with # as nice increment (range 1 to 19)
EOF
exit 0
endif

if ($?IMOD_DIR) then
    set path = ($IMOD_DIR/bin $path)
endif

nohup

set message = " finished successfully"
if ($?SUBM_MESSAGE) then
    set message = $SUBM_MESSAGE
endif
set bell = ""

set dotime = 0
set comtmp = submtemp.$$
set done = 0
set continue = 0
set nice = 0

while ($#argv > 1 && $done == 0)
    switch ($argv[1])
    case -t:
        set dotime = 1
        shift
        onintr clean
        breaksw

    case -c:
        set continue = 1
        shift
        breaksw

    case -n:
        set nice = $argv[2]
        shift; shift
        onintr clean
        breaksw

    default:
        set done = 1
        breaksw
    endsw
end

while ($#argv > 0)
    set rootname = $argv[1]:r
    if (! -e $rootname.com) then
	echo ERROR: $rootname.com does not exist $bell
        set exitstat = 1
	goto clean
    endif
    echo -n "Running $rootname.com ...  "

    if ($dotime == 0 && $nice == 0) then
        vmstocsh $rootname.log < $rootname.com | csh -ef
        set exitstat = $status
    else

        # For nice or time, set up the com script, put nice in it
        echo -n >! $comtmp
        if ($nice != 0) echo nice +$nice >> $comtmp
        vmstocsh $rootname.log < $rootname.com >> $comtmp
        set exitstat = $status
        if ($exitstat == 0) then
            if ($dotime != 0) then
                time csh -ef < $comtmp
                set exitstat = $status
            else
                csh -ef < $comtmp
                set exitstat = $status
            endif
        endif
    endif
    if ($exitstat) then
	echo Error executing $rootname.com $bell
	if (-e $rootname.log) tail -n 1 $rootname.log
	if ($continue == 0) goto clean
    else
	echo $rootname.com $message
    endif
    shift
end

clean:
if ($dotime == 1 || $nice != 0) \rm -f $comtmp 
exit $exitstat
