#!/bin/csh -f
# submfg runs a sequence of .com files and gives completion and error messages
#
#  $Author$
#
#  $Date$
#
#  $Revision$
#
#  Log at end
 
if ($#argv < 1) then
cat <<EOF
subm or submfg will execute a series of command files in sequence
Usage:  submfg [options] command_file1 command_file2 ...
        Command files must have extension .com or .pcm - .com will be converted
               with vmstocsh and run with csh unless -p is given; .pcm will be
               converted with vmstopy and run with Python
        If the filename is comfile.com or comfile.pcm, you can enter 
                 comfile    comfile.  or  comfile.com or comfile.pcm
        submfg will execute the files in the foreground
        To run jobs in the background, set up an alias:  
               alias subm 'submfg \!* &'
        Set the environment variable SUBM_MESSAGE to modify the message upon
                completion
    Options:
        -t     Report the execution time
        -c     Continue with the next command file if one fails
        -p     Translate .com file with vmstopy and run with Python
        -n #   Run niced with # as nice increment (range 1 to 19)
        -q     Quiet: suppress messages and PID output
EOF
exit 0
endif

if ($?IMOD_DIR) then
    setenv PATH "$IMOD_DIR/bin:$PATH"
endif

nohup

set message = " finished successfully"
if ($?SUBM_MESSAGE) then
    set message = $SUBM_MESSAGE
endif
set bell = ""

set dotime = 0
set comtmp = submtemp.$$
set done = 0
set continue = 0
set nice = 0
set quiet = 0
set python = 0

while ($#argv > 1 && $done == 0)
    switch ($argv[1])
    case -t:
        set dotime = 1
        shift
        onintr clean
        breaksw

    case -c:
        set continue = 1
        shift
        breaksw

    case -n:
        set nice = $argv[2]
        shift; shift
        onintr clean
        breaksw

    case -p:
        set python = 1
        shift
        breaksw

    case -q:
        set quiet = 1
        shift
        breaksw

    default:
        set done = 1
        breaksw
    endsw
end

while ($#argv > 0)
    set rootname = $argv[1]:r
    set dopython = 0
    if ($argv[1] == $rootname.com || $argv[1] == $rootname.pcm) then
        set comname = $argv[1]
        if (! -e $comname) then
            echo ERROR: $comname does not exist $bell
            set exitstat = 1
            goto clean
        endif
    else if (! (-e  $rootname.com || -e $rootname.pcm)) then
	echo ERROR: Neither $rootname.com nor $rootname.pcm exists $bell
        set exitstat = 1
	goto clean
    else if (-e  $rootname.com && -e $rootname.pcm) then
	echo ERROR: Both $rootname.com or $rootname.pcm exist - enter a full name $bell
        set exitstat = 1
	goto clean
    else if (-e $rootname.com) then
        set comname = $rootname.com
    else
        set comname = $rootname.pcm
    endif        
    if ($python || ($comname == $rootname.pcm)) set dopython = 1

    if (! $quiet) echo -n "Running $rootname.com ...  "

    if ($dotime == 0 && $nice == 0) then
        if ($dopython) then
            vmstopy $comname $rootname.log | python -u
            set exitstat = $status
        else
            if ($quiet) then
                vmstocsh $rootname.log < $rootname.com | csh -ef >& /dev/null
                set exitstat = $status
            else
                vmstocsh $rootname.log < $rootname.com | csh -ef
                set exitstat = $status
            endif
        endif
    else

        if ($dopython) then
            vmstopy $comname $rootname.log $comtmp
            set exitstat = $status
            if ($exitstat == 0) then
                set comline = ""
                if ($nice != 0) set comline = "nice +$nice"
                if ($dotime) set comline = "$comline time"
                $comline python -u $comtmp
                set exitstat = $status
            endif
        else

            # For nice or time, set up the com script, put nice in it
            echo -n >! $comtmp
            if ($nice != 0) echo nice +$nice >> $comtmp
            vmstocsh $rootname.log < $rootname.com >> $comtmp
            set exitstat = $status
            if ($exitstat == 0) then
                if ($dotime != 0) then
                    time csh -ef < $comtmp
                    set exitstat = $status
                else
                    csh -ef < $comtmp
                    set exitstat = $status
                endif
            endif
        endif
    endif
    if ($exitstat) then
	if (! $quiet) echo Error executing $comname $bell
	if (-e $rootname.log) tail -n 1 $rootname.log
	if ($continue == 0) goto clean
    else
	if (! $quiet) echo $comname $message
    endif
    shift
end

clean:
if ($dotime == 1 || $nice != 0) \rm -f $comtmp 
exit $exitstat

#  $Log$
#  Revision 3.11  2006/07/03 23:10:25  mast
#  Added quiet mode for running from tiltalign
#
#  Revision 3.10  2005/11/19 04:29:07  mast
#  Quote path setting to preserve spaces
#
#  Revision 3.9  2005/03/25 18:10:02  mast
#  Added exitstat setting when com file does not exist
#
#  Revision 3.8  2005/03/16 17:27:25  mast
#  Passed on the error status when exiting
#
#  Revision 3.7  2004/08/27 05:46:48  mast
#  Switched to using head -n and tail -n
#
#  Revision 3.6  2004/07/07 18:56:40  mast
#  Fixed bug in scanning arguments
#
#  Revision 3.5  2004/06/29 03:41:22  mast
#  Added nice option and nohup
#
#  Revision 3.4  2004/06/24 15:32:55  mast
#  Added -c option to continue if one file fails
#
#  Revision 3.3  2004/06/15 01:55:55  mast
#  Added an option to get time output
#
#  Revision 3.2  2003/05/20 23:39:52  mast
#  Change to echo -n for "Running..." to accommodate PID output
#
#  Revision 3.1  2003/04/18 22:52:21  mast
#  Initial addition to package
#
