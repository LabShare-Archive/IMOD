#!/bin/csh -f
# submfg runs a sequence of .com files and gives completion and error messages
#
#  $Author$
#
#  $Date$
#
#  $Revision$
#
#  $Log$
#  Revision 3.3  2004/06/15 01:55:55  mast
#  Added an option to get time output
#
#  Revision 3.2  2003/05/20 23:39:52  mast
#  Change to echo -n for "Running..." to accommodate PID output
#
#  Revision 3.1  2003/04/18 22:52:21  mast
#  Initial addition to package
#
 
if ($#argv < 1) then
cat <<EOF
subm or submfg will execute a series of command files in sequence
Usage:  submfg [-t | -c] command_file1 command_file2 ...
        Command files must have extension .com
        If the filename is comfile.com, you can enter 
                 comfile    comfile.    or  comfile.com
        submfg will execute the files in the foreground
        To run jobs in the background, set up an alias:  
               alias subm 'submfg \!* &'
        The -t option will report the execution time
        The -c option will continue with the next command file if one fails
        Set the environment variable SUBM_MESSAGE to modify the message upon
                completion
EOF
exit 0
endif

if ($?IMOD_DIR) set path = ($IMOD_DIR/bin $path)

set message = " finished successfully"
if ($?SUBM_MESSAGE) then
    set message = $SUBM_MESSAGE
endif
set bell = ""

set dotime = 0
set comtmp = submtimer.$$
set done = 0
set continue = 0

while ($#argv > 2 && $done == 0)
    switch ($argv[1])
    case -t:
        set dotime = 1
        shift
        onintr clean
        breaksw

    case -c:
        set continue = 1
        shift
        breaksw

    default:
        set done = 1
        breaksw
    endsw
end



while ($#argv > 0)
    set rootname = $argv[1]:r
    if (! -e $rootname.com) then
	echo ERROR: $rootname.com does not exist $bell
	goto clean
    endif
    echo -n "Running $rootname.com ...  "
    if ($dotime == 0) then
        vmstocsh $rootname.log < $rootname.com | csh -ef
        set exitstat = $status
    else
        vmstocsh $rootname.log < $rootname.com >! $comtmp
        set exitstat = $status
        if ($exitstat == 0) then
            time csh -ef < $comtmp
            set exitstat = $status
        endif
    endif
    if ($exitstat) then
	echo Error executing $rootname.com $bell
	if (-e $rootname.log) tail -1 $rootname.log
	if ($continue == 0) goto clean
    else
	echo $rootname.com $message
    endif
    shift
end

clean:
if ($dotime == 1) \rm -f $comtmp 
