#!/bin/csh -f
# A script to set up command files to process volumes in chunks
#
#  $Id$
#
#  Log at end of file
#

# Set defaults for filename identifiers and tomopieces call

set masterin = INPUTFILE
set masterout = OUTPUTFILE
set pad = 8
set maxxp = -1
set maxyp = -1
set pn = chunksetup

if ($#argv < 3) then
    cat <<EOF
Usage: $pn [options] master_com_file input_image_file output_image_file
  Will create command files for chopping up a volume, performing operations
  in master_com_file, and reassembling volume
  Options:
     -p #    Pixels to pad and taper each subvolume on each edge
     -o #    Minimum # of pixels of overlap between subvolumes
     -m #    Maximum # of megavoxels in each subvolume
     -xm #   Maximum # of pieces in X direction
     -ym #   Maximum # of pieces in Y direction
     -no     No FFTs will be taken; do not adjust padding to allow FFTs
EOF
    exit 0
endif

set tmpdir = /usr/tmp
if ($?IMOD_DIR) then
    setenv PATH "$IMOD_DIR/bin:$PATH"
    if (-e "$IMOD_DIR/bin/settmpdir") source "$IMOD_DIR/bin/settmpdir"
endif

set padstring =
set overlap =
set mega =
set neednl = 0
set nofft =

while ($#argv > 3)
  switch ($argv[1])
    case -p:
      set pad = $argv[2]
      shift; shift
      breaksw

    case -o:
      set overlap = "-min $argv[2]"
      shift; shift
      breaksw

    case -m:
      set mega = "-mega $argv[2]"
      shift; shift
      breaksw

    case -xm*:
      set maxxp = $argv[2]
      shift; shift
      breaksw

    case -ym*:
      set maxyp = $argv[2]
      shift; shift
      breaksw

    case -no:
      set nofft = "-nofft"
      shift
      breaksw

    default:
        echo "Unrecognized option $argv[1]"
        exit 1
        breaksw
  endsw
end

set mastercom = `\echo "$argv[1]" | sed '/\\/s//\//g'`
set infile = `\echo "$argv[2]" | sed '/\\/s//\//g'`
set outfile = `\echo "$argv[3]" | sed '/\\/s//\//g'`

set fullroot = $mastercom:r
set rootname = $fullroot:t
set allname = $fullroot-all.com
set finishname = $fullroot-finish.com

# The input and output files may be relative to the location of the command
# file which need not be in current dir
#
set masthead = $mastercom:h
set infromhere = $infile
set cleandir = .
if ("$masthead" != "$mastercom") then
    set infromhere = $masthead/$infile
    set cleandir = $masthead
endif

if (! -e $mastercom) then
    echo "ERROR: $pn - Command file $mastercom does not exist"
    exit 1
endif

if (! -e $infromhere) then
    echo "ERROR: $pn - Image file $infile does not exist"
    exit 1
endif

set testin = `grep $masterin $mastercom`
set testout = `grep $masterout $mastercom`
if ("$testin" == "" || "$testout" == "") then
    echo "ERROR: $pn - The master command file does not contain both $masterin and $masterout"
    exit 1
endif

# Find out if need to add a newline at end of master file
#
set lastbytes = `tail -n 1 $mastercom | od -b`
@ ind = $#lastbytes - 1
if ($ind > 0) then
    @ ending = $lastbytes[$ind]
    if ($ending != 12 && $ending != 15) set neednl = 1
endif

set ranlist = `tomopieces -tomo $infromhere $mega $nofft -xp $pad -yp $pad -zp $pad $overlap -xmax $maxxp -ymax $maxyp | sed '/[[:cntrl:]]/s///g'`

if ($status) then
    echo $ranlist
    exit 1
endif

# Remove any previous files now in case the number has changed
#
\find $cleandir -type f -name  "$rootname-[0-9]*.*" -exec rm -f "{}" \;
\find $cleandir -type f -name  "$rootname-start.*" -exec rm -f "{}" \;

@ npiecex = $ranlist[1]
shift ranlist
@ npiecey = $ranlist[1]
shift ranlist
@ npiecez = $ranlist[1]
shift ranlist

cat <<EOF >! $allname
# THIS IS A COMMAND FILE TO RUN ALL THE PIECES AND PUT THEM TOGETHER
#
EOF

@ npiecetot = $npiecex * $npiecey * $npiecez
@ sumnum = 0
@ znum = 0
while ($znum < $npiecez)
    @ znum++
    @ ynum = 0
    while ($ynum < $npiecey)
        @ ynum++
        @ xnum = 0
        while ($xnum < $npiecex)
            @ xnum++
            @ sumnum++

            set numtext = $sumnum
            if ($sumnum < 10) then
                set numtext = 00"$numtext"
            else if ($sumnum < 100) then
                set numtext = 0"$numtext"
            endif
            
            set minmaxes = `echo $ranlist[1] | sed '/,/s// /g'`
            set comfile = $fullroot-$numtext.com
            set imagein = $rootname-$numtext.in
            set imageout = $rootname-$numtext.out
            cat <<EOCAT >! $comfile
\$taperoutvol -StandardInput
InputFile $infile
OutputFile $imagein
XMinAndMax $minmaxes[1],$minmaxes[2]
YMinAndMax $minmaxes[3],$minmaxes[4]
ZMinAndMax $minmaxes[5],$minmaxes[6]
TaperPadsInXYZ $pad,$pad,$pad
EOCAT
            if ("$nofft" != "") then
                cat <<EOF >> $comfile
NoFFTSizes
EOF
            endif
            cat <<EOF >> $allname
\$echo Working on piece  $sumnum  of $npiecetot
\$vmstocsh $rootname-$numtext.log < $comfile | csh -ef
EOF

            sed -e "/$masterin/s//$imagein/g" -e "/$masterout/s//$imageout/g" \
                $mastercom >> $comfile
            if ($neednl) echo "" >> $comfile
            cat <<EOF >> $comfile
\$if (-e $imagein) \\rm -f $imagein
EOF

            shift ranlist
        end
    end
end

cat <<EOCAT  >! $finishname
# THIS COMMAND FILE REASSEMBLES THE PIECES
#
\$assemblevol
$outfile
$npiecex,$npiecey,$npiecez
EOCAT

@ xnum = 0
while ($xnum < $npiecex)
    echo $ranlist[1] >> $finishname
    shift ranlist
    @ xnum++
end

@ ynum = 0
while ($ynum < $npiecey)
    echo $ranlist[1]  >> $finishname
    shift ranlist
    @ ynum++
end

@ znum = 0
while ($znum < $npiecez)
    echo $ranlist[1]  >> $finishname
    shift ranlist
    @ znum++
end
    
@ sumnum = 0
while ($sumnum < $npiecetot)
    @ sumnum++
    set numtext = $sumnum
    if ($sumnum < 10) then
        set numtext = 00"$numtext"
    else if ($sumnum < 100) then
        set numtext = 0"$numtext"
    endif

    echo ${rootname}-$numtext.out  >> $finishname
end

cat <<EOF >> $finishname
\$\\rm -f $rootname-[0-9][0-9][0-9]*.com* $rootname-[0-9][0-9][0-9]*.log*
EOF

cat <<EOF >> $allname
\$echo Reassembling pieces
\$vmstocsh $rootname-finish.log < $finishname | csh -ef
EOF


cat <<EOF

$npiecetot command files were generated and are ready to run.

You can run $allname:t (with subm) to run all command files in 
sequence, reassemble the volume, and clean up intermediate image and 
command files.

If you have multiple processors available, you can use 
  processchunks machine_list $rootname
to do these operations in parallel, where machine_list is a comma-separated 
list of available machines

Or, you can run the files individually and, when they are all done,
run $finishname:t to reassemble the volume and 
clean up intermediate files.
EOF

#
#  $Log$
#  Revision 3.14  2010/01/08 20:34:25  mast
#  Added nofft option, switched to pip input to taperoutvol
#
#  Revision 3.13  2009/12/07 20:54:09  mast
#  Make processchunks responsible for CHUNK DONE
#
#  Revision 3.12  2008/02/22 04:59:00  mast
#  Made it convert backslashes in filename inputs
#
#  Revision 3.11  2008/01/04 07:03:38  mast
#  Fixed for space in IMOD_DIR, possibly for space in tmpdir
#
#  Revision 3.10  2007/11/02 22:07:32  mast
#  Made it work from an upper directory
#
#  Revision 3.9  2005/11/19 04:31:26  mast
#  Quote path setting to preserve spaces
#
#  Revision 3.8  2005/05/12 20:59:08  mast
#  Handle case of missing newline in master com  file
#
#  Revision 3.7  2004/07/22 18:17:20  mast
#  Change to better sed command for stripping Ctrl M
#
#  Revision 3.6  2004/06/29 02:46:36  mast
#  Removed all parallel script code and -f option because of new
#  processchunks script
#
#  Revision 3.5  2004/06/24 23:07:29  mast
#  Made parallel script run the finish when done, and report on numbers of
#  ones undone upon interrupt
#
#  Revision 3.4  2004/06/24 15:33:28  mast
#  Added -c option to subm and an if test to the removal of input file
#
#  Revision 3.3  2004/06/23 19:27:05  mast
#  Fixed missing endif
#
#  Revision 3.2  2004/06/19 21:01:03  mast
#  Added a monitor for parallel script and took care of case of # of machines
#  > # of chunks
#
#  Revision 3.1  2004/06/17 16:00:53  mast
#  Initial creation
