#!/bin/csh -f
# A script to set up command files to process volumes in chunks
#
#  $Author$
#
#  $Date$
#
#  $Revision$
#
#  $Log$
#  Revision 3.1  2004/06/17 16:00:53  mast
#  Initial creation
#

# Set defaults for filename identifiers and tomopieces call

set masterin = INPUTFILE
set masterout = OUTPUTFILE
set pad = 8
set maxxp = -1
set maxyp = -1
set pn = chunksetup

if ($#argv < 3) then
    cat <<EOF
Usage: $pn [options] master_com_file input_image_file output_image_file
  Will create command files for chopping up a volume, performing operations
  in master_com_file, and reassembling volume
  Options:
     -p #    Pixels to pad and taper each subvolume on each edge
     -o #    Minimum # of pixels of overlap between subvolumes
     -m #    Maximum # of megavoxels in each subvolume
     -xm #   Maximum # of pieces in X direction
     -ym #   Maximum # of pieces in Y direction
     -f list Farm out chunks to machines in list (comma-separated, no spaces)
EOF
    exit 0
endif

set tmpdir = /usr/tmp
if ($?IMOD_DIR) then
    set path = ($IMOD_DIR/bin $path)
    if (-e $IMOD_DIR/bin/settmpdir) source $IMOD_DIR/bin/settmpdir
endif

set padstring =
set overlap =
set mega =

while ($#argv > 3)
  switch ($argv[1])
    case -p:
      set pad = $argv[2]
      shift; shift
      breaksw

    case -o:
      set overlap = "-min $argv[2]"
      shift; shift
      breaksw

    case -m:
      set mega = "-mega $argv[2]"
      shift; shift
      breaksw

    case -xm*:
      set maxxp = $argv[2]
      shift; shift
      breaksw

    case -ym*:
      set maxyp = $argv[2]
      shift; shift
      breaksw

    case -f:
      set farmout = `echo $argv[2] | sed '/,/s// /g'`
      shift; shift
      breaksw

    default:
        echo "Unrecognized option $argv[1]"
        exit 1
        breaksw
  endsw
end

set mastercom = $argv[1]
set infile = $argv[2]
set outfile = $argv[3]

set rootname = $mastercom:r
set allname = $rootname-all.com
set finishname = $rootname-finish.com

if (! -e $mastercom) then
    echo "Command file $mastercom does not exist"
    exit 1
endif

if (! -e $infile) then
    echo "Image file $infile does not exist"
    exit 1
endif

set testin = `grep $masterin $mastercom`
set testout = `grep $masterout $mastercom`
if ("$testin" == "" || "$testout" == "") then
    echo "The master command file does not contain both $masterin and $masterout"
    exit 1
endif

set ranlist = `tomopieces -tomo $infile $mega -xp $pad -yp $pad -zp $pad $overlap -xmax $maxxp -ymax $maxyp | sed '/[^ -z]/s///g'`

if ($status) then
    echo $ranlist
    exit 1
endif

@ npiecex = $ranlist[1]
shift ranlist
@ npiecey = $ranlist[1]
shift ranlist
@ npiecez = $ranlist[1]
shift ranlist

cat <<EOF >! $allname
# THIS IS A COMMAND FILE TO RUN ALL THE PIECES AND PUT THEM TOGETHER
#
EOF

@ npiecetot = $npiecex * $npiecey * $npiecez
@ sumnum = 0
@ znum = 0
while ($znum < $npiecez)
    @ znum++
    @ ynum = 0
    while ($ynum < $npiecey)
        @ ynum++
        @ xnum = 0
        while ($xnum < $npiecex)
            @ xnum++
            @ sumnum++

            set numtext = $sumnum
            if ($sumnum < 10) then
                set numtext = 00"$numtext"
            else if ($sumnum < 100) then
                set numtext = 0"$numtext"
            endif
            
            set comfile = $rootname-$numtext.com
            set imagein = $rootname-$numtext.in
            set imageout = $rootname-$numtext.out
            cat <<EOCAT >! $comfile
\$taperoutvol
$infile
$imagein
$ranlist[1]
$pad,$pad,$pad
EOCAT
            cat <<EOF >> $allname
\$echo Working on piece  $sumnum  of $npiecetot
\$vmstocsh $rootname-$numtext.log < $comfile | csh -ef
EOF

            sed -e "/$masterin/s//$imagein/g" -e "/$masterout/s//$imageout/g" \
                $mastercom >> $comfile
            cat <<EOF >> $comfile
\$\\rm $imagein
\$echo CHUNK DONE
EOF

            shift ranlist
        end
    end
end

cat <<EOCAT  >! $finishname
# THIS COMMAND FILE REASSEMBLES THE PIECES
#
\$assemblevol
$outfile
$npiecex,$npiecey,$npiecez
EOCAT

@ xnum = 0
while ($xnum < $npiecex)
    echo $ranlist[1] >> $finishname
    shift ranlist
    @ xnum++
end

@ ynum = 0
while ($ynum < $npiecey)
    echo $ranlist[1]  >> $finishname
    shift ranlist
    @ ynum++
end

@ znum = 0
while ($znum < $npiecez)
    echo $ranlist[1]  >> $finishname
    shift ranlist
    @ znum++
end
    
@ sumnum = 0
while ($sumnum < $npiecetot)
    @ sumnum++
    set numtext = $sumnum
    if ($sumnum < 10) then
        set numtext = 00"$numtext"
    else if ($sumnum < 100) then
        set numtext = 0"$numtext"
    endif

    echo ${rootname}-$numtext.out  >> $finishname
end

cat <<EOF >> $finishname
\$\\rm -f $rootname-[0-9]*.*
EOF

cat <<EOF >> $allname
\$echo Reassembling pieces
\$vmstocsh $rootname-finish.log < $finishname | csh -ef
EOF

if ($?farmout) then
    set parallel = $rootname-parallel
    cat <<EOF >! $parallel
#!/bin/csh -f
\rm -f $rootname-[0-9]*.log
EOF
    set thishost = `hostname`
    set hostroot = $thishost:r:r:r
    set curdir = `pwd | sed "/localscratch/s//scratch\/$hostroot/"`
    @ numproc = $#farmout
    @ basenum = $npiecetot / $numproc
    @ extra = $npiecetot - $basenum * $numproc
    @ proc = 0
    @ sumnum = 0
    @ limit = 0
    while ($proc < $numproc)
        @ proc++
        @ limit += $basenum
        if ($proc <= $extra) @ limit++
        set coms = ()
        while ($sumnum < $limit)
            @ sumnum++
            set numtext = $sumnum
            if ($sumnum < 10) then
                set numtext = 00"$numtext"
            else if ($sumnum < 100) then
                set numtext = 0"$numtext"
            endif
            set coms = ($coms $rootname-$numtext)
        end
        if ($#coms > 0) then
            cat <<EOF >> $parallel
ssh $farmout[$proc] "cd $curdir ; subm $coms" &
EOF
        endif
    end
    cat <<EOF >> $parallel
set flags = ()
@ num = 0
while (\$num < $npiecetot)
    @ num++
    set flags = (\$flags 0)
end
@ numdone = 0
@ lastdone = 0
while (\$numdone < $npiecetot)
    sleep 3
    @ num = 0
    @ numdone = 0
    while (\$num < $npiecetot)
        @ num++
        if (\$flags[\$num] == 0) then
            set numtext = \$num
            if (\$num < 10) then
                set numtext = 00"\$num"
            else if (\$num < 100) then
                set numtext = 0"\$num"
            endif
            if (-e $rootname-\$numtext.log) then
                set lastline = "\`tail -1 $rootname-\$numtext.log\`"
                if ("\$lastline" == "CHUNK DONE") set flags[\$num] = 1
            endif
        endif
        if (\$flags[\$num] == 1) @ numdone++
    end
    
    if (\$numdone > \$lastdone) echo \$numdone DONE SO FAR
    @ lastdone = \$numdone
end
echo "ALL DONE"
EOF


    chmod a+x $parallel
endif

cat <<EOF

$npiecetot command files were generated and are ready to run.

You can run them individually (e.g., some on different machines or processors)
and, when they are all done, run $finishname to reassemble the 
volume and clean up intermediate image and command files.

Or, you can just run $allname to run all files in sequence, 
reassemble, and clean up.
EOF

if ($?farmout) then
cat <<EOF

Run the shell script, $rootname-parallel to use the $numproc different processors.  
Just run this directly (without subm) to start all of the processes.
EOF
