#! /bin/csh -f
# INTERACTIVE OR COMMAND-LINE SHELL SCRIPT TO MAKE INITIAL COMMAND FILE FOR 
# JOINING TOMOGRAMS
#
#  $Id$
#  Log at end of file
#

set MIDASLIMIT = 1024
set pn = "makejoincom"
set version = 4
set defdir = ""
set defsrcext = "rec"
set deftmpext = "tmp"
set joincom = "startjoin.com"
set reclist = ""
set fliplist = ""
set invertlist = ""
set botlist = ""
set toplist = ""
set anglelist = ""
set sizelist = ""
set angleoplist = ""
set sizeoplist = ""
set ifrotlist = ""
set didrotlist = ""
set chunklist = ""
set avglist = ""
set scalelist = ""
@ scaleref = 1
set newmode = 0

setenv LC_NUMERIC C

if ($?IMOD_DIR) then
    setenv PATH "$IMOD_DIR/bin:$PATH"
endif

chmod u+rwx .

if ($#argv > 0) then
    set interactive = 0
    @ listsize = $#argv
else
    set interactive = 1

    echo " "
    echo "This program will set up a command file to do the initial steps in"
    echo "joining tomograms from serial sections."
    echo "You can run it with command line arguments (enter -h to see options)."
    echo "Or you can run it interactively; just answer each of the questions in turn."
    echo "To interrupt, type Ctrl-C then Return."
    echo " "
    echo "When you enter the name of a tomogram file, you can enter just the root"
    echo "name without a directory path or extension.  In this case, the program"
    echo "will add a default directory path (if any) and the appropriate default"
    echo "extension ($defsrcext).  If you enter a name with a"
    echo "directory path, it will override the default path; if you enter a name"
    echo "with an extension, it will override the default extension."
    echo ""

    @ ntomo = 0
    while ($ntomo < 2)
        echo -n "Enter number of tomograms to be joined: "
        @ ntomo = $<
        if ($ntomo < 2) then
            @ ntomo = 0
            echo "No good, try again"
        endif
    end
    @ listsize = $ntomo
endif

# set up the wordlists to be big enough
@ ind = 0
while ($ind < $listsize)
    @ ind++
    set reclist = ($reclist "0")
    set fliplist = ($fliplist "0")
    set botlist = ($botlist "0")
    set toplist = ($toplist "0")
    set angleoplist = ($angleoplist "0")
    set sizeoplist = ($sizeoplist "0")
    set ifrotlist = ($ifrotlist "0")
    set didrotlist = ($didrotlist "0")
end

if ($interactive == 0) then
    # PROCESS COMMAND LINE ARGUMENTS

    @ ntomo = 0
    set botrange = 0
    set toprange = 0
    set ifflip = 0
    set rotangle = 0
    set rotsize = 0
    set didrot = 0
    if ("$argv[1]" == "-h" || "$argv[1]" == "-help") goto usage
    while ($#argv > 1)
      switch ("$argv[1]")
        case -h*:
          goto usage
          breaksw
        case -to*:
          set toprange = "$argv[2]"
          set sizetmp = `echo $argv[2] | sed 's/[,-]/ /g'`
          if ($#sizetmp < 2) then
            echo "ERROR: $pn - top range entry $argv[2] does not have 2 values"
            exit 1
          endif
          shift; shift
          breaksw
        case -b*:
          set botrange = "$argv[2]"
          set sizetmp = `echo $argv[2] | sed 's/[,-]/ /g'`
          if ($#sizetmp < 2) then
            echo "ERROR: $pn - bottom range entry $argv[2] does not have 2 values"
            exit 1
          endif
          shift; shift
          breaksw
        case -fl*:
          set ifflip = 1
          shift
          breaksw
        case -ro*:
          set ifflip = 2
          set rotangle = "$argv[2]"
          set sizetmp = `echo $argv[2] | sed 's/,/ /g'`
          if ($#sizetmp < 3) then
            echo "ERROR: $pn - angle entry $argv[2] does not have 3 values"
            exit 1
          endif
          shift ; shift
          breaksw
        case -a*:
          set didrot = 1
          shift
          breaksw
        case -x*:
          set rotsize = "$argv[2]"
          set sizetmp = `echo $argv[2] | sed 's/,/ /g'`
          if ($#sizetmp < 3) then
            echo "ERROR: $pn - size entry $argv[2] does not have 3 values"
            exit 1
          endif
          shift; shift
          breaksw
        case -d*:
          set defdir = "$argv[2]"
          shift; shift
          breaksw
        case -s*:
          set defsrcext = "$argv[2]"
          shift; shift
          breaksw
        case -tm*:
          set deftmpext = "$argv[2]"
          shift; shift
          breaksw

        case -mi*:
          set MIDASLIMIT = "$argv[2]"
          shift; shift
          breaksw

        case -re*:
          @ scaleref = "$argv[2]"
          shift; shift
          breaksw

        case -ma*:
          set rotsize = "maxxy"
          shift
          breaksw
        case -fu*:
          set rotsize = "full"
          shift
          breaksw

        default:

          # Non-option entry should be filename, but check first for bad option
          set badtest = ` echo $argv[1] | grep '^-'`
          if ($badtest != "") then
              echo "ERROR: $pn - Unrecognized option entry $argv[1]"
              exit 1
          endif

          # This is the next filename, save it in list, save the other
          # entries in their list and rezero the entries
          @ ntomo++
          set reclist[$ntomo] = "$argv[1]"
          set botlist[$ntomo] = "$botrange"
          set toplist[$ntomo] = "$toprange"
          set angleoplist[$ntomo] = "$rotangle"
          set sizeoplist[$ntomo] = "$rotsize"
          set ifrotlist[$ntomo] = $ifflip
          set didrotlist[$ntomo] = $didrot
          set botrange = 0
          set toprange = 0
          set ifflip = 0
          set rotangle = 0
          set rotsize = 0
          set didrot = 0
          shift
          breaksw
      endsw
    end

    # Make sure there are not orphan option entries
    if ("$botrange" != 0 || "$toprange" != 0 || "$ifflip" != 0 || \
        "$rotangle" != 0 || "$rotsize" != 0 || "$didrot" != 0) then
        echo "ERROR: $pn - You entered option(s) for another tomogram without"
        echo "entering both another tomogram name and the root name for output files"
        exit 1
    endif

    if ($ntomo < 2) then
        echo "ERROR: $pn - You must specify at least two tomograms"
        exit 1
    endif

    if ($scaleref < 1 || $scaleref > $ntomo) then
        echo "ERROR: $pn - Illegal number for tomogram to use as scaling reference"
        exit 1
    endif

    # Check for all top and bottom entries

    if ($toplist[$ntomo] != "0") then
        echo "ERROR: $pn - The last tomogram should not have a top entry"
        exit 1
    endif
    if ($botlist[1] != "0") then
        echo "ERROR: $pn - The first tomogram should not have a bottom entry"
        exit 1
    endif

    @ itomo = 1
    while ($itomo < $ntomo)
        if ($toplist[$itomo] == "0") then
            echo "ERROR: $pn - You did not enter a top range for tomogram # $itomo"
            exit 1
        endif
        @ itomo++
        if ($botlist[$itomo] == "0") then
            echo "ERROR: $pn - You did not enter a bottom range for tomogram # $itomo"
            exit 1
        endif
    end

    set joinroot = $argv[1]
else

    # INTERACTIVE: GET THE DEFAULTS FOR DIRECTORY AND EXTENSIONS

    echo "Enter the default directory for source tomograms, or Return to use"
    echo -n " the current directory by default: "
    set defdir = "$<"

    echo -n "Enter the default extension for original tomograms (Return for $defsrcext): "
    set defin = $<
    if ($defin != "") set defsrcext = $defin

    echo "Enter the default extension for temporary tomogram files to be created "
    echo -n "by flipping or rotating, if any (Return for $deftmpext): "
    set defin = $<
    if ($defin != "") set deftmpext = $defin

    @ scaleref = 0
    while ($scaleref < 1 || $scaleref > $ntomo) 
        @ scaleref = 1
        echo "Enter number of tomogram to use as reference for "
        echo -n "density scaling (Return for 1): "
        set defin = $<
        if ($defin != "") @ scaleref = $defin
    end

endif

# Convert backslashes in default directory, make sure it is still one word
#
if ("$defdir" != "")then
    set defdir = `\echo "$defdir" | sed '/\\/s//\//g'`
    set defdir = "$defdir"
endif

# LOOP ON TOMOS

@ nxmax = 0
@ nymax = 0
@ itomo = 1
while ($itomo <= $ntomo)
    set rotsize = (0 0 0)
    set rotangle = (0 0 0)
    set bigrot = 0
    if ($interactive) then
        echo -n "Name of tomogram # ${itomo}: "
        set namein = "$<"

        set didrot = 0
        set ifflip = "-1"
        while ($ifflip == "-1")
            echo "Enter A if this tomogram is Already flipped, F to Flip it with Clip,"
            echo " R to Rotate it with Rotatevol"
            echo -n " or D if rotation was done on a previous run of startjoin.com: "
            set flipin = $<
            if ("$flipin" == "r" || "$flipin" == "R") set ifflip = "2"
            if ("$flipin" == "f" || "$flipin" == "F") set ifflip = "1"
            if ("$flipin" == "a" || "$flipin" == "A") set ifflip = "0"
            if ("$flipin" == "d" || "$flipin" == "D") then
                set ifflip = "2"
                set didrot = 1
            endif
        end
    else

        set namein = "$reclist[$itomo]"
        set ifflip = $ifrotlist[$itomo]
        set didrot = $didrotlist[$itomo]
    endif

    # DECOMPOSE FILENAME INTO HEADER, ROOT AND TAIL

    # First convert backslashes, quoting to retain them, then
    # copy variable again with quotes to reduce to one word, needed for :t
    #
    set namein = `\echo "$namein" | sed '/\\/s//\//g'`
    set namein = "$namein"

    set tail = "$namein:t"
    set header = ""
    if ("$tail" == "$namein") then
	if ("$defdir" != "")set header = "$defdir/"
    else
	set header = "$namein:h""/"
    endif
    set root = "$tail:r"

    # COMPOSE FILENAMES FOR SOURCE AND FLIPPED FILES, GET SIZE
    # Source file needs its backslashes converted and must be quoted in header
    # All backslash conversions must use system echo!  tcsh strips at \c

    if ("$tail" == "$root") then
        set recsource = "$header$root.$defsrcext"
    else
        set recsource = "$header$tail"
    endif
    if (-e "$recsource") then
        set size = `header -si "$recsource" | sed '/[[:cntrl:]]/s///g'`
    else
        set size = (1024 1024 100)
        echo "WARNING: $recsource NOT FOUND; SETTING SIZE TO $size FOR TEST PURPOSES"
    endif
    @ nx = $size[1]
    @ ny = $size[2]
    @ nz = $size[3]

    if ($ifflip != "0") then

	# IF FLIPPING, THEN NEED A REC SOURCE AND FLIP SOURCE

	set flipsource = "$root.$deftmpext"

        # If flipping, or if ny < nz and rotating, swap ny and nz
        if ($ny < $nz) set bigrot = 1
        if ($ifflip == 1 || $ny < $nz) then
            @ ny = $size[3]
            @ nz = $size[2]
        endif
    else

	# IF ALREADY FLIPPED, SET FLIP SOURCE SAME

        set flipsource = "$recsource"
    endif

    @ nxformax = $nx
    @ nyformax = $ny

#    # SAVE SIZE OF FIRST VOLUME FOR COMPUTING SIZE OF NEWSTACK OUTPUT
#    if ($itomo == 1) then
#	@ firstnx = $nx
#	@ firstny = $ny
#    endif

    # IF DOING ROTATEVOL, GET THE SIZE OF OUTPUT FILE AND THE ANGLES

    if ($ifflip == "2") then
        if ($interactive) then
            set ifok = "0"
            while ($ifok == "0")
                set defrotsize = "$nx,$ny,$nz"
                echo -n "Enter size of file after rotating (Return for $defrotsize): "
                set rotentry = $<
                if ($rotentry == "") set rotentry = $defrotsize
                set rotsize = `echo $rotentry | sed 's/,/ /g'`
                if ($#rotsize == 3) then
                    set ifok = "1"
                else
                    echo "You must enter 3 values, try again"
                endif
            end
        else
            if ($sizeoplist[$itomo] == "0") then
                set rotsize = ($nx $ny $nz)
            else if ($sizeoplist[$itomo] == "maxxy" || $sizeoplist[$itomo] == "full") then
                set rotangle = `echo $angleoplist[$itomo] | sed 's/,/ /g'`
                set rotsize = `rotatevol -query -ang $rotangle[3],$rotangle[2],$rotangle[1]  "$recsource"`
                if ($#rotsize < 3) then
                    echo "ERROR: makejoincom - rotatevol size query failed on $recsource"
                    exit 1
                endif
                if ($sizeoplist[$itomo] == "maxxy") set rotsize[3] = $nz
                echo "Dimensions of $flipsource will be $rotsize"
            else
                set rotsize = `echo $sizeoplist[$itomo] | sed 's/,/ /g'`
            endif
        endif

        @ newnz = $rotsize[3]
	@ nxformax = $rotsize[1]
	@ nyformax = $rotsize[2]

#	if ($itomo == 1) then
#	    @ firstnx = $rotsize[1]
#	    @ firstny = $rotsize[2]
#	endif

	set ifok = "0"
        if ($interactive) then
            while ($ifok == "0")
                echo -n "Enter rotation angles around X, Y, and Z axes from slicer: "
                set rotentry = $<
                set rotangle = `echo $rotentry | sed 's/,/ /g'`
                if ($#rotangle == 3) then
                    set ifok = "1"
                else
                    echo "You must enter 3 values, try again"
                endif
            end
            if ($bigrot) then
                echo "Use slice numbers from the unrotated file to specify the slices to extract."
                echo "These values will be adjusted to the right values for the rotated file."
            endif
        else

            set rotangle = `echo $angleoplist[$itomo] | sed 's/,/ /g'`
        endif
    endif

    # KEEP TRACK OF MAXIMUM NX, NY AND MODE
    if ($nxformax > $nxmax) @ nxmax = $nxformax
    if ($nyformax > $nymax) @ nymax = $nyformax

    # GET THE SLICES TO EXTRACT FROM BOTTOM OF SECTION

    @ chunksize = 0
    set botrange = "0"
    if ($itomo > 1) then
	set botrange = ""
	while ($botrange == "")
            if ($interactive) then
                echo -n "Enter starting & ending slices to extract from bottom of section: "
                set zin = "$<"
            else
                set zin = "$botlist[$itomo]"
            endif
	
	    set zentry = `echo $zin | sed '/[,-]/s// /g'`
	    if ($#zentry < 2) then
                echo "You must enter two numbers, try again"
	    else
		@ zst = $zentry[1]
		@ znd = $zentry[2]
		@ zst--
		@ znd--
		if ($zst < 0 || $zst >= $nz || $znd < 0 || $znd >= $nz) then
                    if ($interactive) then
                        echo "Coordinates out of range, try again"
                    else
                        echo "ERROR: $pn - bottom entry for tomogram #$itomo has coordinates out of range"
                        exit 1
                    endif
		else

		    # IF USING ROTATEVOL, NEED TO ADJUST SLICE NUMBERS
                    # bigrot case rotates the Y axis of an unflipped volume
                    # Other case is needed for rotation of Z in flipped vol
                    #
		    if ($ifflip == "2") then
                        if ($bigrot == 1) then
                            @ zst = `echo "$rotangle $nz $newnz $zst" | awk '{print int((cos(0.0174533 * $1) * sin(0.0174533 * $2) * sin(0.0174533 * $3) + sin(0.0174533 * $1) * cos(0.0174533 * $3)) * ($6 - 0.5 * ($4 - 1)) + 0.5 * $5)}'`
                            @ znd = `echo "$rotangle $nz $newnz $znd" | awk '{print int((cos(0.0174533 * $1) * sin(0.0174533 * $2) * sin(0.0174533 * $3) + sin(0.0174533 * $1) * cos(0.0174533 * $3)) * ($6 - 0.5 * ($4 - 1)) + 0.5 * $5)}'`
                        else
                            @ zst = `echo "$rotangle $nz $newnz $zst" | awk '{print int(cos(0.0174533 * $1) * cos(0.0174533 * $2) * ($6 - 0.5 * ($4 - 1)) + 0.5 * $5)}'`
                            @ znd = `echo "$rotangle $nz $newnz $znd" | awk '{print int(cos(0.0174533 * $1) * cos(0.0174533 * $2) * ($6 - 0.5 * ($4 - 1)) + 0.5 * $5)}'`
                        endif
#			echo rotated z: $zst  $znd
                    endif
		    
		    # FIGURE OUT IF INVERTING, AND PROPER ORDER FOR EXTRACTION

		    set ifinvert = "0"
		    if ($zst > $nz / 2) set ifinvert = "1"
		    if (($zst < $znd && $ifinvert == "0") || ($zst >= $znd && $ifinvert == "1")) then
			set zstout = $zst
			set zndout = $znd
		    else
			set zstout = $znd
			set zndout = $zst
			endif
		    set botrange = $zstout"-"$zndout
		    if ($zst == $znd) set botrange = $zst
                    if ($znd >= $zst) then
                        @ chunksize = $znd + 1 - $zst
                    else
                        @ chunksize = $zst + 1 - $znd
                    endif
                    set avglist = ($avglist $chunksize)
		endif
	    endif
	end
    endif

    # GET SLICE NUMBERS TO EXTRACT AT TOP

    set toprange = "0"
    if ($itomo < $ntomo ) then
	set toprange = ""
	while ($toprange == "")
            if ($interactive) then
                echo -n "Enter starting & ending slices to extract from top of section: "
                set zin = "$<"
            else
                set zin = "$toplist[$itomo]"
            endif
	
	    set zentry = `echo $zin | sed '/[,-]/s// /g'`
	    if ($#zentry < 2) then
		echo "You must enter two numbers, try again"
	    else
		@ zst = $zentry[1]
		@ znd = $zentry[2]
		@ zst--
		@ znd--
		if ($zst < 0 || $zst >= $nz || $znd < 0 || $znd >= $nz) then
                    if ($interactive) then
                        echo "Coordinates out of range, try again"
                    else
                        echo "ERROR: $pn - top entry for tomogram #$itomo has coordinates out of range"
                        exit 1
                    endif
		else

		    # IF USING ROTATEVOL, NEED TO ADJUST SLICE NUMBERS

		    if ($ifflip == "2") then
                        if ($bigrot == 1) then
                            @ zst = `echo "$rotangle $nz $newnz $zst" | awk '{print int((cos(0.0174533 * $1) * sin(0.0174533 * $2) * sin(0.0174533 * $3) + sin(0.0174533 * $1) * cos(0.0174533 * $3)) * ($6 - 0.5 * ($4 - 1)) + 0.5 * $5)}'`
                            @ znd = `echo "$rotangle $nz $newnz $znd" | awk '{print int((cos(0.0174533 * $1) * sin(0.0174533 * $2) * sin(0.0174533 * $3) + sin(0.0174533 * $1) * cos(0.0174533 * $3)) * ($6 - 0.5 * ($4 - 1)) + 0.5 * $5)}'`
                        else
                            @ zst = `echo "$rotangle $nz $newnz $zst" | awk '{print int(cos(0.0174533 * $1) * cos(0.0174533 * $2) * ($6 - 0.5 * ($4 - 1)) + 0.5 * $5)}'`
                            @ znd = `echo "$rotangle $nz $newnz $znd" | awk '{print int(cos(0.0174533 * $1) * cos(0.0174533 * $2) * ($6 - 0.5 * ($4 - 1)) + 0.5 * $5)}'`
                        endif
#			echo rotated z: $zst  $znd
		    endif
		    
		    # FIGURE OUT IF INVERTING, AND PROPER ORDER FOR EXTRACTION

		    set ifinvert = "0"
		    if ($znd < $nz / 2) set ifinvert = "1"
		    if (($zst < $znd && $ifinvert == "0") || ($zst >= $znd && $ifinvert == "1")) then
			set zstout = $zst
			set zndout = $znd
		    else
			set zstout = $znd
			set zndout = $zst
		    endif
		    set toprange = $zstout"-"$zndout
		    if ($zst == $znd) set toprange = $zst
                    if ($znd >= $zst) then
                        @ chunkadd = $znd + 1 - $zst
                    else
                        @ chunkadd = $zst + 1 - $znd
                    endif
                    @ chunksize += $chunkadd
                    set avglist = ($avglist $chunkadd)
		endif
	    endif
	end
    endif

    # ADD ALL PARAMETERS TO THE INDEXABLE WORDLISTS 

    set reclist[$itomo] = "$recsource"
    set fliplist[$itomo] = "$flipsource"
    set botlist[$itomo] = $botrange
    set toplist[$itomo] = $toprange
    set invertlist = ($invertlist $ifinvert)
    set sizelist = ($sizelist $rotsize)
    set anglelist = ($anglelist $rotangle)
    set ifrotlist[$itomo] = $ifflip
    set didrotlist[$itomo] = $didrot
    if ($itomo > 1) set chunklist = ${chunklist},
    set chunklist = ${chunklist}$chunksize

    @ itomo++
end

if ($interactive) then
    echo -n "Enter root name for joined tomogram and other files: "
    set joinroot = $<
endif

# WORK OUT WHETHER SQUEEZING IS NEEDED, SET UP TRANSFORMS

@ xymax = $nxmax
if ($nymax > $nxmax) @ xymax = $nymax
set ifsquoze = "0"
set newsize = "$nxmax,$nymax"
if ($xymax > $MIDASLIMIT) then
    set ifsquoze = "1"
    set squeeze = `echo $xymax ${MIDASLIMIT}'.' | awk '{print $2 / $1}'`
    set expand = `echo $xymax ${MIDASLIMIT}'.' | awk '{print $1 / $2}'`
    set newx = `echo $nxmax $squeeze | awk '{print int($1 * $2)}' | goodframe | sed '/[[:cntrl:]]/s///g'`
    set newy = `echo $nymax $squeeze | awk '{print int($1 * $2)}' | goodframe | sed '/[[:cntrl:]]/s///g'`
    set newsize = "$newx,$newy"
    if (-e $joinroot.sqzxf) \mv $joinroot.sqzxf $joinroot.sqzxf~
    if (-e $joinroot.xpndxf) \mv $joinroot.xpndxf $joinroot.xpndxf~
    echo "$squeeze 0. 0. $squeeze 0. 0." > $joinroot.sqzxf
    echo "$expand 0. 0. $expand 0. 0." > $joinroot.xpndxf
endif

# GET THE SCALING
@ itomo = 1
while ($itomo <= $ntomo)
    if ($itomo == $scaleref) then
        set scaling = (1. 0.)
        set newmode = `header -mo "$reclist[$itomo]" | sed '/[[:cntrl:]]/s///g'`
        if ($#newmode == 0) set newmode = 0
    else
        echo "Determining scaling for tomogram # $itomo ..."
        set scaling = `densmatch -report "$reclist[$scaleref]" "$reclist[$itomo]" | sed -n -e '/[[:cntrl:]]/s///g' -e '/Scale factor.*:/s///p'`
    endif
    if ($#scaling < 2) then
        echo "WARNING: Densmatch failed for tomogram # $itomo ; using 1.,0. for scaling"
        set scaling = (1. 0.)
    endif        
    set scalelist = ($scalelist $scaling[1],$scaling[2])
    @ itomo++
end

# OUTPUT INFO FILE

if (-e $joinroot.info) \mv $joinroot.info $joinroot.info~
echo "$ntomo  $ifsquoze  $nxmax  $nymax $version $newmode" > $joinroot.info
echo $invertlist >> $joinroot.info
echo $scalelist >> $joinroot.info

# OUTPUT THE FILE NAMES
@ itomo = 1
while ($itomo <= $ntomo)
    echo "$fliplist[$itomo]" >> $joinroot.info
    @ itomo++
end

# COMPOSE THE COMMAND FILE

if (-e $joincom) \mv $joincom $joincom~

echo -n > $joincom

# LOOP THROUGH THE FILES, FLIP OR ROTATE IF NECESSARY, AND DENSMATCH

@ itomo = 1
while ($itomo <= $ntomo)
    @ indx = 3 * $itomo - 2
    @ indy = $indx + 1
    @ indz = $indy + 1
    if ($ifrotlist[$itomo] == "1") then
	echo '$clip'" flipyz $reclist[$itomo] $fliplist[$itomo]" >> $joincom
    else if ($ifrotlist[$itomo] == "2" && $didrotlist[$itomo] == "0") then
	cat >> $joincom <<EOF
\$rotatevol
$reclist[$itomo]
$fliplist[$itomo]

$sizelist[$indx],$sizelist[$indy],$sizelist[$indz]
/
$anglelist[$indz],$anglelist[$indy],$anglelist[$indx]
EOF
    endif
    @ itomo++
end

# NOW CREATE THE NEWSTACK COMMAND

echo '$newstack -StandardInput' >> $joincom
@ itomo = 1
while ($itomo <= $ntomo)
    echo "InputFile $fliplist[$itomo]" >> $joincom
    if ($itomo == 1) then
	echo "SectionsToRead $toplist[$itomo]" >> $joincom 
    else if ($itomo == $ntomo) then
	echo "SectionsToRead $botlist[$itomo]" >> $joincom 
    else
	echo "SectionsToRead $botlist[$itomo],$toplist[$itomo]" >> $joincom 
    endif
    echo "MultiplyAndAdd $scalelist[$itomo]" >> $joincom
    
    @ itomo++
end

echo "ModeToOutput $newmode" >> $joincom
echo "OutputFile $joinroot.sample" >> $joincom
echo "SizeToOutputInXandY $newsize" >> $joincom

if ($ifsquoze == "1") echo "TransformFile $joinroot.sqzxf" >> $joincom

# Now make the average commands
@ ind = 0
@ startsec = 0
set tmplist = ""
while ($ind < $#avglist)
    @ ind++
    @ numavg = $avglist[$ind]
    @ endsec = $startsec + $numavg - 1
    cat >> $joincom <<EOF
\$avgstack
$joinroot.sample
$joinroot.tmpavg.$ind
$startsec,$endsec
EOF
    @ startsec += $numavg
    set tmplist = ($tmplist $joinroot.tmpavg.$ind)
end

echo '$newstack -StandardInput' >> $joincom
echo "OutputFile $joinroot.sampavg" >> $joincom
foreach i ($tmplist)
    echo "InputFile $i" >> $joincom
end

cat >> $joincom <<EOF
\$\\rm -f $joinroot.tmpavg.*
EOF

cat <<EOF

The command file $joincom has been written and is ready to submit.
Run it to create the files $joinroot.sample and $joinroot.sampavg
For optional automatic alignment of the top/bottom averages, try:
   xfalign -tomo -pre $joinroot.sampavg $joinroot.xf
Then run:
   midas -c $chunklist $joinroot.sample $joinroot.xf
to run midas in chunk alignment mode and create or edit the transform file
For optional automatic refinement of transforms, then try:
   xfalign -tomo -ini $joinroot.xf $joinroot.sampavg $joinroot.xf
(after which you should check results with the midas command again).
Finally run finishjoin to create the joined tomogram
EOF
exit 0

usage:
cat <<EOF
Usage: makejoincom [options] tomogram1 [options] tomogram2 ... root_name
  Tomogram names may be full paths and contain extensions, or can omit a
      default path or extension.  The path may contain spaces, in which case
      you must enclose the whole tomogram name in double quotes ("...").
  Root_name is the root name for various output files.
  Options may be abbreviated to one or 2 unique letters.
  Options applying to one tomogram (all such options must be entered before the
      respective tomogram name):
    -top #,#        Starting and ending slices of sample from top of section
    -bottom #,#     Starting and ending slices of sample from bottom of section
    -flip           Flip Y and Z of tomogram to make X/Y be in plane of section
    -rotate #,#,#   Run Rotatevol on tomogram with given rotation around 
                      X, Y, and Z axes
    -already        Rotatevol was already run with these rotations
    -xyzsize #,#,#  Set output size from Rotatevol to given values in X, Y, Z
    -fullsize       Set Rotatevol output size to maximum needed to hold volume
    -maxxysize      Set Rotatevol output size in X and Y to maximum needed to 
                      hold volume, keep Z same size as input

  Global options (may be entered anywhere before root_name)
    -dir path       Set the default directory for source tomograms to "path"
    -srcext ext     Set the default extension for original tomograms to "ext"
    -tmpext ext     Set the default extension for temporary tomograms (flipped
                       or rotated) to "ext"
    -reference #    Use given tomogram as reference for density scaling
    -midaslim #     Set the size to which samples will be squeezed if they
                       are bigger than this (default $MIDASLIMIT)
EOF

#
#  $Log$
#  Revision 3.18  2008/05/20 21:13:14  mast
#  Put out stacking of sample averages in multiple lines to avoid long line
#
#  Revision 3.17  2006/08/17 18:36:54  mast
#  Added locale statement to keep output of awk from having instead of .
#
#  Revision 3.16  2006/06/06 23:04:49  mast
#  Moved control stripping before /p
#
#  Revision 3.15  2006/02/17 21:50:46  mast
#  Filter output of goodframe
#
#  Revision 3.14  2006/02/16 06:47:09  mast
#  Stripped control chars from output of sed/header etc for Windows
#
#  Revision 3.13  2006/02/10 19:22:15  mast
#  Added options to skip rotation, and to make rotated volume full size in Z
#
#  Revision 3.12  2005/12/01 06:37:58  mast
#  Added option to set rotated volumes to max needed size in X/Y
#
#  Revision 3.11  2005/11/19 04:31:26  mast
#  Quote path setting to preserve spaces
#
#  Revision 3.10  2005/10/08 22:31:23  mast
#  Adjusted sample slices properly for case of rotation that inverts volume
#  by rotation of Z axis vector
#
#  Revision 3.9  2005/08/03 23:22:01  mast
#  Made sample sizes be suitable for filtering in enhance using goodframe,
#  and add option to modify MIDASLIMT
#
#  Revision 3.8  2005/02/11 23:15:18  mast
#  Fixed handling of Windows filenames if in c:\cygwin or spaces on path
#
#  Revision 3.7  2004/12/06 02:56:55  mast
#  Fixed bug in converting backslashes in input files
#
#  Revision 3.6  2004/11/29 05:31:03  mast
#  Determine an output file mode from the density reference section and pass
#  it into info file (version 4 now)
#
#  Revision 3.5  2004/08/27 05:45:53  mast
#  Changed to take command line arguments, do densmatch to get scaling,
#  put out filenames on separate lines
#
#  Revision 3.4  2004/07/21 16:20:50  mast
#  Added commands for averaging the sample slices
#
#  Revision 3.3  2004/07/21 14:18:50  mast
#  Added messages about optional xfalign commands
#
#  Revision 3.2  2004/07/12 19:03:07  mast
#  Added an output of the command line for running Midas with the -c size list
#
#  Revision 3.1  2004/06/29 03:52:22  mast
#  Fixed path-setting
#
