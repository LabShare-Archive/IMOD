#! /bin/csh -f
# patchcrawl3d - to get local 3d cross-correlations between two volumes at
# a grid of positions.
if ($#argv < 16 || $#argv > 19) then
cat <<EOCAT
Usage: 
patchcrawl3d  XSIZE YSIZE ZSIZE  NX NY NZ  XLO XHI YLO YHI ZLO ZHI  MAX_SHIFT \
       FILEA FILEB OUTPUT_FILE [TRANSFORM_FILE ORIGINAL_FILEB] [BOUNDARY_MODEL]
Finds the displacement of the volume in FILEB relative to the volume in FILEA,
 in a series of local volumes of size XSIZE by YSIZE by ZSIZE,
 at grid positions determined by:
   NX, NY, NZ: number of positions in X, Y and Z
   XLO, XHI, YLO, YHI, ZLO, ZHI: minimum and maximum coordinates of the block
       from which local volumes will be extracted 
 MAX_SHIFT sets the maximum displacement that will be determined by local 
   search rather than FFT-based cross-correlation
 It places the list of coordinates and displacements in OUTPUT_FILE
EOCAT
exit 1
endif
set tmpdir = /usr/tmp
set modelfile = ""
if ($?IMOD_DIR) set path = ($IMOD_DIR/bin $path)

@ nxl = $1; shift
@ nyl = $1; shift
@ nzl = $1; shift
@ nx = $1; shift
@ ny = $1; shift
@ nz = $1; shift
@ xbl = $1 - 1; shift
@ xhi = $1; shift
@ ybl = $1 - 1; shift
@ yhi = $1; shift
@ zbl = $1 - 1; shift
@ zhi = $1; shift
set maxshift = $1; shift
#
set nxyz =  `header $argv[1] | sed -n '/rows, sections/p'| awk '{print $7, $8, $9}'`
@ nxt = $nxyz[1]
@ nyt = $nxyz[2]
@ nzt = $nxyz[3]

@ xbh = $nxt - $xhi
@ ybh = $nyt - $yhi
@ zbh = $nzt - $zhi

# If argument list is even, the last must be a patch model file
#
if ($#argv == 4 || $#argv == 6) then
    set modelfile = $argv[$#argv]
endif

# If a transform file and original volume are entered, use that to modify the
# borders appropriately

if ($#argv >= 5) then
    set inxyz =  `header $argv[5] | sed -n '/rows, sections/p'| awk '{print $7, $8, $9}'`

    # Get the transformed coordinates of the corners of the original volume

    set sol = `cat $argv[4]`
    set a11 = $sol[1]
    set a12 = $sol[3]
    set odx = $sol[4]
    set a21 = $sol[9]
    set a22 = $sol[11]
    set ody = $sol[12]
    @ inx = $inxyz[1] / 2
    @ iny = $inxyz[3] / 2
    @ onx = $nxt / 2
    @ ony = $nzt / 2

    @ xll = `echo $a11 $a12 $odx $inx $iny $onx | awk '{print int(-$1 * $4 - $2 * $5 + $3 + $6)}'`
    @ xlr = `echo $a11 $a12 $odx $inx $iny $onx | awk '{print int($1 * $4 - $2 * $5 + $3 + $6)}'`
    @ xul = `echo $a11 $a12 $odx $inx $iny $onx | awk '{print int(-$1 * $4 + $2 * $5 + $3 + $6)}'`
    @ xur = `echo $a11 $a12 $odx $inx $iny $onx | awk '{print int($1 * $4 + $2 * $5 + $3 + $6)}'`
    @ yll = `echo $a21 $a22 $ody $inx $iny $ony | awk '{print int(-$1 * $4 - $2 * $5 + $3 + $6)}'`
    @ ylr = `echo $a21 $a22 $ody $inx $iny $ony | awk '{print int($1 * $4 - $2 * $5 + $3 + $6)}'`
    @ yul = `echo $a21 $a22 $ody $inx $iny $ony | awk '{print int(-$1 * $4 + $2 * $5 + $3 + $6)}'`
    @ yur = `echo $a21 $a22 $ody $inx $iny $ony | awk '{print int($1 * $4 + $2 * $5 + $3 + $6)}'`

    # Sort the values in order to find second and third ones

    @ x1 = $xll
    @ x2 = $xlr
    @ x3 = $xul
    @ x4 = $xur

    if ($x1 > $x2) then
	@ tmp = $x1
	@ x1 = $x2
	@ x2 = $tmp
    endif
    if ($x1 > $x3) then
	@ tmp = $x1
	@ x1 = $x3
	@ x3 = $tmp
    endif
    if ($x1 > $x4) then
	@ tmp = $x1
	@ x1 = $x4
	@ x4 = $tmp
    endif
    if ($x2 > $x3) then
	@ tmp = $x2
	@ x2 = $x3
	@ x3 = $tmp
    endif
    if ($x2 > $x4) then
	@ tmp = $x2
	@ x2 = $x4
	@ x4 = $tmp
    endif
    if ($x3 > $x4) then
	@ tmp = $x3
	@ x3 = $x4
	@ x4 = $tmp
    endif

    @ y1 = $yll
    @ y2 = $ylr
    @ y3 = $yul
    @ y4 = $yur

    if ($y1 > $y2) then
	@ tmp = $y1
	@ y1 = $y2
	@ y2 = $tmp
    endif
    if ($y1 > $y3) then
	@ tmp = $y1
	@ y1 = $y3
	@ y3 = $tmp
    endif
    if ($y1 > $y4) then
	@ tmp = $y1
	@ y1 = $y4
	@ y4 = $tmp
    endif
    if ($y2 > $y3) then
	@ tmp = $y2
	@ y2 = $y3
	@ y3 = $tmp
    endif
    if ($y2 > $y4) then
	@ tmp = $y2
	@ y2 = $y4
	@ y4 = $tmp
    endif
    if ($y3 > $y4) then
	@ tmp = $y3
	@ y3 = $y4
	@ y4 = $tmp
    endif

    # Use the middle values to modify the borders

    if ($x2 > 0) @ xbl += $x2
    if ($x3 < $nxt) @ xbh += ($nxt - $x3)
    if ($y2 > 0) @ zbl += $y2
    if ($y3 < $nzt) @ zbh += ($nzt - $y3)

endif
#
@ nxtap = ($nxl + 9) / 10
@ nytap = ($nyl + 9) / 10
@ nztap = ($nzl + 9) / 10

corrsearch3d <<EOF
$argv[1]
$argv[2]
$argv[3]
patchtmp.$$
$modelfile
$nxl,$nyl,$nzl
$nx,$ny,$nz
$xbl,$xbh,$ybl,$ybh,$zbl,$zbh
$nxtap,$nytap,$nztap
$maxshift
EOF
if (-e patchtmp.$$) \rm patchtmp.$$
