#! /bin/csh -f
# sirtsetup: sets up command files for SIRT iterations
#
#  $Id$
#
#  Log at end

set pn = sirtsetup

set numproc = 8
set flatfrac = 1.0
set radial1 = "0.5,0.05"
set radial2 = "0.5,0.05"
@ leaverecs = 5
@ iterations = 10
set mode = 2

if ($#argv < 1) then
cat <<EOF
Usage: $pn [options] command_file
   Produces multiple command files for running iterative reconstruction
   Options:
      -nu #    Target or expected number of machines (default $numproc)
      -st      Do starting reconstruction
      -it #    Number of iterations (default $iterations)
      -le #    Leave this number of reconstructions (default $leaverecs)
      -al      Leave that number after all iterations, not just last one
      -sc #,#  Convert retained reconstructions to integers with given min/max
      -tr opt  Run trimvol with given options on retained reconstuctions
      -fl #    Flat filter fraction for starting reconstruction (default $flatfrac)
      -ri #,#  Radius and sigma for radial filter in starting reconstruction
      -rd #,#  Radius and sigma for radial filter in difference reconstructions
      -zp      Constrain reconstruction to positive values
      -zn      Constrain reconstruction to negative values
      -ch      Write reconstructions to separate chunks, not directly to file
      -di      Directly write projections to single output file
      -mo #    Output file mode (default $mode)
      -te #    Test mode, 1: retain proj, drec; 2: leave command and log files
EOF
exit 0
endif


setenv LC_NUMERIC C

if ($?IMOD_DIR) then
    setenv PATH "$IMOD_DIR/bin:$PATH"
endif

set projchunk = "-c"
set recchunk = ""
set projsubzero = "-zero"
set recsubthresh = ""
set startfirst = 0
set sirtext = srec
@ testmode = 0
set trimarg = ""
set always = 0
set integer = ""

while ($#argv > 1)
  switch ($argv[1])
    case -nu:
      set numproc = $argv[2]
      shift; shift
      breaksw

    case -ch:
      set recchunk = "-c"
      shift
      breaksw

    case -di:
      set projchunk = ""
      shift
      breaksw

    case -fl:
      set  flatfrac = $argv[2]
      shift; shift
      breaksw

    case -ri:
      set radial1 = $argv[2]
      shift; shift
      breaksw

    case -rd:
      set radial2 = $argv[2]
      shift; shift
      breaksw

    case -it:
      @ iterations = $argv[2]
      shift; shift
      breaksw

    case -zp:
      set projsubzero = ""
      set recsubthresh = "-lower 0."
      shift
      breaksw

    case -zn:
      set projsubzero = ""
      set recsubthresh = "-upper 0."
      shift
      breaksw

    case -le:
      @ leaverecs = $argv[2]
      if ($leaverecs < 1) @ leaverecs = 1
      shift; shift
      breaksw

    case -al:
      set always = 1
      shift
      breaksw

    case -mo:
      @ mode = $argv[2]
      shift; shift
      breaksw

    case -sc:
      set integer = "-sc $argv[2]"
      shift; shift
      breaksw

    case -tr:
      set trimarg = "$argv[2]"
      shift; shift
      breaksw

    case -st:
      set startfirst = 1
      shift
      breaksw

    case -te:
      @ testmode = $argv[2]
      shift; shift
      breaksw

    default:
      echo "ERROR: $pn - unrecognized option $argv[1]"
      exit 1
  endsw
end

if ($#argv < 1) then
    echo "ERROR: $pn - You must enter the command file name as last argument"
    exit 1
endif

set rootname = $argv[1]:r
set comname = $rootname.com
if (! -e $comname) then
    echo "ERROR: $pn - command file $comname does not exist"
    exit 1
endif

if ("$integer" != "" && "$trimarg" != "") then
    echo "ERROR: $pn - You cannot enter both -sc and -tr"
    exit 1
endif

set sirtname = ${rootname}_sirt

set slices = `grep -i slice $comname | grep -v '^#' | sed '/[^ 0-9\.]/s///g'`
set alifile = `grep -i inputproj $comname | grep -v '^#' | sed '/[^ 0-9\.]/s///g'`
set recfile = `grep -i outputfile $comname | grep -v '^#' | sed '/[^ 0-9\.]/s///g'`
set width = `grep -i width $comname | grep -v '^#' | sed '/[^ 0-9\.]/s///g'`
set thickness = `grep -i thickness $comname | grep -v '^#' | sed '/[^0-9\.]/s///g'`
set logbase = `grep -i '^ *log' $comname | sed '/[^ 0-9\.]/s///g'`

# Keep track of whether these are non option args
#
set recnonopt = 0
if ("$recfile" == "") set recnonopt = 1
set alinonopt = 0
if ("$alifile" == "") set alinonopt = 1

# Get the input image file name from the command file if necessary
#
if ($recnonopt || ! $alinonopt) then
    set topline  = \
      `vmstocsh < $comname | awk '/tilt/{print NR}' | sed '/[[:cntrl:]]/s///g'`
    if ($#topline > 1) then
        @ topnum = $topline[1]
    else
        @ topnum = $topline
    endif
    @ nextline = $topnum + 1
    if ($alinonopt) set alifile = \
       `vmstocsh < $comname | awk '{if (NR==LINE) print}' LINE=$nextline | sed '/[[:cntrl:]]/s///g'`
    @ nextline = $topnum + 2
    if ($recnonopt) set recfile = \
        `vmstocsh < $comname | awk '{if (NR==LINE) print}' LINE=$nextline | sed '/[[:cntrl:]]/s///g'`
endif

if (! -e $alifile) then
    echo "ERROR: $pn - $alifile does not exist yet"
    exit 1
endif
set fullimage = `header -s $alifile | sed '/[[:cntrl:]]/s///g'`
if ($#fullimage < 3) then
    echo "ERROR: $pn - Reading header of $alifile"
    exit 1
endif
@ alix = $fullimage[1]
@ aliy = $fullimage[2]
set binning = `grep -i imagebinned $comname | grep -v '^#' | sed '/[^0-9\.]/s///g'`
@ binval = 1
if ("$binning" != "") then
    @ binval = $binning[1]
endif
set iytext = ""
if ("$thickness" != "") then
    @ thick = $thickness
    @ thick /= (2 * $binval)
    set iytext = "-iy $thick"
endif
@ thick = $alix / 2
set ixtext = "-ix $thick"

# If either width or slices entry is present, we need to make sure ali exists
# and matches the possibly binned size here
#
if ("$width" != "" ||  "$slices" != "") then

    if ("$width" != "") then
        @ widthval = $width[1]
        @ alix = $fullimage[1]
        if ($alix != $widthval / $binval) then
            echo "ERROR: $pn - The reconstruction must be the full width of the aligned stack"
            exit 1
        endif
    endif

    if ("$slices" != "") then
        @ start = $slices[1]
        @ end = $slices[2]
        if ($aliy != ($end / $binval) + 1 - ($start / $binval)) then
            echo "ERROR: $pn - The reconstruction must be the full height of the aligned stack"
            exit 1
        endif
    endif
endif
@ aliy = $aliy * $binval - 1
set slices = (0 $aliy)

# Get starting reconstruction #
#
set setname = $recfile:r
@ lastnum = 0
if (! $startfirst) then
    set reclist = `\find . -maxdepth 1 -name "$setname.${sirtext}[0-9][0-9]" -print | sort`
    if ($#reclist) then
        set lastnum = `echo $reclist[$#reclist] | sed '/.*\([0-9][0-9]$\)/s//\1/'`
        if ($lastnum == "") then
            echo "ERROR: $pn - Cannot detect number of last reconstruction"
            exit 1
        endif
        @ lastnum = $lastnum
        echo "Starting from last reconstruction # $lastnum"
    else
        set startfirst = 1
    endif
endif

set aliuse = "$alifile"
if ("$logbase" != "") then
    set aliuse = "${alifile}log10"
    if (! $startfirst && ! -e $aliuse) then
        echo "ERROR: $pn - $aliuse does not exist"
        exit 1
    endif
endif

# Clean up previous stuff that splittilt might not get
#
\find . -type f -name  "$sirtname-[0-9]*.*" -exec rm -f "{}" \;
\rm -f $sirtname-start.com

# Make an initial reconstruction 
#
@ comnum = 1
if ($startfirst) then
    
    # But first take the log if necessary, advance com file number
    #
    if ("$logbase" != "") then
        cat <<EOF >! $sirtname-001-sync.com
\$if (-e $aliuse) \\rm -f $aliuse
\$densnorm -log $logbase $alifile $aliuse
\$echo CHUNK DONE
EOF
        @ comnum++
    endif
    set srecname = $setname.${sirtext}00
    sed -e "/$recfile/s//$srecname/" \
        -e "/$alifile/s//$aliuse/" \
        -e "/^ *SLICE/d" \
        -e "/^ *MODE.*/s//MODE   $mode/" \
        -e "/^ *RADIAL.*/s//RADIAL   $radial1/" \
        -e "/THICKNESS/a\\
SLICE     $slices\
" \
        -e "/THICKNESS/a\\
FlatFilterFraction   $flatfrac\
" < $comname | grep -v -i '^ *log' >! $sirtname.com
    set splitout = `splittilt -n $numproc -o $recchunk -i $comnum $sirtname.com`
    if ($status) then
        echo "$splitout"
        echo "ERROR: $pn - splittilt failed on initial run"
        exit 1
    endif
    set numchunk = `echo $splitout | sed -e "/.* files for/s///" -e "/chunks created.*/s///"`
    if ("$numchunk" == "") then
        echo "ERROR: $pn - cannot determine com file number from splittilt on initial run"
        exit 1
    endif

    # If the number started past 1 there was no -start file, so add one
    if ($comnum > 1 && "$recchunk" == "") @ comnum++
    @ chunkval = $numchunk
    @ comnum += $chunkval + 1
endif

set projname = $setname.proj
set diffname = $setname.diff
set drecname = $setname.drec

# Loop on iterations
@ iter = 0
while ($iter < $iterations)
    @ iter++
    @ recnum = $lastnum + 1
    set numtext = $recnum
    if ($recnum < 10) set numtext = 0$numtext
    set srecname = $setname.${sirtext}$numtext
    set numtext = $lastnum
    if ($lastnum < 10) set numtext = 0$numtext
    set lastname = $setname.${sirtext}$numtext

    # Make the projection file
    #
    sed -e "/$recfile/s//$projname/" \
        -e "/$alifile/s//$aliuse/" \
        -e "/^ *MODE.*/s//MODE   $mode/" \
        -e "/^ *SLICE/d" \
        -e "/THICKNESS/a\\
SLICE     $slices\
" \
        -e "/THICKNESS/a\\
ViewsToReproj     0\
" \
        -e "/THICKNESS/a\\
RecFileToReproj     $lastname\
" < $comname | grep -v -i '^ *log' >! $sirtname.com
    
    set splitout = `splittilt -n $numproc -o -i $comnum $projchunk $sirtname.com`
    if ($status) then
        echo "$splitout"
        echo "ERROR: $pn - splittilt failed setting up projection for iteration # $iter"
        exit 1
    endif
    set numchunk = `echo $splitout | sed -e "/.* files for/s///" -e "/chunks created.*/s///"`
    if ("$numchunk" == "") then
        echo "ERROR: $pn - cannot determine com file number from splittilt for project # $iter"
        exit 1
    endif

    @ chunkval = $numchunk
    @ comnum += $chunkval + 1
    if ("$projchunk" == "") @ comnum++
    
    # Put out a sync file that subtracts aligned stack from projection
    #
    set numtext = `echo $comnum | awk '{printf "%03d\n", $1}'`
    set outfile = $sirtname-$numtext-sync.com
    cat <<EOF >! $outfile
\$\\rm -f $setname.diff $projname~ $drecname~ $drecname
\$subimage $projsubzero $projname $aliuse $setname.diff
EOF
    if (! $testmode) \echo '$\rm -f'" $projname" >> $outfile
    echo '$echo CHUNK DONE' >> $outfile

    # Make the error reconstruction file
    #
    
    @ comnum++
    sed -e "/$recfile/s//$drecname/" \
        -e "/$alifile/s//$diffname/" \
        -e "/^ *MODE.*/s//MODE   $mode/" \
        -e "/^ *RADIAL.*/s//RADIAL   $radial2/" \
        -e "/^ *SLICE/d" \
        -e "/THICKNESS/a\\
SLICE     $slices\
" \
        -e "/THICKNESS/a\\
FlatFilterFraction   2\
" < $comname | grep -v -i '^ *log' >! $sirtname.com

    set splitout = `splittilt -n $numproc -o -i $comnum $recchunk $sirtname.com`
    if ($status) then
        echo "$splitout"
        echo "ERROR: $pn - splittilt failed setting up difference reconstruction for iteration # $iter"
        exit 1
    endif
    set numchunk = `echo $splitout | sed -e "/.* files for/s///" -e "/chunks created.*/s///"`
    if ("$numchunk" == "") then
        echo "ERROR: $pn - cannot determine com file number from splittilt for reconstruction # $iter"
        exit 1
    endif

    @ chunkval = $numchunk
    @ comnum += $chunkval + 1
    if ("$recchunk" == "") @ comnum++

    # Put out a sync file that subtracts diff reconstruction from last recon
    #
    set numtext = `echo $comnum | awk '{printf "%03d\n", $1}'`
    set outfile = $sirtname-$numtext-sync.com
    @ lastnum++
    @ lastleave = ( $recnum + 1 + $iterations - $iter ) - $leaverecs
    if ($always) @ lastleave = $recnum + 1 - $leaverecs

    if ($iter == $iterations) set outfile = $sirtname-finish.com
    set deldiff = $diffname
    if ($testmode) set deldiff = ""
    cat <<EOF >! $outfile
\$\\rm -f $srecname $projname~ $deldiff $drecname~ $lastname~
\$clip stat $ixtext $iytext -iz 10 $drecname
\$subimage $recsubthresh $lastname $drecname $srecname
EOF
    if (! $testmode) \echo '$\rm -f'" $drecname" >> $outfile
    if ("$trimarg" != "") then
        cat <<EOF >> $outfile
\$managesirt -it $recnum -le $lastleave -tr "$trimarg" $setname
EOF
    else
        cat <<EOF >> $outfile
\$managesirt -it $recnum -le $lastleave $integer $setname
EOF
endif
    if ($iter == $iterations) echo '$'"sed -n '/@ z/p' $sirtname-[0-9]*sync.log" >> $outfile
    if ($iter == $iterations && $testmode < 2) \echo '$\rm -f '"$sirtname-[0-9]*.*" >> $outfile
    if ($iter < $iterations) @ comnum++
    echo '$echo CHUNK DONE' >> $outfile
end

if ("$recchunk" == "" && $startfirst) @ comnum++
echo "$comnum command files created and ready to run with:"
echo "  processchunks machine_list $sirtname"

exit 0

#  $Log$
#  Revision 3.6  2008/04/14 17:56:24  mast
#  Used escaped echo to output escaped rm due to bad cygwin tcsh echo
#
#  Revision 3.5  2007/09/11 21:37:32  mast
#  Added scaling options, always option, enhanced test option, changed com
#  files to call managesirt
#
#  Revision 3.4  2007/08/18 03:21:22  mast
#  Fixed to work with binning and to add chunk done to densnorm file
#
#  Revision 3.3  2007/08/10 22:17:52  mast
#  Added ability to make log stack, fixed extraction of stats to use sed
#
#  Revision 3.2  2007/07/19 15:53:48  mast
#  Fixed removal of rec files
#
#  Revision 3.1  2007/07/19 05:49:42  mast
#  First shot
#
#
