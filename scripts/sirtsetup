#! /bin/csh -f
# sirtsetup: sets up command files for SIRT iterations
#
#  $Id$
#
#  Log at end

set pn = sirtsetup

set numproc = 8
set flatfrac = 1.0
set radial1 = "0.5,0.05"
set radial2 = "0.5,0.05"
@ leaverecs = 5
@ iterations = 10
set mode = 2

if ($#argv < 1) then
cat <<EOF
Usage: $pn [options] command_file
   Produces multiple command files for running iterative reconstruction
   Options:
      -n #    Target or expected number of machines (default $numproc)
      -s      Do starting reconstruction
      -i #    Number of iterations (default $iterations)
      -l #    Leave this number of reconstructions (default $leaverecs)
      -f #    Flat filter fraction for starting reconstruction (default $flatfrac)
      -r1 #,# Radius and sigma for radial filter in starting reconstruction
      -r2 #,# Radius and sigma for radial filter in difference reconstructions
      -zp     Constrain reconstruction to positive values
      -zn     Constrain reconstruction to negative values
      -c      Write projections to separate chunks, not directly to output file
      -d      Directly write projections to single output file
      -m #    Output file mode (default $mode)
      -t      Test mode, leave command and log files at end of processing
EOF
exit 0
endif


setenv LC_NUMERIC C

if ($?IMOD_DIR) then
    setenv PATH "$IMOD_DIR/bin:$PATH"
endif

set projchunk = "-c"
set recchunk = ""
set projsubzero = "-zero"
set recsubthresh = ""
set startfirst = 0
set sirtext = srec
set testmode = 0

while ($#argv > 1)
  switch ($argv[1])
    case -n:
      set numproc = $argv[2]
      shift; shift
      breaksw

    case -c:
      set recchunk = "-c"
      shift
      breaksw

    case -d:
      set projchunk = ""
      shift
      breaksw

    case -f:
      set  flatfrac = $argv[2]
      shift; shift
      breaksw

    case -r1:
      set radial1 = $argv[2]
      shift; shift
      breaksw

    case -r2:
      set radial2 = $argv[2]
      shift; shift
      breaksw

    case -i:
      @ iterations = $argv[2]
      shift; shift
      breaksw

    case -zp:
      set projsubzero = ""
      set recsubthresh = "-lower 0."
      shift
      breaksw

    case -zn:
      set projsubzero = ""
      set recsubthresh = "-upper 0."
      shift
      breaksw

    case -l:
      @ leaverecs = $argv[2]
      if ($leaverecs < 2) @ leaverecs = 2
      shift; shift
      breaksw

    case -m:
      @ mode = $argv[2]
      shift; shift
      breaksw

    case -s:
      set startfirst = 1
      shift
      breaksw

    case -t:
      set testmode = 1
      shift
      breaksw

    default:
      echo "ERROR: $pn - unrecognized option $argv[1]"
      exit 1
  endsw
end

set rootname = $argv[1]:r
set comname = $rootname.com
if (! -e $comname) then
    echo "ERROR: $pn - command file $comname does not exist"
    exit 1
endif

set sirtname = ${rootname}_sirt

set slices = `grep -i slice $comname | grep -v '^#' | sed '/[^ 0-9\.]/s///g'`
set alifile = `grep -i inputproj $comname | grep -v '^#' | sed '/[^ 0-9\.]/s///g'`
set recfile = `grep -i outputfile $comname | grep -v '^#' | sed '/[^ 0-9\.]/s///g'`
set width = `grep -i width $comname | grep -v '^#' | sed '/[^ 0-9\.]/s///g'`
set thickness = `grep -i thickness $comname | grep -v '^#' | sed '/[^0-9\.]/s///g'`

# Keep track of whether these are non option args
#
set recnonopt = 0
if ("$recfile" == "") set recnonopt = 1
set alinonopt = 0
if ("$alifile" == "") set alinonopt = 1

# Get the input image file name from the command file if necessary
#
if ($recnonopt || ! $alinonopt) then
    set topline  = `vmstocsh < $comname | awk '/tilt/{print NR}' | \
                sed '/[[:cntrl:]]/s///g'`
    if ($#topline > 1) then
        @ topnum = $topline[1]
    else
        @ topnum = $topline
    endif
    @ nextline = $topnum + 1
    if ($alinonopt) set alifile = `vmstocsh < $comname | awk '{if (NR==LINE) print}' \
                LINE=$nextline | sed '/[[:cntrl:]]/s///g'`
    @ nextline = $topnum + 2
    if ($recnonopt) set recfile = `vmstocsh < $comname | awk '{if (NR==LINE) print}' \
                LINE=$nextline | sed '/[[:cntrl:]]/s///g'`
endif

if (! -e $alifile) then
    echo "ERROR: $pn - $alifile does not exist yet"
    exit 1
endif
set fullimage = `header -s $alifile | sed '/[[:cntrl:]]/s///g'`
if ($#fullimage < 3) then
    echo "ERROR: $pn - Reading header of $alifile"
    exit 1
endif
@ alix = $fullimage[1]
@ aliy = $fullimage[2]
set binning = `grep -i imagebinned $comname | grep -v '^#' | sed '/[^0-9\.]/s///g'`
@ binval = 1
if ("$binning" != "") then
    @ binval = $binning[1]
endif
set iytext = ""
if ("$thickness" != "") then
    @ thick = $thickness
    @ thick /= (2 * $binval)
    set iytext = "-iy $thick"
endif
@ thick = $alix / 2
set ixtext = "-ix $thick"

# If either width or slices entry is present, we need to make sure ali exists
# and matches the possibly binned size here
#
if ("$width" != "" ||  "$slices" != "") then

    if ("$width" != "") then
        @ widthval = $width[1]
        @ alix = $fullimage[1]
        if ($alix != $widthval / $binval) then
            echo "ERROR: $pn - The reconstruction must be the full width of the aligned stack"
            exit 1
        endif
    endif

    if ("$slices" != "") then
        @ start = $slices[1]
        @ end = $slices[2]
        if ($aliy != ($end / $binval) + 1 - ($start / $binval)) then
            echo "ERROR: $pn - The reconstruction must be the full height of the aligned stack"
            exit 1
        endif
    endif
endif
@ aliy--
set slices = (0 $aliy)

# Get starting reconstruction #
#
set setname = $recfile:r
@ lastnum = 0
if (! $startfirst) then
    set reclist = `\find . -maxdepth 1 -name "$setname.${sirtext}[0-9][0-9]" -print | sort`
    if ($#reclist) then
        set lastnum = `echo $reclist[$#reclist] | sed '/.*\([0-9][0-9]$\)/s//\1/'`
        if ($lastnum == "") then
            echo "ERROR: $pn - Cannot detect number of last reconstruction"
            exit 1
        endif
        @ lastnum = $lastnum
        echo "Starting from last reconstruction # $lastnum"
    else
        set startfirst = 1
    endif
endif

# Clean up previous stuff that splittilt might not get
#
\find . -type f -name  "$sirtname-[0-9]*.*" -exec rm -f "{}" \;

# Make an initial reconstruction 
#
@ comnum = 1
if ($startfirst) then
    set srecname = $setname.${sirtext}00
    sed -e "/$recfile/s//$srecname/" \
        -e "/^MODE.*/s//Mode   $mode/" \
        -e "/^RADIAL.*/s//RADIAL   $radial1/" \
        -e "/THICKNESS/a\\
FlatFilterFraction   $flatfrac\
" < $comname >! $sirtname.com
    set splitout = `splittilt -n $numproc -o $recchunk $sirtname.com`
    if ($status) then
        echo "$splitout"
        echo "ERROR: $pn - splittilt failed on initial run"
        exit 1
    endif
    set numchunk = `echo $splitout | sed -e "/.* files for/s///" -e "/chunks created.*/s///"`
    if ("$numchunk" == "") then
        echo "ERROR: $pn - cannot determine com file number from splittilt on initial run"
        exit 1
    endif

    @ chunkval = $numchunk
    @ comnum += $chunkval + 1
endif

set projname = $setname.proj
set diffname = $setname.diff
set drecname = $setname.drec

# Loop on iterations
@ iter = 0
while ($iter < $iterations)
    @ iter++
    @ recnum = $lastnum + 1
    set numtext = $recnum
    if ($recnum < 10) set numtext = 0$numtext
    set srecname = $setname.${sirtext}$numtext
    set numtext = $lastnum
    if ($lastnum < 10) set numtext = 0$numtext
    set lastname = $setname.${sirtext}$numtext

    # Make the projection file
    #
    sed -e "/$recfile/s//$projname/" \
        -e "/^ *MODE.*/s//Mode   $mode/" \
        -e "/SLICE/d" \
        -e "/THICKNESS/a\\
SLICE     $slices\
" \
        -e "/THICKNESS/a\\
ViewsToReproj     0\
" \
        -e "/THICKNESS/a\\
RecFileToReproj     $lastname\
" < $comname >! $sirtname.com
    
    set splitout = `splittilt -n $numproc -o -i $comnum $projchunk $sirtname.com`
    if ($status) then
        echo "$splitout"
        echo "ERROR: $pn - splittilt failed setting up projection for iteration # $iter"
        exit 1
    endif
    set numchunk = `echo $splitout | sed -e "/.* files for/s///" -e "/chunks created.*/s///"`
    if ("$numchunk" == "") then
        echo "ERROR: $pn - cannot determine com file number from splittilt for project # $iter"
        exit 1
    endif

    @ chunkval = $numchunk
    @ comnum += $chunkval + 1
    if ("$projchunk" == "") @ comnum++
    
    # Put out a sync file that subtracts aligned stack from projection
    #
    set numtext = `echo $comnum | awk '{printf "%03d\n", $1}'`
    set outfile = $sirtname-$numtext-sync.com
    cat <<EOF >! $outfile
\$\\rm -f $setname.diff $projname~ $drecname~
\$subimage $projsubzero $projname $alifile $setname.diff
\$echo CHUNK DONE
EOF

    # Make the error reconstruction file
    #
    
    @ comnum++
    sed -e "/$recfile/s//$drecname/" \
        -e "/$alifile/s//$diffname/" \
        -e "/^ *MODE.*/s//MODE   $mode/" \
        -e "/^ *RADIAL.*/s//RADIAL   $radial2/" \
        -e "/SLICE/d" \
        -e "/THICKNESS/a\\
SLICE     $slices\
" \
        -e "/THICKNESS/a\\
FlatFilterFraction   2\
" < $comname >! $sirtname.com

    set splitout = `splittilt -n $numproc -o -i $comnum $recchunk $sirtname.com`
    if ($status) then
        echo "$splitout"
        echo "ERROR: $pn - splittilt failed setting up difference reconstruction for iteration # $iter"
        exit 1
    endif
    set numchunk = `echo $splitout | sed -e "/.* files for/s///" -e "/chunks created.*/s///"`
    if ("$numchunk" == "") then
        echo "ERROR: $pn - cannot determine com file number from splittilt for reconstruction # $iter"
        exit 1
    endif

    @ chunkval = $numchunk
    @ comnum += $chunkval + 1
    if ("$recchunk" == "") @ comnum++

    # Put out a sync file that subtracts diff reconstruction from last recon
    #
    set numtext = `echo $comnum | awk '{printf "%03d\n", $1}'`
    set outfile = $sirtname-$numtext-sync.com
    @ lastnum++
    @ lastdel = $recnum - $leaverecs

    if ($iter == $iterations) set outfile = $sirtname-finish.com
    cat <<EOF >! $outfile
\$@ i = 0
\$while (\$i <= $lastdel)
\$    set numtext = \$i
\$    if (\$i < 10) set numtext = "0"\$i
\$    \\rm -f $setname.${sirtext}\$numtext
\$    @ i++
\$end
\$\\rm -f $srecname $projname~ $drecname~ $lastname~
\$clip stat $ixtext $iytext -iz 10 $drecname
\$subimage $recsubthresh $lastname $drecname $srecname
EOF
    if ($iter == $iterations) echo '$'"grep '@ z' $sirtname-[0-9]*sync.log" >> $outfile
    if ($iter == $iterations && ! $testmode) echo '$\rm -f '"$sirtname-[0-9]*.*" >> $outfile
    if ($iter < $iterations) @ comnum++
    echo '$echo CHUNK DONE' >> $outfile
end

if ("$recchunk" == "" && $startfirst) @ comnum++
echo "$comnum command files created and ready to run with:"
echo "  processchunks machine_list $sirtname"

exit 0

#  $Log$
#  Revision 3.1  2007/07/19 05:49:42  mast
#  First shot
#
#
