#!/bin/csh -f
# A script to process command files on multiple machines
#
#  $Author$
#
#  $Date$
#
#  $Revision$
#
#  $Log$
#  Revision 3.7  2005/05/12 23:11:08  mast
#  Fixed for windows, made .csh file before starting process
#
#  Revision 3.6  2005/05/12 21:24:09  mast
#  Added ability to run with sync files
#
#  Revision 3.5  2004/08/27 05:46:48  mast
#  Switched to using head -n and tail -n
#
#  Revision 3.4  2004/07/23 00:09:00  mast
#  Set default nice to 18 per user request
#
#  Revision 3.3  2004/07/21 17:00:27  mast
#  Output the all file list when it is used.
#
#  Revision 3.2  2004/06/29 03:41:48  mast
#  Added nohup
#
#  Revision 3.1  2004/06/29 02:47:09  mast
#  Initial addition to package
#

nohup
set pn = processchunks
set nice = 18

if ($#argv < 2) then
cat <<EOF
Usage: $pn [options] machine_list root_name
Will process multiple command files on multiple processors or machines
  machine_list is a list of available machines, separated by commas; enter 
    ALL (or all) for a list defined in environment variable IMOD_ALL_MACHINES
  root_name is the base name of the command files, omitting -nnn.com
  Options:
    -r     Resume, retaining existing finished files (the default is to remove
             all log files and redo everything)
    -g     Go process, without asking for confirmation after probing machines
    -n #   Set the "nice" value to the given number (default $nice, range 0-19)
EOF
exit 0
endif

if ($?IMOD_DIR) then
    set path = ($IMOD_DIR/bin $path)
endif

set retain = 0
set justgo = 0

while ($#argv > 2)
  switch ($argv[1])
    case -r:
      set retain = 1
      shift
      breaksw

    case -g:
      set justgo = 1
      shift
      breaksw

    case -n:
      set nice = $argv[2]
      shift ; shift
      breaksw

    default:
        echo "ERROR: $pn - Unrecognized option $argv[1]"
        exit 1
        breaksw
  endsw
end

if ("$argv[1]" == "ALL" || "$argv[1]" == "all") then
    if ($?IMOD_ALL_MACHINES) then
        set machines = `echo $IMOD_ALL_MACHINES | sed '/,/s// /g'`
        echo "The All-machine list is:"
        echo "$IMOD_ALL_MACHINES"
    else
        echo "ERROR: $pn - Environment variable IMOD_ALL_MACHINES is not defined"
        exit 1
    endif
else
    set machines = `echo $argv[1] | sed '/,/s// /g'`
endif

if ($#machines < 1) then
    echo "ERROR: $pn - No machines specified"
    exit 1
endif

set rootname = $argv[2]
set comlist = `ls $rootname-[0-9]*.com`

if ($#comlist < 1) then
    echo "ERROR: $pn - There are no command files matching $rootname-nnn.com"
    exit 1
endif

set thishost = `hostname`
set hostroot = $thishost:r:r:r
set curdir = `pwd | sed -e "/localscratch/s//scratch\/$hostroot/" -e "/ /s//\\ /g"`

# probe machines and get all the verifications
#
echo "Probing machine connections and loads..."
@ num = 0
set newlist = ()
while ($num < $#machines)
    @ num++ 
    set machname = $machines[$num]
    set checkit = 1
    if ($num > 1) then
        @ last = $num - 1
        if ( "$machname" == "$machines[$last]" ) set checkit = 0
    endif
    if ($checkit == 1) then
        if ("$machname" == $hostroot || $machname == localhost) then
            echo $machname
            w | head -n 1
            set laststat = 0
        else
            ssh -x $machname "hostname ; w | head -n 1"
            set laststat = $status
            if ($laststat != 0) then
                echo "Dropping $machname from list because it does not respond"
                echo ""
            endif
        endif
    endif
    if ($laststat == 0) set newlist = ($newlist $machname)
end 

set machines = ($newlist)

if ($justgo == 0) then
    echo -n "Enter Y to proceed with the current set of machines: "
    set answer = $<
    if ("$answer" != "Y" && "$answer" != "y") exit
endif

restart:

# set up flag list and list of assignments
#
set flags = ()
@ num = 0
while ($num < $#comlist)
    @ num++
    set sync = 0
    set test = `echo $comlist[$num] | grep -i '[0-9]-sync.com'`
    if (! $status) set sync = -1
    set flags = ($flags $sync)
end

set assigned = ()
set startcount = ()
@ num = 0
while ($num < $#machines)
    @ num++
    set assigned = ($assigned 0)
    set startcount = ($startcount 0)
end

# remove logs if not restarting, and run starting file
#
@ numdone = 0
if ($retain == 0) then
    \find . -type f -name  "$rootname-[0-9]*.log" -exec rm -f "{}" \;
    if (-e $rootname-start.com) then
        echo "Going to run $rootname-start first..."
        vmstocsh $rootname-start.log < $rootname-start.com | csh -ef
        if ($status) then
            echo "Error running $rootname-start.com, check $rootname-start.log"
            exit 1
        endif
    endif
else

    # otherwise prescan logs for done ones
    #
    @ num = 0
    while ($num < $#comlist)
        @ num++
        set logname = $comlist[$num]:r.log
        if (-e $logname) then
            set lastline = `tail -n 1 $logname`
            if ("$lastline" == "CHUNK DONE") then
                set flags[$num] = 2
                @ numdone++
            endif
        endif
    end 
endif

onintr report

# Loop until all appear to be done
#
@ lastdone = 0
@ count = 0
@ nextsync = $#comlist + 2

continue:

while ($numdone < $#comlist)
    sleep 3
    @ proc = 0
    @ count++
    
    # Loop on machines, if they have an assignment check if it is done
    #
    while ($proc < $#machines)
        @ proc++
        @ ind =$assigned[$proc]
        set dropout = 0
        if ($ind != 0) then
            set logname = $comlist[$ind]:r.log
            set cshname = $comlist[$ind]:r.csh
            if (-e $logname) then
                set lastline = `tail -n 1 $logname | sed '/[[:cntrl:]]/s///g'`
                if ("$lastline" == "CHUNK DONE") then

                    # If it is DONE, then set flag to done and deassign
                    #
                    set flags[$ind] = 2
                    set assigned[$proc] = 0
                    @ numdone++
                else if (! -e $cshname) then

                    # If the log file exists but the .csh is gone, 
                    # set flag to redo it
                    #
                    set dropout = 1
                endif
            else
            
                # Similarly if log file doesn't exist after timeout, give up
                #
                @ tmpcount = $startcount[$proc]
                if ($count > $tmpcount + 40) set dropout = 1
            endif

            # if failed, remove the assignment, mark chunk as to be done, 
            # skip this machine on this round
            #
            if ($dropout == 1) then
                echo "Need to restart $comlist[$ind]"
                set flags[$ind] = 0
                set assigned[$proc] = 0
            endif
        endif

        # If the current machine is unassigned, find next com to do and run it
        # Move current log out of way so non-existence of log can be sign of
        # nothing having started
        #
        @ num = 0
        while ($num < $#comlist && $assigned[$proc] == 0 && $dropout == 0)
            @ num++

            # But if the next com is a sync, record number and break loop
            #
            if ($flags[$num] == -1) then
                @ nextsync = $num
                break
            endif
            if ($flags[$num] == 0) then
                set assigned[$proc] = $num
                set flags[$num] = 1
                set startcount[$proc] = $count
                set comname = $comlist[$num]
                set logname = $comname:r.log
                set cshname = $comname:r.csh
                set pidname = $comname:r.pid
                set machname = $machines[$proc]
                if (-e $logname) \mv $logname $logname~
                if (-e $pidname) \rm -f $pidname
                echo "Running $comname on $machname ..."
                \echo "nice +$nice" >! $cshname
                vmstocsh $logname < $comname >> $cshname
                if ("$machname" == $hostroot || "$machname" == localhost) then
                    csh -ef < $cshname >& $pidname ; \rm -f $cshname $pidname &
                else
                    ssh -x $machname "cd $curdir ; nice csh -ef < $cshname >& $pidname ; \rm -f $cshname $pidname" &
                endif
            endif
        end 
    end

    if ($numdone > $lastdone) echo $numdone DONE SO FAR
    @ lastdone = $numdone

    # If we have finished up to the sync file, then run it
    if ($numdone >= $nextsync - 1) then
        set comname = $comlist[$nextsync]
        set logname = $comname:r.log
        echo "Running $comname to synchronize ..."
        vmstocsh $logname < $comname | csh -ef
        if ($status) then
            echo "Error running $comname, check $logname"
            exit 1
        endif
        set flags[$nextsync] = 1
        @ nextsync = $#comlist + 2
        @ numdone++
    endif
end

echo "ALL DONE - going to run $rootname-finish to reassemble"
vmstocsh $rootname-finish.log < $rootname-finish.com | csh -ef
exit

report:
@ undone = $#comlist - $numdone
echo  " $undone chunks are still undone"
set ans = 0
while ("$ans" != "R" && "$ans" != "Q" && "$ans" != "C")
    echo "Enter R to try to redo them with the current list of machines,"
    echo " Q to kill all jobs and quit, or C to continue waiting: "
    set ans = "$<"
    if ($ans == "r") set ans = R
    if ($ans == "q") set ans = Q
    if ($ans == "c") set ans = C
end

if ("$ans" == "C") goto continue

# now try to kill jobs
@ proc = 0
while ($proc < $#machines)
    @ proc++
    @ ind =$assigned[$proc]
    if ($ind != 0) then
        set pidname = $comlist[$ind]:r.pid
        if (-e $pidname) then
            set pid = `cat $pidname | sed '/[^0-9]/s///g'`
            set machname = $machines[$proc]
            echo "Killing $comlist[$ind] on $machname"
            if ("$machname" == $hostroot || "$machname" == localhost) then
                kill $pid
            else
                ssh -x $machname "kill $pid"
            endif
        endif
    endif
end

set retain = 1
if ("$ans" == "R") goto restart
echo ""
echo "When you rerun with a different set of machines, be sure to use"
echo "the -r flag to retain the existing results"
exit
