.na
.nh
.ll 7.5i
.TH PIP 1 3.0.11 BL3DEMC
.SH NAME
.nh
PIP \- package for parsing input parameters from Fortran or C
.SH USER DESCRIPTION
.nh
PIP is a package of functions for entering parameters into programs.  A
program using PIP will accept input in two different ways.  Options and their
values can be entered as command line arguments, or on separate lines with
one option name per line followed by its value.  The multi-line entry can be
made via standard input, on lines following the command line invoking the 
program; in addition, the program may also allow entries in this format to be
read from a separate parameter file.  These different methods may even be used
together, with some options taken from the command line and some from line
entries.

Options are generally given both a short and long name, with the short name
designed for convenience when used at the command line, and the long name
being more descriptive for use in command files.  However, either form may be
used in either place.  The names are case-sensitive.  Options can be
abbreviated to their shortest unique form, sometimes one or two letters.

When entered at the command line, options must be preceded by one or two dashes
(- or --).  The option must be followed by a space then a value if
appropriate.  If the value contains embedded blanks it must be enclosed in 
quotes.  Options cannot be concatenated the way single letter options in 
Unix programs often can be.

Multiple-line entry is invoked by entering the argument \fB-StandardInput\fR on
the command line, or, if the program allows, by entering the option to read
a parameter file, followed by the name of the file.  The program will read
lines of input until the tag \fBEndInput\fR is read or until the end of the
file is reached.  It will then resume processing command line arguments, if
any.

The format of the line entry is an option name followed by any number of
spaces or tabs and an optional equals sign, followed by the value of the
option.  If the value consists of multiple numbers, they can be separated by
spaces, tabs or commas.  If a value consists of a text string, it may contain
embedded blanks.

Blank lines and lines starting with # are ignored.  A comment starting with #
can also be placed on a line after an option and its value.

Programs may allow Fortran-style default input, in which
a comma without a number indicates that the default value for the number
should be taken, and a / indicates that all remaining numbers have their
default values.  For example, 23,,15 takes the default for the second value
and ,42,17 takes the default for the first; 1,1024/ takes the default for
all values after the first two and / takes the default for all values.
Defaults can be used only when a fixed number of values are expected.

Boolean options are ones that turn a particular feature on or off.  When
entered as command lines arguments, they must not be followed by a value; in
other words, the presence of the entry sets the option to true or on.
However, when a boolean option is entered in a separate line in a command
file, it may be followed by 0, F, f, FALSE, false, OFF, off, 1, T, t, TRUE,
true, ON, or on.

Options can be entered more than once.  In most cases a later value will
supercede a previous entry, but in some cases the multiple entries will
accumulate.  This is useful if multiple input file names are needed, or if
more numbers need to be entered than will fit on a line.  In rare cases, each
entry of an option is associated with (linked to) the next entry of another
option; this is the only situation where the order of entering different 
options matters.

PIP provides a standard help output which the program should make available
with an option such as \fB-help\fR or \fB-usage\fR.  Invoking a program with
no arguments may also cause this to be printed, unless the program still
supports old-style interactive input as the default when there are no
arguments.  The help output will list the two forms for each option, indicate
what kind of value is expected, and provide a one-line description of the
option.  In addition, it will indicate if multiple entries of an option will
accumulate.

.SH PROGRAMMING DESCRIPTION
.nh
The simplest way to use PIP is first to set up its state with optional calls
to \fBPipExitOnError\fR and \fBPipAllowCommaDefaults\fR, then pass it the
list of options and have it parse input with \fBPipParseInput\fR, then
get option
values with a series of \fBPipGet...\fR calls, then finish with \fBPipDone\fR.
PIP can also read the list of options from a separate file, referred to as an
autodoc file.  In this case, instead of calling \fBPipParseInput\fR, one
calls \fBPipReadOptionFile\fR to read the options from the file, then 
\fBPipParseEntries\fR to parse the input.  There is also
a convenience function, \fBPipReadOrParseOptions\fR, that will first try to
read options from an autodoc file, then fall back to a list of options supplied
by the calling program.

For use from C, the header file \fBparse_params.h\fR is in the IMOD/include
directory.  The PIP package and Fortran-callable wrappers are in the
\fBlibcfshr\fR library.  The Fortran versions of \fBPipParseInput\fR and
\fBPipReadOptionFile\fR are in the
\fBlibhvem\fR library, which requires \fBlibcfshr\fR.

Fortran-callable wrappers to the C functions have been given the same name as 
the C functions, although internally they are all lower case with an
underscore appended, or all uppercase in Windows.  
The function calls from Fortran are case-insensitive but
they are shown with mixed case here for clarity.

PIP can also be used from Python by importing the pip module in the IMOD/pylib
directory.  Up to IMOD 3.11 this was a compiled extension module using the C
code, but this is now written in Python to avoid compatibility problems.  The
calling conventions are described in a separate section below.

.SS Option Specifications Supplied by the Calling Program
Each legal option should be specified with a string having up to 4 
components:
  \fBshortName:longName:type:helpString\fR

The short name is intended to be used predominantly on the command line, while
the long name would be more suitable in parameter files.  However, PIP makes
only one distinction between the short and long names - if a short name
consists of a single letter, there can be other short names starting with that
letter.  Either name can be abbreviated, either name can be preceded by either
one or two dashes, and either name can be omitted.  Any of these 4 components
can be omitted as long as there is either a short or a long name.  The string
must have 3 colons.

.SS Option Types
.nf
\fBB\fR    Boolean - the only type that does not require a value
\fBI\fR    Integer
\fBIP\fR   Pair of integers
\fBIT\fR   Three integers
\fBIA\fR   Integer array
\fBF\fR    Floating point
\fBFP\fR   Pair of floating point numbers
\fBFT\fR   Three floating point numbers
\fBFA\fR   Floating point array
\fBCH\fR   Character string
\fBFN\fR   File name
\fBLI\fR   List (comma-separated list of ranges)
\fBPF\fR   Parameter file
.fi

If an option specification ends in \fBM\fR or \fBL\fR, this indicates that
multiple entries of the option will accumulate rather than supercede each
other.  This allows multiple filenames of a particular type to be entered, or
multiple lines of input for long lists of numbers.  The \fBL\fR ending
indicates that each entry of the option is associated with, or linked to, the
next occurrence of some other option.  It must be specified in order to use
the \fBPipLinkedIndex\fR function.

PIP uses these types primarily to provide information in the help output and
does not enforce the implications of these types, except as follows: 
an option that does not take an argument must be coded as \fBB\fR; a parameter
file option must be coded as \fBPF\fR.

.SS Option Specifications in an Autodoc File
The autodoc file is designed to provide a single source of information
about program options for the program itself, the man page, and graphical user
interfaces that run the program.  The file consists of global metadata at
the start, then a series of sections starting with a token inside brackets.
Each section can then contain keyword-value pairs.  The general form of
a token entry is:
   \fB[token delimiter value]\fR
.br
and the general form of a keyword-value pair is:
   \fBkeyword delimiter value\fR
.br
Tokens, keywords, and token values must not contain embedded spaces, although 
keyword values
may.  There must be no space between the opening [ and a token or between its 
value
and the ending ].  There can be spaces or tabs before and after the
delimiter; these will not be considered part of the token or value strings.
PIP will ignore white space before keywords or tokens, but other parsers of
autodoc files may not accept this.
The default delimiter is an equals sign (=).  It can be changed once, in
the metadata, before any tokens have been encountered, with a statement
such as:
   \fBKeyValueDelimiter = ==\fR

PIP will examine keyword-value pairs only after a \fBField\fR token, which
signifies the start of an option, or after a \fBSectionHeader\fR token,
which can be used to introduce some header text into the usage or manpage
outputs.  
The following
keywords are understood by PIP in a \fBField\fR section, while others are
ignored:
.nf
\fBshort\fR    Short option name
\fBlong\fR     Long option name
\fBtype\fR     Type of option; see table above
\fBformat\fR   String shown after the option in usage or manpage output
\fBusage\fR    Help string for usage output
\fBtooltip\fR  Help string for tooltip
\fBmanpage\fR  Help string for manual page
.fi

If one of these keywords has no value after it, PIP will ignore the entry.
Short and long option names should not contain spaces.  
If a \fBField\fR has a value, it becomes the default long option name, in
which case \fBlong\fR can be omitted.  Alternatively, a \fBlong\fR entry
can be used to override the value of the field, and a blank \fBlong\fR entry
can be used to eliminate the default long option name provided by a
\fBField\fR value.

If a \fBformat\fR entry is destined for a .man-type manpage, it will be
italicized by default by wrapping it in \\fI and \\fR.  It can contain these
kind of font specifiers, and the default wrapping will be omitted if it starts
with one of the specifiers.  Thus, enclose the entry in \\fB and \\fR or start
it with \\fR to have it be in bold or regular font.

The help strings are
allowed to contain spaces, and to continue on multiple lines.  A
continuation line should not have \fB#\fR or \fB[\fR as its first non-white
space character, nor should it contain the key-value delimiter.  Lines are
added to a help string until a line with the delimiter is encountered.  If
you want to use = in help strings, change the delimiter to ==
as shown above, or enclose the entire (possibly multiline) string in quotes.
The quote can be a single quote, double quote, or backtick character.  PIP
will look for a matching quote only at the end of a line, but other autodoc
parsers may be confused by a matching quote embedded in the line, so it is
best to use a quote that is not used literally in the string.  

Use \fB^\fR at the beginning of a continuation line to
start a new line before outputting the text on the line.  Spaces after 
the \fB^\fR will be retained, so that lines can be indented in a man page.

Lines containing only white space, and lines with \fB#\fR as the first
non-white space, are ignored.

In a \fBSectionHeader\fR section, keywords besides \fBusage\fR and 
\fBmanpage\fR are ignored.  Help strings will be output without indentation;
for a man page that is input to \fBnroff\fR, start the string with .SS or .SH
to avoid the regular indentation of option text.

Other meaningful metadata entries are \fBNoHelpAbbrevations\fR to avoid
showing unique abbreviations in help output, \fBNoAbbreviations\fR to
turn on the flag for no abbreviations internally and allow otherwise
ambiguous options, and 
\fBDoubleDashOptions\fR to show options with two dashes in help output.

.SS Errors and Return Values
.nh
All functions return a negative number if an error occurs.  Functions in which
an option is specified typically return -1 if the option is not a legal one,
or -2 if the option is abbreviated ambiguously.  An error string is available
after an error by calling \fBPipGetError\fR.  Alternatively, the program can
call \fBPipExitOnError\fR at any point, and PIP will print the error string
itself and exit with an error status.

.SS Functions for Initialization
.nh
.ft B
.nf
int PipExitOnError(int \fIuseStdErr\fB, const char *\fIprefix\fB);

integer*4 function PipExitOnError(\fIuseStdErr\fB, \fIprefix\fB)
integer*4 \fIuseStdErr\fB
character*N \fIprefix\fB
.ft R
.fi

Use this function to enable PIP to exit with a message upon any error in
program function or user input.  The string \fIprefix\fR will be placed in
front of the error message that PIP ordinarily generates upon error, and the
message will be printed to standard output or standard error depending on
whether \fIuseStdErr\fR is 0 or 1.  PIP will exit with an error status.  If
\fIprefix\fR is an empty string, then this feature is disabled.


.ft B
.nf
void PipAllowCommaDefaults(int \fIval\fB);

subroutine PipAllowCommaDefaults(\fIval\fB)
integer*4 \fIval\fB
.ft R
.fi

If \fIIval\fR
is non-zero, then Fortran-style default input will be allowed whenever
a fixed number of values are being returned.  Specifically, if commas are
used to separate entries and there is no entry between a pair of commas, then
the returned value will be unmodified from the default value supplied in the
call.  A / character will terminate input and leave all remaining expected
elements at their default values.


.ft B
.nf
void PipSetSpecialFlags(int \fInoCase\fB, int \fIdoneEnds\fB,  int \fItakeStdin\fB,
                        int \fInonOptLines\fB,  int \fInoAbbrevs\fB)

subroutine PipSetSpecialFlags(\fInoCase\fB, \fIdoneEnds\fB,  \fItakeStdin\fB,
                              \fInonOptLines\fB,  \fInoAbbrevs\fB)
integer*4 \fInoCase\fB, \fIdoneEnds\fB,  \fItakeStdin\fB, \fInonOptLines\fB, \fInoAbbrevs\fB
.ft R
.fi

This call can be used to set flags that modify the behavior as follows:
.br
\fInoCase\fR non-zero allows case-insensitive options
.br
\fIdoneEnds\fR non-zero allows DONE to be used in place of EndInput
.br
\fItakeStdin\fR non-zero runs a program with no arguments as if -StandardInput
were entered
.br
\fInonOptLines\fR greater than zero allows the first few lines of input to be
taken as non-option arguments, up to a number of lines given by the value.
.br
\fInoAbbrevs\fR non-zero means that options must be entered in full
.br
The first four behaviors were required to convert Tilt(1) to PIP input without
retaining the old input code, but none of this should be needed elsewhere.

.ft B
.nf
int PipSetLinkedOption(const char *\fIoption\fB);

integer*4 function PipSetLinkedOption(\fIoption\fB)
character*N \fIoption\fB
.ft R
.fi
This function will set a specific option as the linked option, so that the
current count (index of next occurrence) of that option will be recorded for
each entry of other options.

.ft B
.nf
int PipParseInput(int \fIargc\fB, char *\fIargv[]\fB, const char *\fIoptions[]\fB,
                  int \fInumOptions\fB, int *\fInumOptArgs\fB, 
                  int *\fInumNonOptArgs\fB);

integer*4 function PipParseInput(\fIoptions\fB, \fInumOptions\fB, \fIseparator\fB,
                                 \fInumOptArg\fB, \fInumNonOptArg\fB)
character*N \fIoptions\fB(N)
integer*4 \fInumOptions\fB
character \fIseparator\fB
integer*4 \fInumOptArg\fB, \fInumNonOptArg\fB    [Returned arguments]
.ft R
.fi

This is a high-level function that will initialize PIP (\fBPipInitialize\fR)
for the number of options given in \fInumOptions\fR,
take the list of all available options specified in 
\fIoptions\fR and add them one at a time with \fBPipAddOption\fR, parse
command line arguments and other input with \fBPipNextArg\fR, and return the 
number of option
arguments in \fInumOptArg\fR and the number of
non-option arguments in \fInumNonOptArg\fR.  At the end, it calls
\fBPipPrintEntries\fR, which will print program entries if enabled (see below).
The C version receives the command
line arguments directly while the Fortran version fetches them with 
\fBgetarg\fR.

There are two alternatives for Fortran usage.  Each option specification
can be placed in a separate element of the \fIoptions\fR array.  In this case,
\fIoptions\fR should be dimensioned to the number of options, \fIseparator\fR
should be a space character, and the length of the character elements of the
array should at least as big as the longest option description.  Alternatively,
all of the options can be placed in one character string, separated by the
character given in \fIseparator\fR.  In this case, set the dimension 
of \fIoptions\fR
to 1 and make its length be big enough for the entire string.


.ft B
.nf
int PipReadOptionFile(const char *\fIprogName\fB, int \fIhelpLevel\fB, int \fIlocalDir\fB)

integer*4 function PipReadOptionFile(\fIprogName\fB, \fIhelpLevel\fB, \fIlocalDir\fB)
character*N \fIprogName\fB
integer*4 \fIhelpLevel, localDir\fB
.ft R
.fi

This function will read options from an autodoc file,
\fBprogName.adoc\fR.
If \fIlocalDir\fR is 0, this file will be sought first in the directory
pointed to by the environment variable AUTODOC_DIR, if it is defined; then
in the directory $IMOD_DIR/autodoc; then in the current directory.  If
\fIlocalDir\fR is 1 or 2, etc., the file will be sought in ../autodoc
or ../../autodoc, etc., then in the current directory.  This allows PIP to
generate a man page entry from the autodoc file in the current source tree
rather than in the installed version of IMOD.

The \fIhelpLevel\fR argument determines which help string is used when
multiple strings are available. 
.br
If \fIhelpLevel\fR is 1, then the usage string
will be stored if available, or the tooltip string if there is no usage
string, or the manpage string if neither tooltip nor usage is available.
.br
If \fIhelpLevel\fR is 2, then the tooltip string
will be stored if available, or the usage string if there is no tooltip
string, or the manpage string if neither tooltip nor usage is available.
.br
If \fIhelpLevel\fR is 3, then the manpage string
will be stored if available, or the tooltip string if there is no manpage
string, or the usage string if neither tooltip nor manpage is available.


.ft B
.nf
int PipParseEntries(int \fIargc\fB, char *\fIargv[]\fB, int *\fInumOptArgs\fB, 
                    int *\fInumNonOptArgs\fB);

integer*4 function PipParseEntries(\fInumOptArg\fB, \fInumNonOptArg\fB)
integer*4 \fInumOptArg\fB, \fInumNonOptArg\fB    [Returned arguments]
.ft R
.fi

This high-level function is used after options have been read from an
autodoc file with \fBPipReadOptionFile\fR.
It parses command line arguments and other input with \fBPipNextArg\fR,
and return the number of option
arguments in \fInumOptArg\fR and the number of
non-option arguments in \fInumNonOptArg\fR.  The C version receives the command
line arguments directly while the Fortran version fetches them with 
\fBgetarg\fR.


.ft B
.nf
subroutine PipReadOrParseOptions(\fIoptions\fB, \fInumOptions\fB, \fIprogName\fB, 
                                 \fIexitString\fB, \fIinteractive\fB, \fIminArgs\fB, 
                                 \fInumInFiles\fB, \fInumOutFiles\fB, 
                                 \fInumOptArg\fB, \fInumNonOptArg\fB)
character*N \fIoptions\fB
character*N \fIprogName\fB
character*N \fIexitString\fB
logical \fIinteractive\fB
integer*4 \fIminArgs\fB, \fInumInFiles\fB, \fInumOutFiles\fB
integer*4 \fInumOptArg\fB, \fInumNonOptArg\fB    [Returned arguments]
.ft R
.fi

This Fortran subroutine performs a sequence of
initialization tasks.  It first attempts to read options for the program
\fIprogName\fR from an autodoc file using \fBPipReadOptionFile\fR then
\fBPipParseEntries\fR.  If this
fails, it falls back to calling \fBPipParseInput\fR to define
\fInumOptions\fR options from the single string \fIoptions\fR, with the
separator \fB@\fR between options.  It allows comma defaults with 
\fBPipAllowCommaDefaults\fR, and calls both \fBPipExitOnError\fR and 
\fBsetExitPrefix\fR with the prefix
string in \fIexitString\fR.  If \fIinteractive\fR is \fB.true.\fR, the routine
returns if there are no input arguments.  Otherwise, it checks for whether to
print a usage output.  If the number of arguments is less than
\fIminArgs\fR or \fB-help\fR is entered as an argument, then it calls
\fBPipPrintHelp\fR with \fInumInFiles\fR and \fInumOutFiles\fR as arguments
for the number of input and output files, then exits.
The option \fBhelp\fR must therefore be defined.

.ft B
.nf
void PipReadOrParseOptions(int \fIargc\fB, char *\fIargv[]\fB, 
                           const char *\fIoptions[]\fB, int \fInumOptions\fB, 
                           const char *\fIprogName\fB, int \fIminArgs\fB, 
                           int \fInumInFiles\fB, int \fInumOutFiles\fB, 
                           int *\fInumOptArgs\fB, int *\fInumNonOptArgs\fB, 
                           void (\fIheaderFunc\fB)(const char *));
.ft R
.fi

This C function performs a similar sequence of
initialization tasks.  It first attempts to read options for the program
\fIprogName\fR from an autodoc file using \fBPipReadOptionFile\fR then
\fBPipParseEntries\fR.  If this
fails, and if \fInumOptions\fR options are provided in an array of 
strings, \fIoptions\fR, it falls back to calling \fBPipParseInput\fR.
It calls \fBPipExitOnError\fR with "ERROR: \fIprogName\fR - " as the error
string, defining standard out as the destination for error output.
If the number of arguments is less than \fIminArgs\fR, it first calls the
function supplied in \fIheaderFunc\fR if it is non-NULL, then calls
\fBPipPrintHelp\fR with \fInumInFiles\fR and \fInumOutFiles\fR as arguments
for the number of input and output files, then exits.  

.ft B
.nf
int PipInitialize(int \fInumOpts\fB);

integer*4 function PipInitialize(int \fInumOpts\fB)
integer*4 \fInumOpts\fB
.ft R
.fi

This function will initialize PIP and allocate memory for the number of
options given in \fInumOpts\fR.


.ft B
.nf
int PipAddOption(const char *\fIoptionString\fB);

integer*4 function PipAddOption(\fIoptionString\fB)
character*N \fIoptionString\fB
.ft R
.fi

This function is used to add one option at a time to PIP's table of options.


.ft B
.nf
int PipNextArg(const char *\fIargString\fB);

integer*4 function PipNextArg(\fIargString\fB)
character*N \fIargString\fB
.ft R
.fi

This function is used to send each argument in turn to PIP.  An option will
be checked against the list of legal options; a value for an option will be
associated with the option in PIP's table; and a non-option argument will
be stored in PIP's list of those.  The function returns 1 if an argument is
an option that requires a value.


.ft B
.nf
void PipNumberOfArgs(int *\fInumOptArgs\fB, int *\fInumNonOptArgs\fB);

subroutine PipNumberOfArgs(\fInumOptArgs\fB, \fInumNonOptArgs\fB);
integer*4 \fInumOptArg\fB, \fInumNonOptArg\fB      [Returned arguments]
.ft R
.fi

After arguments have been parsed, this function returns the number of option
arguments in \fInumOptArg\fR and the number of non-option arguments in
\fInumNonOptArgs\fR.

.SS Functions for Getting Values

.nh
.ft B
.nf
int PipNumberOfEntries(const char *\fIoption\fB, int *\fInumEntries\fB);

integer*4 function PipNumberOfEntries(\fIoption\fB, \fInumEntries\fB);
character*N \fIoption\fB
integer*4 \fInumEntries\fB     [Returned argument]
.ft R
.fi

This function returns the number of accumulated entries for the given option
in the argument \fInumEntries\fR.  After calling this function, simply call
a function to get the value of the option that number of times to
retrieve all of the entered values.

.nh
.ft B
.nf
int PipLinkedIndex(const char *\fIoption\fB, int *\Iindex\fB);

integer*4 function PipLinkedIndex(\fIoption\fB, \fIindex\fB);
character*N \fIoption\fB
integer*4 \fIindex\fB     [Returned argument]
.ft R
.fi

This function returns into the argument \fIindex\fR the index of the next
entry of a linked option, for the next entry of the given option to be
retrieved.  It returns the index of a specific linked option if one was
identified with \fBPipSetLinkedOption\fR and if entries were made with that
option; otherwise it returns the index of the next nonoption argument.

.ft B
.nf
int PipGetNonOptionArg(int \fIargNo\fB, char **\fIarg\fB);

integer*4 function PipGetNonOptionArg(\fIargNo\fB, \fIarg\fB)
integer*4 \fIargNo\fB
character*N \fIarg\fB           [Returned argument]
.ft R
.fi

This function returns the non-option argument specified by \fIargNo\fR
(numbered from 0 in C and Python, from 1 in Fortran) in as a string in the
argument \fIarg\fR.  Note that non-option arguments can also be retrieved by
calling
\fBPipGetString\fR repeatedly with the option as \fBNonOptionArgument\fR or
any abbreviation thereof.  When called from C and a string is returned, the
string is allocated with malloc() and should be freed with free().

.ft B
.nf
int PipGetString(const char *\fIoption\fB, char **\fIstring\fB);

integer*4 function PipGetString(\fIoption\fB, \fIstring\fB)
character*N \fIoption\fB
character*N \fIstring\fB        [Returned argument]
.ft R
.fi

This function returns the value of the given option as a string in the
argument \fIstring\fR.  The return value is 1 if the user did not enter this
option.  When called from C and a string is returned, the string is allocated
with malloc() and should be freed with free().


.ft B
.nf
int PipGetInteger(const char *\fIoption\fB, int *\fIval\fB);

integer*4 function PipGetInteger(\fIoption\fB, \fIval\fB)
character*N \fIoption\fB
integer*4 \fIval\fB             [Returned argument]

int PipGetFloat(const char *\fIoption\fB, float *\fIval\fB);

integer*4 function PipGetFloat(\fIoption\fB, \fIval\fB)
character*N \fIoption\fB
real*4 \fIval\fB                [Returned argument]
.ft R
.fi

These functions returns a single integer or floating point value for the given
option in the argument \fIval\fR.  The return value is 1 if the user did not
enter this option.


.ft B
.nf
int PipGetTwoIntegers(const char *\fIoption\fB, int *\fIval1\fB, int *\fIval2\fB);

integer*4 function PipGetInteger(\fIoption\fB, \fIval1\fB, \fIval2\fB)
character*N \fIoption\fB
integer*4 \fIval1, val2\fB             [Returned arguments]

int PipGetTwoFloats(const char *\fIoption\fB, float *\fIval1\fB, float *\fIval2\fB);

integer*4 function PipGetTwoFloats(\fIoption\fB, \fIval1\fB, \fIval2\fB)
character*N \fIoption\fB
real*4 \fIval1, val2\fB             [Returned arguments]

.ft R
.fi

These functions returns two integers or two floats for the given
option in the arguments \fIval1\fR and \fIval2\fR.
The return value is 1 if the user did not enter this option.


.ft B
.nf
int PipGetThreeIntegers(const char *\fIoption\fB, int *\fIval1\fB, int*\fIval2\fB,
                        int*\fIval3\fB,);

integer*4 function PipGetInteger(\fIoption\fB, \fIval1\fB, \fIval2\fB, \fIval3\fB)
character*N \fIoption\fB
integer*4 \fIval1, val2, val3\fB             [Returned arguments]

int PipGetThreeFloats(const char *\fIoption\fB, float *\fIval1\fB, float*\fIval2\fB,
                      float*\fIval3\fB);

integer*4 function PipGetThreeFloats(\fIoption\fB, \fIval1\fB, \fIval2\fB, \fIval3\fB)
character*N \fIoption\fB
real*4 \fIval1, val2, val3\fB             [Returned arguments]

.ft R
.fi

These functions returns three integers or three floats for the given
option in the arguments \fIval1\fR, \fIval2\fR, and \fIval2\fR.
The return value is 1 if the user did not enter this option.


.ft B
.nf
int PipGetBoolean(const char *\fIoption\fB, int *\fIval\fB);

integer*4 function PipGetBoolean(\fIoption\fB, \fIval\fB)
character*N \fIoption\fB
integer*4 \fIval\fB             [Returned argument]
.ft R
.fi

This function returns a value of 0 or 1 for the given boolean option in the
argument \fIval\fR.  The return value is 1 if the user did not enter this
option.


.ft B
.nf
integer*4 function PipGetLogical(\fIoption\fB, \fIval\fB)
character*N \fIoption\fB
logical \fIval\fB             [Returned argument]
.ft R
.fi

This function returns a value of .true. or .false. for the given boolean
option in the argument \fIval\fR.  The return value is 1 if the user did not
enter this option.


.ft B
.nf
int PipGetIntegerArray(const char *\fIoption\fB, int *\fIarray\fB, int *\fInumToGet\fB,
                       int \fIarraySize\fB);

integer*4 function PipGetIntegerArray(\fIoption\fB, \fIarray\fB, \fInumToGet\fB, 
                                      \fIarraySize\fB)
character*N \fIoption\fB
integer*4 \fIarray\fB(N)        [Returned argument]
integer*4 \fInumToGet\fB        [Returned argument if initially 0]
integer*4 \fIarraySize\fB

int PipGetFloatArray(const char *\fIoption\fB, float *\fIarray\fB, int *\fInumToGet\fB,
                     int \fIarraySize\fB);

integer*4 function PipGetFloatArray(\fIoption\fB, \fIarray\fB, \fInumToGet\fB,
                                    \fIarraySize\fB)
character*N \fIoption\fB
real*4 \fIarray\fB(N)           [Returned argument]
integer*4 \fInumToGet\fB        [Returned argument if initially 0]
integer*4 \fIarraySize\fB
.ft R
.fi

These functions return an array of integers or floating point values for the
given option.  The argument \fInumToGet\fR should be set to the number of
values to be retrieved, or to 0 if a variable number of entries is allowed.
In the latter case, the functions will return the number of values in
\fInumToGet\fR.  The size of \fIarray\fR should be specified in
\fIarraySize\fR.  The return value is 1 if the user did not enter the given
option.

.nf
.ft B
int PipGetInOutFile(const char *\fIoption\fB, int \fInonOptArgNo\fB, 
                    char **\fIfilename\fB)

integer*4 function PipGetInOutFile(\fIoption\fB, \fInonOptArgNo\fB, \fIprompt\fB,
                                   \fIfilename\fB)
character*N \fIoption\fB, \fIprompt\fB
integer*4 \fInonOptArgNo\fB
character*N \fIfilename\fB           [Returned argument]
.ft R
.fi

This function gets a filename specified
by \fIoption\fR; if that option was not entered, it gets the non-option
argument in the \fInonOptArgNo\fR position (numbered from 0 in C and Python,
from 1 in Fortran).  If that argument does not
exist either, it returns with an error.
Alternatively for Fortran, if interactive
input is being used, it prompts for the filename interactively with the
string in \fIprompt\fR.  If
there is no interactive input, supply an empty string for \fIprompt\fR.

To prevent the function from looking for a non-option argument, call it
with \fInonOptArgNo\fR bigger than the value of \fInumNonOptArg\fR. 


.SS Functions for Help, Entry Printing, Cleanup, and Errors

.nh
.ft B
.nf
int PipSetManpageOutput(int \fItype\fB);

subroutine PipSetManpageOutput(\fItype\fB)
integer*4 \fItype\fB
.ft R
.fi

This function stores \fItype\fR in the static variable \fIoutputManpage\fR
to control the type of help output.  If the value is left at 0, a standard
usage output is produced.  A value of 1 produces output for a man page to
be interpreted by \fBnroff\fR (a .man file), while -1 produces output for a
preformatted man page (a .1 file).  A value of -2 produces the complete 
Fortran code for a fallback option string, while 2 or 3 produce output for C
or Python code defining an array of option strings, all suitable for passing
to \fBPipReadOrParseOptions\fR.

.nh
.ft B
.nf
int PipSetUsageString(const char *usage);

integer*4 function PipSetUsageString(\fIusage\fB)
character*N \fIusage\fB
.ft R
.fi

This function allows you set a custom usage string to replace the default
output entirely.  PIP will print a newline after this string so it need not be
included.  A multiline string can be supplied with embedded newlines.

.nh
.ft B
.nf
int PipPrintHelp(const char *\fIprogName\fB, int \fIuseStdErr\fB, int \fIinputFiles\fB,
                 int \fIoutputFiles\fB);

integer*4 function PipPrintHelp(\fIprogName\fB, \fIuseStdErr\fB, \fIinputFiles\fB,
                                \fIoutputFiles\fB)
character*N \fIprogName\fB
integer*4 \fIuseStdErr\fB, \fIinputFiles\fB, \fIoutputFiles\fB
.ft R
.fi

This function produces a complete, formatted listing of options and
their help strings, depending on the value of \fIoutputManpage\fR as 
described just above.  The program name should be supplied in
\fIprogName\fR.  The listing is sent to standard output or standard
error depending on whether \fIuseStdErr\fR is 0 or 1.  The usage
summary includes \fIinput_file\fR or \fIinput_files...\fR if
\fIinputFiles\fR is 1 or 2, respectively; and \fIoutput_file\fR or
\fIoutput_files...\fR if \fIoutputFiles\fR is 1 or 2 respectively.

.nh
.ft B
.nf
void PipEnableEntryOutput(int \fIenable\fB);

subroutine PipEnableEntryOutput(\fIenable\fB)
integer*4 \fIenable\fB
.ft R
.fi

This call controls whether \fBPipPrintEntries\fR will print the entries to
the program.  If \fIenable\fR is 1, printing is enabled; if it is 0 printing is
disabled, and if it is -1 then printing is controlled by the value of the
environment variable PIP_PRINT_ENTRIES.

.ft B
.nf
void PipPrintEntries(void);
subroutine PipPrintEntries()
.ft R
.fi

This call causes the module to print a summary of all options entered to 
the program, if enabled either by a call to \fBPipEnableEntryOutput\fR or by
the environment variable PIP_PRINT_ENTRIES.  The header line will include the
program name if \fBPipReadOptionFile\fR was used for startup.  

.ft B
.nf
void PipDone(void);
subroutine PipDone()
.ft R
.fi

This call frees all allocated memory and reinitializes all variables so that
another complete round of processing could occur.


.ft B
.nf
int PipGetError(char **\fIerrString\fB);

integer*4 function PipGetError(\fIerrString\fB)
character*N \fIerrString\fB     [Returned argument]
.ft R
.fi

Use this function to get the error string generated by PIP from the last
error.
When called from C and a string is returned, the string is allocated
with malloc() and can be freed with free().


.ft B
.nf
int PipMemoryError(void *\fIptr\fB, const char *\fIroutine\fB);
.ft R
.fi

Tests \fIptr\fR and returns 0 if it is non-NULL; otherwise it makes up
an error string including the name given in \fIroutine\fR and calls
\fBPipSetError\fR, then returns -1.

.ft B
.nf
int PipSetError(const char *\fIerrString\fB);
.ft R
.fi

Sets the error string and, if PIP has been set to exit on error, prints
an error message and exits.

.ft B
.nf
void exitError(const char *\fIformat\fB, ...);

subroutine exitError(\fIerrString\fB)
character*N \fIerrString\fB

void setExitPrefix(const char *\fIprefix\fB);

subroutine setExitPrefix(\fIprefix\fB)
character*N \fIprefix\fB

subroutine memoryError(\fIierr\fB, \fIerrString\fB)
integer*4 \fIierr\fB
character*N \fIerrString\fB
.ft R
.fi

\fBexitError\fR exits after printing an error string after a prefix, which 
is set by calling \fBsetExitPrefix\fR.  The Fortran version takes the 
error string while the C version takes variable arguments like \fBprintf\fR.
A space will be printed between the prefix and error string, and a newline
printed after the error, so it is not necessary to include a newline in the
string.  The prefix is also set automatically
by calling \fBPipReadOrParseOptions\fR or \fBPipExitOnError\fR; in the latter
case the destination for error output can be specified, whereas using 
\fBsetExitPrefix\fR will cause output to go to standard out.  These two
functions can be used by programs that do not call anything else in PIP;
however, \fBexitError\fR will work only if the exit prefix has been set to a
non-empty string with either \fBsetExitPrefix\fR or \fBPipExitOnError\fR.
The Fortran routine \fBmemoryError\fR tests whether \fIierr\fR  is nonzero
and, if so, calls \fBexitError\fR with \fIerrString\fR appended to "FAILURE TO
ALLOCATE ".

.SS Calling from Python
The Python versions of the functions handle returned values differently:
the values that would be returned in the function arguments in C or Fortran
are returned in a single object as the return value of the function.
For functions with multiple values, this will be a tuple.  When an error
occurs, this will be None.  The value corresponding to the return value from a
C function is
obtained by calling the function \fBPipGetErrNo\fR.  Functions that in C do
not return any values except for the error code also set the error code for
retrieval by \fBPipGetErrNo\fR and
return 0 for success or None for an error.

If you do not set PIP to exit on error,
then you need to process return values in two steps, as in:
   retval = PipGetThreeIntegers('option', ix, iy, iz)
   if retval == None:
        process the error
   (ix, iy, iz) = retval

This is not needed if PIP exits on error.  In that case, if you need to 
determine whether an option was entered, use:
   (ix, iy, iz) = PipGetThreeIntegers('option', ix, iy, iz)
   optionEntered = 1 - PipGetErrNo()

Here are the conventions for all of
available function calls:

.ft B
.nf
Functions for Initialization:

\fIstatus\fB = PipExitOnError(\fIuseStdErr\fB, \fIprefix\fB)

PipSetLinkedOption(\fIoption\fB)

(\fInumOptArgs\fB, \fInumNonOptArgs\fB) = PipParseInput(\fIsys.argv\fB, \fIoptions\fB)

PipReadOptionFile(\fIprogName\fB)
.ft R
.fi
In the call to the C function, the \fIhelpLevel\fR argument is set at 1 and 
the \fIlocalDir\fR argument is set at 0.

.ft B
.nf
(\fInumOptArgs\fB, \fInumNonOptArgs\fB) = PipParseEntries(\fIsys.argv\fB)

(\fInumOptArgs\fB, \fInumNonOptArgs\fB) = PipReadOrParseOptions(\fIsys.argv\fB, \fIoptions\fB, 
                   \fIprogName\fB, \fIminArgs\fB, \fInumInFiles\fB, \fInumOutFiles\fB)
.ft R
.fi
These are similar to the C functions described above.  \fIoptions\fR should be a list of
strings as in the call to the C function.  If \fI-help\fR is defined as an
option and the user adds this option, then \fBPipReadOrParseOptions\fR will 
print the usage and exit as in Fortran.

.ft B
.nf
\fIstatus\fB = PipInitialize(numOpts)

(\fInumOptArgs\fB, \fInumNonOptArgs\fB) = PipNumberOfArgs()

Functions for Getting Values:
.ft R
.br
.fi
When an option is not entered, the function returns the supplied
argument value(s).
.nf
.ft B

\fInumEntries\fB = PipNumberOfEntries(\fIoption\fB)

\fIindex\fB = PipLinkedIndex(\fIoption\fB)

\fIstring\fB = PipGetNonOptionArg(\fInonOptArgNo\fB)

\fIstring\fB = PipGetString(\fIoption\fB, \fIstring\fB)

\fIiVal\fB = PipGetInteger(\fIoption\fB, \fIiVal\fB)

\fIfVal\fB = PipGetFloat(\fIoption\fB, \fIfVal\fB)

(\fIiVal1\fB, \fIiVal2\fB) = PipGetTwoIntegers(\fIoption\fB, \fIiVal1\fB, \fIiVal2\fB)

(\fIfVal1\fB, \fIfVal2\fB) = PipGetTwoFloats(\fIoption\fB, \fIfVal1\fB, \fIfVal2\fB)

(\fIiVal1\fB, \fIiVal2\fB, \fIiVal3\fB) = PipGetThreeIntegers(\fIoption\fB, \fIiVal1\fB, \fIiVal2\fB, \fIiVal3\fB)

(\fIfVal1\fB, \fIfVal2\fB, \fIfVal3\fB) = PipGetThreeFloats(\fIoption\fB, \fIfVal1\fB, \fIfVal2\fB, \fIfVal3\fB)

\fIiVal\fB = PipGetBoolean(\fIoption\fB,\fIiVal\fB)

\fIiArray\fB = PipGetIntegerArray(\fIoption\fB, \fInumToGet\fB)

\fIfArray\fB = PipGetFloatArray(\fIoption\fB, \fInumToGet\fB)
.ft R
.fi
These two functions return the arrays as lists of values.  As for the C
functions, \fInumToGet\fR specifies the number to return, or 0 to return all
available values.
.ft B
.nf

\fIfilename\fB = PipGetInOutFile(\fIoption\fB, \fInonOptArgNo\fB)

Functions for Help, Cleanup, and Errors:

\fIstatus\fB = PipPrintHelp(\fIprogName\fB, \fIuseStdErr\fB, \fIinputFiles\fB, \fIoutputFiles\fB)

PipEnableEntryOutput(\fIenable\fB)

PipPrintEntries()

PipDone()

\fIerrStr\fB = PipGetError()

\fIerrNo\fB = PipGetErrNo()

\fIstatus\fB = PipSetError(\fIerrString\fB)

exitError(\fIstring\fB)

setExitPrefix(\fIprefix\fB)
.ft R
.fi

.SH AUTHOR
David Mastronarde (mast@colorado.edu)
