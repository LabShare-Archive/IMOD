.na
.nh
.ll 7.5i
.TH PIP 1 3.0.11 BL3DEMC
.SH NAME
.nh
PIP \- package for parsing input parameters from Fortran or C
.SH USER DESCRIPTION
.nh
PIP is a package of functions for entering parameters into programs.  A
program using PIP will accept input in two different ways.  Options and their
values can be entered as command line arguments, or on separate lines with
one option name per line followed by its value.  The multi-line entry can be
made via standard input, on lines following the command line invoking the 
program; in addition, the program may also allow entries in this format to be
read from a separate parameter file.  These different methods may even be used
together, with some options taken from the command line and some from line
entries.

Options are generally given both a short and long name, with the short name
designed for convenience when used at the command line, and the long name
being more descriptive for use in command files.  However, either form may be
used in either place.  The names are case-sensitive.  Options can be
abbreviated to their shortest unique form, sometimes one or two letters.

When entered at the command line, options must be preceded by one or two dashes
(- or --).  The option must be followed by a space then a value if
appropriate.  If the value contains embedded blanks it must be enclosed in 
quotes.  Options cannot be concatenated the way single letter options in 
Unix programs often can be.

Multiple-line entry is invoked by entering the argument \fB-StandardInput\fR on
the command line, or, if the program allows, by entering the option to read
a parameter file, followed by the name of the file.  The program will read
lines of input until the tag \fBEndInput\fR is read or until the end of the
file is reached.  It will then resume processing command line arguments, if
any.

The format of the line entry is an option name followed by any number of
spaces or tabs and an optional equals sign, followed by the value of the
option.  If the value consists of multiple numbers, they can be separated by
spaces, tabs or commas.  If a value consists of a text string, it may contain
embedded blanks.

Blank lines and lines starting with # are ignored.  A comment starting with #
can also be placed on a line after an option and its value.

Programs may allow Fortran-style default input, in which
a comma without a number indicates that the default value for the number
should be taken, and a / indicates that all remaining numbers have their
default values.  For example, 23,,15 takes the default for the second value
and ,42,17 takes the default for the first; 1,1024/ takes the default for
all values after the first two and / takes the default for all values.
Defaults can be used only when a fixed number of values are expected.

Boolean options are ones that turn a particular feature on or off.  When
entered as command lines arguments, they must not be followed by a value; in
other words, the presence of the entry sets the option to true or on.
However, when a boolean option is entered in a separate line in a command
file, it may be followed by 0, F, f, FALSE, false, OFF, off, 1, T, t, TRUE,
true, ON, or on.

Options can be entered more than once.  In most cases a later value will
supercede a previous entry, but in some cases the multiple entries will
accumulate.  This is useful if multiple input file names are needed, or if
more numbers need to be entered than will fit on a line.

PIP provides a standard help output which the program should make available
with an option such as \fB-help\fR or \fB-usage\fR.  Invoking a program with
no arguments may also cause this to be printed, unless the program still
supports old-style interactive input as the default when there are no
arguments.  The help output will list the two forms for each option, indicate
what kind of value is expected, and provide a one-line description of the
option.  In addition, it will indicate if multiple entries of an option will
accumulate.

.SH PROGRAMMING DESCRIPTION
.nh
The simplest way to use PIP is first to set up its state with optional calls
to \fBPipExitOnError\fR and \fBPipAllowCommaDefaults\fR, then pass it the
list of options and have it parse input with \fBPipParseInput\fR, then
get option
values with a series of \fBPipGet...\fR calls, then finish with \fBPipDone\fR.
PIP can also read the list of options from a separate file, referred to as an
autodoc file.  In this case, instead of calling \fBPipParseInput\fR, one
calls \fBPipReadOptionFile\fR to read the options from the file, then 
\fBPipParseEntries\fR to parse the input.  From Fortran, there is also
a convenience function, \fBPipReadOrParseOptions\fR, that will first try to
read options from an autodoc file, then fall back to a list of options supplied
by the calling program.

For use from C, the header file \fBparse_params.h\fR is in the IMOD/include
directory.  The PIP package and Fortran-callable wrappers are in the
\fBlibimod\fR library.  The Fortran versions of \fBPipParseInput\fR and
\fBPipReadOptionFile\fR are in the
\fBlibhvem\fR library, which requires \fBlibimod\fR.

Fortran-callable wrappers to the C functions have been given the same name as 
the C functions, although internally they are all lower case with an
underscore appended.  The function calls from Fortran are case-insensitive but
they are shown with mixed case here for clarity.

.SS Option Specifications Supplied by the Calling Program
Each legal option should be specified with a string having up to 4 
components:
  \fBshortName:longName:type:helpString\fR

The short name is intended to be used predominantly on the command line, while
the long name would be more suitable in parameter files.  However,
PIP makes no distinction between the short and long names.  Either name can be
abbreviated, either name can be preceded by either one or two dashes, and
either name can be omitted.  Any of these 4 components can be omitted as long
as there is either a short or a long name.  The string must have 3 colons.

.SS Option Types
.nf
\fBB\fR    Boolean - the only type that does not require a value
\fBI\fR    Integer
\fBIP\fR   Pair of integers
\fBIT\fR   Three integers
\fBIA\fR   Integer array
\fBF\fR    Floating point
\fBFP\fR   Pair of floating point numbers
\fBFT\fR   Three floating point numbers
\fBFA\fR   Floating point array
\fBCH\fR   Character string
\fBFN\fR   File name
\fBLI\fR   List (comma-separated list of ranges)
\fBPF\fR   Parameter file
.fi

If an option specification ends in \fBM\fR, this indicates that multiple
entries of the option will accumulate rather than supercede each other.  This
allows multiple filenames of a particular type to be entered, or multiple
lines of input for long lists of numbers.

PIP uses these types primarily to provide information in the help output and
does not enforce the implications of these types, except as follows: 
an option that does not take an argument must be coded as \fBB\fR; a parameter
file option must be coded as \fBPF\fR.

.SS Option Specifications in an Autodoc File
The autodoc file is designed to provide a single source of information
about program options for the program itself, the man page, and graphical user
interfaces that run the program.  The file consists of global metadata at
the start, then a series of sections starting with a token inside brackets.
Each section can then contain keyword-value pairs.  The general form of
a token entry is:
   \fB[token delimiter label_string]\fR
.br
and the general form of a keyword-value pair is:
   \fBkeyword delimiter value\fR
.br
Tokens and keywords must not contain embedded spaces, although values and
label strings may.  There can be spaces or tabs before and after the
delimiter; these will not be considered part of the token or value strings.
PIP will ignore white space before keywords or tokens, but other parsers of
autodoc files may not accept this.
The default delimiter is an equals sign (=).  It can be changed once, in
the metadata, before any tokens have been encountered, with a statement
such as:
   \fBKeyValueDelimiter = ==\fR

PIP will examine keyword-value pairs only after a \fBField\fR token, which
signifies the start of an option, or after a \fBSectionHeader\fR token,
which can be used to introduce some header text into the usage or manpage
outputs.  The following
keywords are understood by PIP in a \fBField\fR section, while others are
ignored:
.nf
\fBshort\fR    Short option name
\fBlong\fR     Long option name
\fBtype\fR     Type of option; see table above
\fBusage\fR    Help string for usage output
\fBtooltip\fR  Help string for tooltip
\fBmanpage\fR  Help string for manual page
.fi

If one of these keywords has no value after it, PIP will ignore the entry.
Short and long option names should not contain spaces.  The help strings are
allowed to contain spaces, and to continue on multiple lines.  A
continuation line should not have \fB#\fR or \fB[\fR as its first non-white
space character, nor should it contain the key-value delimiter.  Lines are
added to a help string until a line with the delimiter is encountered.  If
you want to use = in help strings, change the delimiter to ==
as shown above.  Use \fB^\fR at the beginning of a continuation line to
start a new line before outputting the text on the line.  Spaces after 
the \fB^\fR will be retained, so that lines can be indented in a man page.

Lines containing only white space, and lines with \fB#\fR as the first
non-white space, are ignored.

In a \fBSectionHeader\fR section, keywords besides \fBusage\fR and 
\fBmanpage\fR are ignored.  Help strings will be output without indentation;
for a man page that is input to \fBnroff\fR, start the string with .SS or .SH
to avoid the regular indentation of option text.
.SS Functions for Initialization
.nh
.ft B
.nf
int PipExitOnError(int \fIuseStdErr\fB, char *\fIprefix\fB);

integer*4 function PipExitOnError(int \fIuseStdErr\fB, char *\fIprefix\fB)
integer*4 \fIuseStdErr\fB
character*N \fIprefix\fB
.ft R
.fi

Use this function to enable PIP to exit with a message upon any error in
program function or user input.  The string \fIprefix\fR will be placed in
front of the error message that PIP ordinarily generates upon error, and the
message will be printed to standard output or standard error depending on
whether \fIuseStdErr\fR is 0 or 1.  PIP will exit with an error status.  If
\fIprefix\fR is an empty string, then this feature is disabled.


.ft B
.nf
void PipAllowCommaDefaults(int \fIval\fB);

subroutine PipAllowCommaDefaults(\fIval\fB)
integer*4 \fIval\fB
.ft R
.fi

If \fIIval\fR
is non-zero, then Fortran-style default input will be allowed whenever
a fixed number of values are being returned.  Specifically, if commas are
used to separate entries and there is no entry between a pair of commas, then
the returned value will be unmodified from the default value supplied in the
call.  A / character will terminate input and leave all remaining expected
elements at their default values.


.ft B
.nf
int PipParseInput(int \fIargc\fB, char \fI*argv[]\fB, char \fI*options[]\fB,
                  int \fInumOptions\fB, int \fI*numOptArgs\fB, 
                  int \fI*numNonOptArgs\fB);

integer*4 function PipParseInput(\fIoptions\fB, \fInumOptions\fB, \fIseparator\fB,
                                 \fInumOptArg\fB, \fInumNonOptArg\fB)
character*N \fIoptions\fB(N)
integer*4 \fInumOptions\fB
character \fIseparator\fB
integer*4 \fInumOptArg\fB, \fInumNonOptArg\fB    [Returned arguments]
.ft R
.fi

This is a high-level function that will initialize PIP (\fBPipInitialize\fR)
for the number of options given in \fInumOptions\fR,
take the list of all available options specified in 
\fIoptions\fR and add them one at a time with \fBPipAddOption\fR, parse
command line arguments and other input with \fBPipNextArg\fR, and return the 
number of option
arguments in \fInumOptArg\fR and the number of
non-option arguments in \fInumNonOptArg\fR.  The C version receives the command
line arguments directly while the Fortran version fetches them with 
\fBgetarg\fR.

There are two alternatives for Fortran usage.  Each option specification
can placed in a separate element of the \fIoptions\fR array.  In this case,
\fIoptions\fR should be dimensioned to the number of options, \fIseparator\fR
should be a space character, and the length of the character elements of the
array should at least as big as the longest option description.  Alternatively,
all of the options can be placed in one character string, separated by the
character given in \fIseparator\fR.  In this case, set the dimension 
of \fIoptions\fR
to 1 and make its length be big enough for the entire string.


.ft B
.nf
int PipReadOptionFile(char \fI*progName\fB, int \fIhelpLevel\fB, int \fIlocalDir\fB)

integer*4 function PipReadOptionFile(\fIprogName\fB, \fIhelpLevel\fB, \fIlocalDir\fB)
character*N \fIprogName\fB
integer*4 \fIhelpLevel, localDir\fB
.ft R
.fi

This function will read options from an autodoc file,
\fBprogName.adoc\fR.
If \fIlocalDir\fR is 0, this file will be sought first in the directory
pointed to by the environment variable AUTODOC_DIR, if it is defined; then
in the directory $IMOD_DIR/autodoc; then in the current directory.  If
\fIlocalDir\fR is 1 or 2, etc., the file will be sought in ../autodoc
or ../../autodoc, etc., then in the current directory.  This allows PIP to
generate a man page entry from the autodoc file in the current source tree
rather than in the installed version of IMOD.

The \fIhelpLevel\fR argument determines which help string is used when
multiple strings are available. 
.br
If \fIhelpLevel\fR is 1, then the usage string
will be stored if available, or the tooltip string if there is no usage
string, or the manpage string if neither tooltip nor usage is available.
.br
If \fIhelpLevel\fR is 2, then the tooltip string
will be stored if available, or the usage string if there is no tooltip
string, or the manpage string if neither tooltip nor usage is available.
.br
If \fIhelpLevel\fR is 3, then the manpage string
will be stored if available, or the tooltip string if there is no manpage
string, or the usage string if neither tooltip nor manpage is available.


.ft B
.nf
int PipParseEntries(int \fIargc\fB, char \fI*argv[]\fB, int \fI*numOptArgs\fB, 
                    int \fI*numNonOptArgs\fB);

integer*4 function PipParseEntries(\fInumOptArg\fB, \fInumNonOptArg\fB)
integer*4 \fInumOptArg\fB, \fInumNonOptArg\fB    [Returned arguments]
.ft R
.fi

This high-level function is used after options have been read from an
autodoc file with \fBPipReadOptionFile\fR.
It parses command line arguments and other input with \fBPipNextArg\fR,
and return the number of option
arguments in \fInumOptArg\fR and the number of
non-option arguments in \fInumNonOptArg\fR.  The C version receives the command
line arguments directly while the Fortran version fetches them with 
\fBgetarg\fR.


.ft B
.nf
subroutine PipReadOrParseOptions(\fIoptions\fB, \fInumOptions\fB, \fIprogName\fB, 
                                 \fIexitString\fB, \fIinteractive\fB, \fIminArgs\fB, 
                                 \fInumInFiles\fB, \fInumOutFiles\fB, 
                                 \fInumOptArg\fB, \fInumNonOptArg\fB)
character*N \fIoptions\fB
character*N \fIprogName\fB
character*N \fIexitString\fB
logical \fIinteractive\fB
integer*4 \fIminArgs\fB, \fInumInFiles\fB, \fInumOutFiles\fB
integer*4 \fInumOptArg\fB, \fInumNonOptArg\fB    [Returned arguments]
.ft R
.fi

This function, available only from Fortran, performs a sequence of
initialization tasks.  It first attempts to read options for the program
\fIprogName\fR from an autodoc file using \fBPipReadOptionFile\fR then
\fBPipParseEntries\fR.  If this
fails, it falls back to calling \fBPipParseInput\fR to define
\fInumOptions\fR options from the single string \fIoptions\fR, with the
separator \fB@\fR between options.  It allows comma defaults with 
\fBPipAllowCommaDefaults\fR, and calls \fBPipExitOnError\fR with the prefix
string in \fIexitString\fR.  If \fIinteractive\fR is \fB.true.\fR, the routine
returns if there are no input arguments.  Otherwise, it checks for whether to
print a usage output.  If the number of arguments is less than
\fIminArgs\fR or \fB-help\fR is entered as an argument, then it calls
\fBPipPrintHelp\fR with \fInumInFiles\fR and \fInumOutFiles\fR as arguments
for the number of input and output files, then exits.
The option \fBhelp\fR must therefore be defined.


.ft B
.nf
int PipInitialize(int \fInumOpts\fB);

integer*4 function PipInitialize(int \fInumOpts\fB)
integer*4 \fInumOpts\fB
.ft R
.fi

This function will initialize PIP and allocate memory for the number of
options given in \fInumOpts\fR.


.ft B
.nf
int PipAddOption(char *\fIoptionString\fB);

integer*4 function PipAddOption(\fIoptionString\fB)
character*N \fIoptionString\fB
.ft R
.fi

This function is used to add one option at a time to PIP's table of options.


.ft B
.nf
int PipNextArg(char *\fIargString\fB);

integer*4 function PipNextArg(\fIargString\fB)
character*N \fIargString\fB
.ft R
.fi

This function is used to send each argument in turn to PIP.  An option will
be checked against the list of legal options; a value for an option will be
associated with the option in PIP's table; and a non-option argument will
be stored in PIP's list of those.  The function returns 1 if an argument is
an option that requires a value.


.ft B
.nf
void PipNumberOfArgs(int *\fInumOptArgs\fB, int *\fInumNonOptArgs\fB);

subroutine PipNumberOfArgs(\fInumOptArgs\fB, \fInumNonOptArgs\fB);
integer*4 \fInumOptArg\fB, \fInumNonOptArg\fB      [Returned arguments]
.ft R
.fi

After arguments have been parsed, this function returns the number of option
arguments in \fInumOptArg\fR and the number of non-option arguments in
\fInumNonOptArgs\fR.

.SS Functions for Getting Values

.nh
.ft B
.nf
int PipNumberOfEntries(char *\fIoption\fB, int *\fInumEntries\fB);

integer*4 function PipNumberOfEntries(\fIoption\fB, \fInumEntries\fB);
character*N \fIoption\fB
integer*4 \fInumEntries\fB     [Returned argument]
.ft R
.fi

This function returns the number of accumulated entries for the given option
in the argument \fInumEntries\fR.  After calling this function, simply call
a function to get the value of the option that number of times to
retrieve all of the entered values.


.ft B
.nf
int PipGetNonOptionArg(int \fIargNo\fB, char **\fIarg\fB);

integer*4 function PipGetNonOptionArg(\fIargNo\fB, \fIarg\fB)
integer*4 \fIargNo\fB
character*N \fIarg\fB           [Returned argument]
.ft R
.fi

This function returns the non-option argument specified by \fIargNo\fR
(numbered from 0 in C, from 1 in Fortran) in as a string in the argument
\fIarg\fR.  Note that non-option arguments can also be retrieved by calling
\fBPipGetString\fR repeatedly with the option as \fBNonOptionArgument\fR or
any abbreviation thereof.  When called from C and a string is returned, the
string is allocated with malloc() and should be freed with free().

.ft B
.nf
int PipGetString(char *\fIoption\fB, char **\fIstring\fB);

integer*4 function PipGetString(\fIoption\fB, \fIstring\fB)
character*N \fIoption\fB
character*N \fIstring\fB        [Returned argument]
.ft R
.fi

This function returns the value of the given option as a string in the
argument \fIstring\fR.  The return value is 1 if the user did not enter this
option.  When called from C and a string is returned, the string is allocated
with malloc() and should be freed with free().


.ft B
.nf
int PipGetInteger(char *\fIoption\fB, int *\fIval\fB);

integer*4 function PipGetInteger(\fIoption\fB, \fIval\fB)
character*N \fIoption\fB
integer*4 \fIval\fB             [Returned argument]

int PipGetFloat(char *\fIoption\fB, float *\fIval\fB);

integer*4 function PipGetFloat(\fIoption\fB, \fIval\fB)
character*N \fIoption\fB
real*4 \fIval\fB                [Returned argument]
.ft R
.fi

These functions returns a single integer or floating point value for the given
option in the argument \fIval\fR.  The return value is 1 if the user did not
enter this option.


.ft B
.nf
int PipGetTwoIntegers(char *\fIoption\fB, int *\fIval1\fB, int *\fIval2\fB);

integer*4 function PipGetInteger(\fIoption\fB, \fIval1\fB, \fIval2\fB)
character*N \fIoption\fB
integer*4 \fIval1, val2\fB             [Returned arguments]

int PipGetTwoFloats(char *\fIoption\fB, float *\fIval1\fB, float *\fIval2\fB);

integer*4 function PipGetInteger(\fIoption\fB, \fIval1\fB, \fIval2\fB)
character*N \fIoption\fB
real*4 \fIval1, val2\fB             [Returned arguments]

.ft R
.fi

These functions returns two integers or two floats for the given
option in the arguments \fIval1\fR and \fIval2\fR.
The return value is 1 if the user did not enter this option.


.ft B
.nf
int PipGetThreeIntegers(char *\fIoption\fB, int *\fIval1\fB, int*\fIval2\fB,
                        int*\fIval3\fB,);

integer*4 function PipGetInteger(\fIoption\fB, \fIval1\fB, \fIval2\fB, \fIval3\fB)
character*N \fIoption\fB
integer*4 \fIval1, val2, val3\fB             [Returned arguments]

int PipGetThreeFloats(char *\fIoption\fB, float *\fIval1\fB, float*\fIval2\fB,
                      float*\fIval3\fB);

integer*4 function PipGetInteger(\fIoption\fB, \fIval1\fB, \fIval2\fB, \fIval3\fB)
character*N \fIoption\fB
real*4 \fIval1, val2, val3\fB             [Returned arguments]

.ft R
.fi

These functions returns three integers or three floats for the given
option in the arguments \fIval1\fR, \fIval2\fR, and \fIval2\fR.
The return value is 1 if the user did not enter this option.


.ft B
.nf
int PipGetBoolean(char *\fIoption\fB, int *\fIval\fB);

integer*4 function PipGetBoolean(\fIoption\fB, \fIval\fB)
character*N \fIoption\fB
integer*4 \fIval\fB             [Returned argument]
.ft R
.fi

This function returns a value of 0 or 1 for the given boolean option in the
argument \fIval\fR.  The return value is 1 if the user did not enter this
option.


.ft B
.nf
integer*4 function PipGetLogical(\fIoption\fB, \fIval\fB)
character*N \fIoption\fB
logical \fIval\fB             [Returned argument]
.ft R
.fi

This function returns a value of .true. or .false. for the given boolean
option in the argument \fIval\fR.  The return value is 1 if the user did not
enter this option.


.ft B
.nf
int PipGetIntegerArray(char *\fIoption\fB, int *\fIarray\fB, int *\fInumToGet\fB,
                       int \fIarraySize\fB);

integer*4 function PipGetIntegerArray(\fIoption\fB, \fIarray\fB, \fInumToGet\fB, 
                                      \fIarraySize\fB)
character*N \fIoption\fB
integer*4 \fIarray\fB(N)        [Returned argument]
integer*4 \fInumToGet\fB        [Returned argument if initially 0]
integer*4 \fIarraySize\fB

int PipGetFloatArray(char *\fIoption\fB, float *\fIarray\fB, int *\fInumToGet\fB,
                     int \fIarraySize\fB);

integer*4 function PipGetFloatArray(\fIoption\fB, \fIarray\fB, \fInumToGet\fB,
                                    \fIarraySize\fB)
character*N \fIoption\fB
real*4 \fIarray\fB(N)           [Returned argument]
integer*4 \fInumToGet\fB        [Returned argument if initially 0]
integer*4 \fIarraySize\fB
.ft R
.fi

These functions return an array of integers or floating point values for the
given option.  The argument \fInumToGet\fR should be set to the number of
values to be retrieved, or to 0 if a variable number of entries is allowed.
In the latter case, the functions will return the number of values in
\fInumToGet\fR.  The size of \fIarray\fR should be specified in
\fIarraySize\fR.  The return value is 1 if the user did not enter the given
option.

.nf
.ft B
integer*4 function PipGetInOutFile(\fIoption\fB, \fInonOptArgNo\fB, \fIprompt\fB,
                                   \fIfilename\fB)
character*N \fIoption\fB, \fIprompt\fB
integer*4 \fInonOptArgNo\fB
character*N \fIfilename\fB           [Returned argument]
.ft R
.fi

This function is available from Fortran only.  It gets a filename specified
by \fIoption\fR; if that option was not entered, it gets the non-option
argument in the \fInonOptArgNo\fR position.  If that argument does not
exist either, it returns with an error.  Alternatively, if interactive
input is being used, it prompts for the filename interactively with the
string in \fIprompt\fR.

To prevent the function from looking for a non-option argument, call it
with \fInonOptArgNo\fR bigger than the value of \fInumNonOptArg\fR.  If
there is no interactive input, supply an empty string for \fIprompt\fR.


.SS Functions for Help, Cleanup, and Errors

.nh
.ft B
.nf
int PipSetManpageOutput(int \fItype\fB);

subroutine PipSetManpageOutput(\fItype\fB)
integer*4 \fItype\fB
.ft R
.fi

This function stores \fItype\fR in the static variable \fIoutputManpage\fR
to control the type of help output.  If the value is left at 0, a standard
usage output is produced.  A value of 1 produces output for a man page to
be interpreted by \fBnroff\fR (a .man file), while -1 produces output for a
preformatted man page (a .1 file).  A value of -2 produces the complete 
Fortran code for a fallback option string to be passed to
\fBPipReadOrParseOptions\fR.

.nh
.ft B
.nf
int PipPrintHelp(char *\fIprogName\fB, int \fIuseStdErr\fB, int \fIinputFiles\fB,
                 int \fIoutputFiles\fB);

integer*4 function PipPrintHelp(\fIprogName\fB, \fIuseStdErr\fB, \fIinputFiles\fB,
                                \fIoutputFiles\fB)
character*N \fIprogName\fB
integer*4 \fIuseStdErr\fB, \fIinputFiles\fB, \fIoutputFiles\fB
.ft R
.fi

This function produces a complete, formatted listing of options and
their help strings, depending on the value of \fIoutputManpage\fR as 
described just above.  The program name should be supplied in
\fIprogName\fR.  The listing is sent to standard output or standard
error depending on whether \fIuseStdErr\fR is 0 or 1.  The usage
summary includes \fIinput_file\fR or \fIinput_files...\fR if
\fIinputFiles\fR is 1 or 2, respectively; and \fIoutput_file\fR or
\fIoutput_files...\fR if \fIoutputFiles\fR is 1 or 2 respectively.


.ft B
.nf
void PipDone(void);
subroutine PipDone()
.ft R
.fi

This call frees all allocated memory and reinitializes all variables so that
another complete round of processing could occur.


.ft B
.nf
int PipGetError(char **\fIerrString\fB);

integer*4 function PipGetError(\fIerrString\fB)
character*N \fIerrString\fB     [Returned argument]
.ft R
.fi

Use this function to get the error string generated by PIP from the last
error.
When called from C and a string is returned, the string is allocated
with malloc() and can be freed with free().


.ft B
.nf
int PipMemoryError(void *\fIptr\fB, char *\fIroutine\fB);
.ft R
.fi

Tests \fIptr\fR and returns 0 if it is non-NULL; otherwise it makes up
an error string including the name given in \fIroutine\fR and calls
\fBPipSetError\fR, then returns -1.

.ft B
.nf
int PipSetError(char *\fIerrString\fB);
.ft R
.fi
Sets the error string and, if PIP has been set to exit on error, prints
an error message and exits.

.SH ERRORS AND RETURN VALUES
.nh
All functions return a negative number if an error occurs.  Functions in which
an option is specified typically return -1 if the option is not a legal one,
or -2 if the option is abbreviated ambiguously.  An error string is available
after an error by calling PipGetError.  Alternatively, the program can call
PipExitOnError at any point, and PIP will print the error string itself and 
exit with an error status.

.SH AUTHOR
David Mastronarde (mast@colorado.edu)
