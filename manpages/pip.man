.na
.nh
.ll 7.5i
.TH PIP 1 3.0.11 BL3DEMC
.SH NAME
.nh
PIP \- package for parsing input parameters from Fortran or C
.SH USER DESCRIPTION
.nh
PIP is a package of functions for entering parameters into programs.  A
program using PIP will accept input in two different ways.  Options and their
values can be entered as command line arguments, or on separate lines with
one option name per line followed by its value.  The multi-line entry can be
made via standard input, on lines following the command line invoking the 
program; in addition, the program may also allow entries in this format to be
read from a separate parameter file.  These different methods may even be used
togther, with some options taken from the command line and some from line
entries.

Options are generally given both a short and long name, with the short name
designed for convenience when used at the command line, and the long name
being more descriptive for use in command files.  However, either form may be
used in either place.  The names are case-sensitive.  Options can be
abbreviated to their shortest unique form, sometimes one or two letters.

When entered at the command line, options must be preceded by one or two dashes
(- or --).  The option must be followed by a space then a value if
appropriate.  If the value contains embedded blanks it must be enclosed in 
quotes.  Options cannot be concatenated the way single letter options in 
Unix programs often can be.

Multiple-line entry is invoked by entering the argument \fB-StandardInput\fR on
the command line, or, if the program allows, by entering the option to read
a parameter file, followed by the name of the file.  The program will read
lines of input until the tag \fBEndInput\fR is read or until the end of the
file is reached.  It will then resume processing command line arguments, if
any.

The format of the line entry is an option name followed by any number of
spaces or tabs and an optional equals sign, followed by the value of the
option.  If the value consists of multiple numbers, they can be separated by
spaces, tabs or commas.  If a value consists of a text string, it may contain
embedded blanks.

Blank lines and lines starting with # are ignored.  A comment starting with #
can also be placed on a line after an option and its value.

Programs may allow Fortran-style default input, in which
a comma without a number indicates that the default value for the number
should be taken, and a / indicates that all remaining numbers have their
default values.  For example, 23,,15 takes the default for the second value
and ,42,17 takes the default for the first; 1,1024/ takes the default for
all values after the first two and / takes the default for all values.
Defaults can be used only when a fixed number of values are expected.

Options can be entered more than once.  In most cases a later value will
supercede a previous entry, but in some cases the multiple entries will
accumulate.  This is useful if multiple input file names are needed, or if
more numbers need to be entered than will fit on a line.

PIP provides a standard help output which the program should make available
with an option such as \fB-help\fR or \fB-usage\fR.  Invoking a program with
no arguments may also cause this to be printed, unless the program still
supports old-style interactive input as the default when there are no
arguments.  The help output will list the two forms for each option, indicate
what kind of value is expected, and provide a one-line description of the
option.  In addition, it will indicate if multiple entries of an option will
accumulate.

.SH PROGRAMMING DESCRIPTION
.nh
The simplest way to use PIP is first to set up its state with optional calls
to \fBPipExitOnError\fR and \fBPipAllowCommaDefaults\fR, then pass it the
list of options and have it parse input with \fBPipParseInput\fR, then
get option
values with a series of \fBPipGet...\fR calls, then finish with \fBPipDone\fR.

For use from C, the header file \fBparse_params.h\fR is in the IMOD/include
directory.  The PIP package and Fortran-callable wrappers are in the
\fBlibimod\fR library.  The Fortran version of \fBPipParseInput\fR is in the
\fBlibhvem\fR library, which requires \fBlibimod\fR.

Fortran-callable wrappers to the C functions have been given the same name as 
the C functions, although internally they are all lower case with an
underscore appended.  The function calls from Fortran are case-insensitive but
they are shown with mixed case here for clarity.

.SS Option Specifications
Each legal option should be specified with a string having up to 4 
components:
  \fBshortName:longName:type:helpString\fR

The short name is intended to be used predominantly on the command line, while
the long name would be more suitable in parameter files.  However,
PIP makes no distinction between the short and long names.  Either name can be
abbreviated, either name can be preceded by either one or two dashes, and
either name can be omitted.  Any of these 4 components can be omitted as long
as there is either a short or a long name.  The string must have 3 colons.

.SS Option Types
.nf
\fBB\fR    Boolean - the only type that does not require a value
\fBI\fR    Integer
\fBIA\fR   Integer array
\fBF\fR    Floating point
\fBFA\fR   Floating point array
\fBCH\fR   Character string
\fBFN\fR   File name
\fBLI\fR   List (comma-separated list of ranges)
\fBPF\fR   Parameter file
.fi

If an option specification ends in \fBM\fR, this indicates that multiple
entries of the option will accumulate rather than supercede each other.  This
allows multiple filenames of a particular type to be entered, or multiple
lines of input for long lists of numbers.

PIP uses these types primarily to provide information in the help output and
does not enforce the implications of these types, except as follows: 
an option that does not take an argument must be coded as \fBB\fR; a parameter
file option must be coded as \fBPF\fR.

.SS Functions for Initialization
.nh
.ft B
.nf
int PipExitOnError(int \fIuseStdErr\fB, char *\fIprefix\fB);

integer*4 function PipExitOnError(int \fIuseStdErr\fB, char *\fIprefix\fB)
integer*4 \fIuseStdErr\fB
chararacter*N \fIprefix\fB
.ft R
.fi

Use this function to enable PIP to exit with a message upon any error in
program function or user input.  The string \fIprefix\fR will be placed in
front of the error message that PIP ordinarily generates upon error, and the
message will be printed to standard output or standard error depending on
whether \fIuseStdErr\fR is 0 or 1.  PIP will exit with an error status.  If
\fIprefix\fR is an empty string, then this feature is disabled.


.ft B
.nf
void PipAllowCommaDefaults(int \fIval\fB);

subroutine PipAllowCommaDefaults(\fIval\fB)
integer*4 \fIval\fB
.ft R
.fi

If \fIIval\fR
is non-zero, then Fortran-style default input will be allowed whenever
a fixed number of values are being returned.  Specifically, if commas are
used to separate entries and there is no entry between a pair of commas, then
the returned value will be unmodified from the default value supplied in the
call.  A / character will terminate input and leave all remaining expected
elements at their default values.


.ft B
.nf
int PipParseInput(int argc, char \fI*argv[]\fB, char \fI*options[]\fB,
                  int \fInumOptions\fB, int \fI*numOptArgs\fB, 
                  int \fI*numNonOptArgs\fB);

integer*4 function PipParseInput(\fIoptions\fB, \fInumOptions\fB, \fIseparator\fB
                                 \fInumOptArg\fB, \fInumNonOptArg\fB)
character*N \fIoptions\fB(N)
integer*4 \fInumOptions\fB
character \fIseparator\fB
integer*4 \fInumOptArg\fB, \fInumNonOptArg\fB    [Returned arguments]
.ft R
.fi

This is a high-level function that will initialize PIP (\fBPipInitialize\fR)
for the number of options given in \fInumOptions\fR,
take the list of all available options specified in 
\fIoptions\fR and add them one at a time with \fBPipAddOption\fR, parse
command line arguments and other input with \fBPipNextArg\fR, and return the 
number of option
arguments in \fInumOptArg\fB and the number of
non-option arguments in \fInumNonOptArg\fB.  The C version receives the command
line arguments directly while the Fortran version fetches them with 
\fBgetarg\fR.

There are two alternatives for Fortran usage.  Each option specification
can placed in a separate element of the \fIoptions\fR array.  In this case,
\fIoptions\fR should be dimensioned to the number of options, \fIseparator\fR
should be a space character, and the length of the character elements of the
array should at least as big as the longest option description.  Alternatively,
all of the options can be placed in one character string, separated by the
character given in \fIseparator\fR.  In this case, set the dimension 
of \fIoptions\fR
to 1 and make its length be big enough for the entire string.

.ft B
.nf
int PipInitialize(int \fInumOpts\fB);

integer*4 function PipInitialize(int \fInumOpts\fB)
integer*4 \fInumOpts\fB
.ft R
.fi

This function will initialize PIP and allocate memory for the number of
options given in \fInumOpts\fR.


.ft B
.nf
int PipAddOption(char *\fIoptionString\fB);

integer*4 function PipAddOption(\fIoptionString\fB)
character*N \fIoptionString\fB
.ft R
.fi

This function is used to add one option at a time to PIP's table of options.


.ft B
.nf
int PipNextArg(char *\fIargString\fB);

integer*4 function PipNextArg(\fIargString\fB)
character*N \fIargString\fB
.ft R
.fi

This function is used to send each argument in turn to PIP.  An option will
be checked against the list of legal options; a value for an option will be
associated with the option in PIP's table; and a non-option argument will
be stored in PIP's list of those.  The function returns 1 if an argument is
an option that requires a value.


.ft B
.nf
void PipNumberOfArgs(int *\fInumOptArgs\fB, int *\fInumNonOptArgs\fB);

subroutine PipNumberOfArgs(\fInumOptArgs\fB, \fInumNonOptArgs\fB);
integer*4 \fInumOptArg\fB, \fInumNonOptArg\fB      [Returned arguments]
.ft R
.fi

After arguments have been parsed, this function returns the number of option
arguments in \fInumOptArg\fR and the number of non-option arguments in
\fInumNonOptArgs\fR.

.SS Functions for Getting Values

.nh
.ft B
.nf
int PipNumberOfEntries(char *\fIoption\fB, int *\fInumEntries\fB);

integer*4 function PipNumberOfEntries(\fIoption\fB, \fInumEntries\fB);
character*N \fIoption\fB
integer*4 \fInumEntries\fB     [Returned argument]
.ft R
.fi

This function returns the number of accumulated entries for the given option
in the argument \fInumEntries\fR.


.ft B
.nf
int PipGetNonOptionArg(int \fIargNo\fB, char **\fIarg\fB);

integer*4 function PipGetNonOptionArg(\fIargNo\fB, \fIarg\fB)
integer*4 \fIargNo\fB
character*N \fIarg\fB           [Returned argument]
.ft R
.fi

This function returns the non-option argument specified by \fIargNo\fR
(numbered from 0 in C, from 1 in Fortran) in as a string in the argument
\fIarg\fR.  Note that non-option arguments can also be retrieved by calling
\fBPipGetString\fR repeatedly with the option as \fBNonOptionArgument\fR or
any abbreviation thereof.  When called from C and a string is returned, the
string is allocated with malloc() and should be freed with free().

.ft B
.nf
int PipGetString(char *\fIoption\fB, char **\fIstring\fB);

integer*4 function PipGetString(char *\fIoption\fB, char **\fIstring\fB)
character*N \fIoption\fB
character*N \fIstring\fB        [Returned argument]
.ft R
.fi

This function returns the value of the given option as a string in the
argument \fIstring\fR.  The return value is 1 if the user did not enter this
option.  When called from C and a string is returned, the string is allocated
with malloc() and should be freed with free().


.ft B
.nf
int PipGetInteger(char *\fIoption\fB, int *\fIval\fB);

integer*4 function PipGetInteger(\fIoption\fB, \fIval\fB)
character*N \fIoption\fB
integer*4 \fIval\fB             [Returned argument]

int PipGetFloat(char *\fIoption\fB, float *\fIval\fB);

integer*4 function PipGetFloat(\fIoption\fB, \fIval\fB)
character*N \fIoption\fB
real*4 \fIval\fB                [Returned argument]
.ft R
.fi

These functions returns a single integer or floating point value for the given
option in the argument \fIval\fR.  The return value is 1 if the user did not
enter this option.


.ft B
.nf
int PipGetTwoIntegers(char *\fIoption\fB, int *\fIval1\fB, int *\fIval2\fB);

integer*4 function PipGetInteger(\fIoption\fB, \fIval1\fB, \fIval2\fB)
character*N \fIoption\fB
integer*4 \fIval1, val2\fB             [Returned arguments]

int PipGetTwoFloats(char *\fIoption\fB, float *\fIval1\fB, float *\fIval2\fB);

integer*4 function PipGetInteger(\fIoption\fB, \fIval1\fB, \fIval2\fB)
character*N \fIoption\fB
real*4 \fIval1, val2\fB             [Returned arguments]

.ft R
.fi

These functions returns two integers or two floats for the given
option in the arguments \fIval1\fR and \fIval2\fR.
The return value is 1 if the user did not enter this option.


.ft B
.nf
int PipGetBoolean(char *\fIoption\fB, int *\fIval\fB);

integer*4 function PipGetBoolean(\fIoption\fB, \fIval\fB)
character*N \fIoption\fB
integer*4 \fIval\fB             [Returned argument]
.ft R
.fi

This function returns a value of 0 or 1 for the given boolean option in the
argument \fIval\fR.  The return value is 1 if the user did not enter this
option.


.ft B
.nf
integer*4 function PipGetLogical(\fIoption\fB, \fIval\fB)
character*N \fIoption\fB
logical \fIval\fB             [Returned argument]
.ft R
.fi

This function returns a value of .true. or .false. for the given boolean
option in the argument \fIval\fR.  The return value is 1 if the user did not
enter this option.


.ft B
.nf
int PipGetIntegerArray(char *\fIoption\fB, int *\fIarray\fB, int *\fInumToGet\fB,
                       int \fIarraySize\fB);

integer*4 function PipGetIntegerArray(\fIoption\fB, \fIarray\fB, \fInumToGet\fB, 
                                      \fIarraySize\fB)
chararacter*N \fIoption\fB
integer*4 \fIarray\fB(N)        [Returned argument]
integer*4 \fInumToGet\fB        [Returned argument if initially 0]
integer*4 \fIarraySize\fB

int PipGetFloatArray(char *\fIoption\fB, float *\fIarray\fB, int *\fInumToGet\fB,
                     int \fIarraySize\fB);

integer*4 function PipGetFloatArray(\fIoption\fB, \fIarray\fB, \fInumToGet\fB,
                                    \fIarraySize\fB)
chararacter*N \fIoption\fB
real*4 \fIarray\fB(N)           [Returned argument]
integer*4 \fInumToGet\fB        [Returned argument if initially 0]
integer*4 \fIarraySize\fB
.ft R
.fi

These functions return an array of integers or floating point values for the
given option.  The argument \fInumToGet\fR should be set to the number of
values to be retrieved, or to 0 if a variable number of entries is allowed.
In the latter case, the functions will return the number of values in
\fInumToGet\fR.  The size of \fIarray\fR should be specified in
\fIarraySize\fR.  The return value is 1 if the user did not enter the given
option.

.SS Functions for Help, Cleanup, and Errors

.nh
.ft B
.nf
int PipPrintHelp(char *\fIprogName\fB, int \fIuseStdErr\fB, int \fIinputFiles\fB,
                 int \fIoutputFiles\fB);

integer*4 function PipPrintHelp(\fIprogName\fB, \fIuseStdErr\fB, \fIinputFiles\fB,
                                \fIoutputFiles\fB)
chararacter*N \fIprogName\fB
integer*4 \fIuseStdErr\fB, \fIinputFiles\fB, \fIoutputFiles\fB
.ft R
.fi

This function produces a complete, formatted listing of options and
their help strings.  The program name should be supplied in
\fIprogName\fR.  The listing is sent to standard output or standard
error depending on whether \fIuseStdErr\fR is 0 or 1.  The usage
summary includes \fIinput_file\fR or \fIinput_files...\fR if
\fIinputFiles\fR is 1 or 2, respectively; and \fIoutput_file\fR or
\fIoutput_files...\fR if \fIoutputFiles\fR is 1 or 2 respectively.


.ft B
.nf
void PipDone(void);
subroutine PipDone()
.ft R
.fi

This call frees all allocated memory and reinitializes all variables so that
another complete round of processing could occur.


.ft B
.nf
int PipGetError(char **\fIerrString\fB);

integer*4 function PipGetError(\fIerrString\fB)
character*N \fIerrString\fB     [Returned argument]
.ft R
.fi

Use this function to get the error string generated by PIP from the last
error.
When called from C and a string is returned, the string is allocated
with malloc() and can be freed with free().


.ft B
.nf
int PipMemoryError(void *\fIptr\fB, char *\fIroutine\fB);
.ft R
.fi

Tests \fIptr\fR and returns 0 if it is non-NULL; otherwise it makes up
an error string including the name given in \fIroutine\fR and calls
\fBPipSetError\fR, then returns -1.

.ft B
.nf
int PipSetError(char *\fIerrString\fB);
.ft R
.fi
Sets the error string and, if PIP has been set to exit on error, prints
an error message and exits.

.SH ERRORS AND RETURN VALUES
.nh
All functions return a negative number if an error occurs.  Functions in which
an option is specified typically return -1 if the option is not a legal one,
or -2 if the option is abbreviated ambiguously.  An error string is available
after an error by calling PipGetError.  Alternatively, the program can call
PipExitOnError at any point, and PIP will print the error string itself and 
exit with an error status.

.SH AUTHOR
David Mastronarde (mast@colorado.edu)
